[
  {
    "name": "Nim_0",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_1",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 3, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 3, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_2",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_3",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_4",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_5",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_6",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 7, 8, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 7, 8, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_7",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_8",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_9",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_10",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_11",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_12",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_13",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_14",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 8, 8, 7, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 8, 8, 7, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_15",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 8, 6, 2, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 8, 6, 2, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_16",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 2, 8, 0, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 2, 8, 0, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_17",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_18",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_19",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 3, 3, 5, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 3, 3, 5, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_20",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 1, 2, 9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 1, 2, 9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_21",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 8, 7, 2, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 8, 7, 2, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_22",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_23",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 7, 0, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 7, 0, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_24",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_25",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_26",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 6, 5, 6, 0, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 6, 5, 6, 0, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_27",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 2, 4, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 2, 4, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_28",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 5, 3, 8, 3, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 5, 3, 8, 3, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_29",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_30",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_31",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_32",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 1, 3, 9, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 1, 3, 9, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_33",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 6, 3, 8, 0, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 6, 3, 8, 0, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_34",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 8, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 8, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_35",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 8, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 8, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_36",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_37",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_38",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_39",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_40",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 5, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 5, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_41",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 9, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 9, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_42",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_43",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_44",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 4, 2, 8, 0, 9, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 4, 2, 8, 0, 9, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_45",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_46",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_47",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_48",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 3, 1, 7, 4, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 3, 1, 7, 4, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_49",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_50",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_51",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 2, 1, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 2, 1, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_52",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_53",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 8, 4, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 8, 4, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_54",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_55",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 8, 0, 3, 5, 4, 1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 8, 0, 3, 5, 4, 1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_56",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 6, 3, 1, 0, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 6, 3, 1, 0, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_57",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 8, 3, 9, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 8, 3, 9, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_58",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_59",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 8, 9, 6, 7, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 8, 9, 6, 7, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_60",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 3, 7, 8, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 3, 7, 8, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_61",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 9, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 9, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_62",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_63",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_64",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 7, 4, 1, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 7, 4, 1, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_65",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 4, 6, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 4, 6, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_66",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 5, 0, 7, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 5, 0, 7, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_67",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 5, 7, 1, 2, 0, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 5, 7, 1, 2, 0, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_68",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_69",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_70",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_71",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_72",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 0, 8, 4, 6, 7, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 0, 8, 4, 6, 7, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_73",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_74",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 5, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 5, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_75",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 7, 3, 6, 1, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 7, 3, 6, 1, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_76",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_77",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_78",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 8, 1, 5, 5, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 8, 1, 5, 5, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_79",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_80",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_81",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 0, 0, 1, 6, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 0, 0, 1, 6, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_82",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_83",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 2, 2, 2, 5, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 2, 2, 2, 5, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_84",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 5, 5, 8, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 5, 5, 8, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_85",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 4, 9, 6, 6, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 4, 9, 6, 6, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_86",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_87",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_88",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 7, 3, 3, 5, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 7, 3, 3, 5, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_89",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_90",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 4, 8, 0, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 4, 8, 0, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_91",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_92",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 4, 5, 6, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 4, 5, 6, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_93",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_94",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_95",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_96",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_97",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 6, 2, 0, 8, 2, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 6, 2, 0, 8, 2, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_98",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_99",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 2, 6, 2, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 2, 6, 2, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_100",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 9, 7, 7, 0, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 9, 7, 7, 0, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_101",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_102",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_103",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 6, 3, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 6, 3, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_104",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 4, 6, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 4, 6, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_105",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_106",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 2, 3, 4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 2, 3, 4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_107",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_108",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_109",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_110",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_111",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_112",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 8, 2, 2, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 8, 2, 2, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_113",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 5, 6, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 5, 6, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_114",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 2, 3, 4, 8, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 2, 3, 4, 8, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_115",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 8, 4, 3, 2, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 8, 4, 3, 2, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_116",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 2, 4, 2, 2, 6, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 2, 4, 2, 2, 6, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_117",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_118",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 2, 3, 3, 4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 2, 3, 3, 4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_119",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 8, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 8, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_120",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 4, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 4, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_121",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 3, 0, 9, 4, 1, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 3, 0, 9, 4, 1, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_122",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 3, 2, 4, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 3, 2, 4, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_123",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 1, 0, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 1, 0, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_124",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 0, 0, 3, 3, 1, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 0, 0, 3, 3, 1, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_125",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 6, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 6, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_126",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 0, 2, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 0, 2, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_127",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 2, 3, 8, 2, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 2, 3, 8, 2, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_128",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 3, 0, 5, 6, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 3, 0, 5, 6, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_129",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 4, 3, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 4, 3, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_130",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 4, 0, 6, 6, 4, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 4, 0, 6, 6, 4, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_131",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_132",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 8, 3, 0, 4, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 8, 3, 0, 4, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_133",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 4, 7, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 4, 7, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_134",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 7, 4, 0, 0, 7, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 7, 4, 0, 0, 7, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_135",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 3, 1, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 3, 1, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_136",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 2, 8, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 2, 8, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_137",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 8, 2, 1, 9, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 8, 2, 1, 9, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_138",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 9, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 9, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_139",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_140",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_141",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 4, 1, 8, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 4, 1, 8, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_142",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 0, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 0, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_143",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 3, 2, 8, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 3, 2, 8, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_144",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 1, 9, 3, 2, 0, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 1, 9, 3, 2, 0, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_145",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 0, 0, 8, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 0, 0, 8, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_146",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 0, 1, 6, 8, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 0, 1, 6, 8, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_147",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_148",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_149",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_150",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 8, 2, 4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 8, 2, 4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_151",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 1, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 1, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_152",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 4, 6, 2, 8, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 4, 6, 2, 8, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_153",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_154",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_155",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_156",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 7, 6, 2, 7, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 7, 6, 2, 7, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_157",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 2, 1, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 2, 1, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_158",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 0, 3, 6, 3, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 0, 3, 6, 3, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_159",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_160",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 0, 9, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 0, 9, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_161",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 7, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 7, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_162",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 9, 0, 6, 3, 5, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 9, 0, 6, 3, 5, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_163",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 7, 2, 0, 6, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 7, 2, 0, 6, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_164",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 9, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 9, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_165",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_166",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 2, 4, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 2, 4, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_167",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 9, 4, 8, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 9, 4, 8, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_168",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 5, 8, 0, 3, 2, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 5, 8, 0, 3, 2, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_169",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 4, 8, 6, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 4, 8, 6, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_170",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 8, 7, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 8, 7, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_171",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_172",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_173",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 9, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 9, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_174",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_175",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 8, 7, 8, 9, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 8, 7, 8, 9, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_176",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 0, 8, 8, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 0, 8, 8, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_177",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_178",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_179",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 3, 4, 5, 2, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 3, 4, 5, 2, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_180",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_181",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_182",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 4, 9, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 4, 9, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_183",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 0, 6, 3, 4, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 0, 6, 3, 4, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_184",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_185",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 1, 7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 1, 7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_186",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 7, 7, 0, 4, 7, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 7, 7, 0, 4, 7, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_187",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 3, 4, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 3, 4, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_188",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 9, 4, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 9, 4, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_189",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_190",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 8, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 8, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_191",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_192",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 8, 7, 4, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 8, 7, 4, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_193",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 3, 9, 2, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 3, 9, 2, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_194",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_195",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_196",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4, 4, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4, 4, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_197",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 1, 1, 1, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 1, 1, 1, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_198",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 9, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 9, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_199",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 7, 8, 7, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 7, 8, 7, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_200",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_201",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 8, 4, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 8, 4, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_202",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_203",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 3, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 3, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_204",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 0, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 0, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_205",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_206",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_207",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_208",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 4, 9, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 4, 9, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_209",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 0, 6, 9, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 0, 6, 9, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_210",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 9, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 9, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_211",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_212",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_213",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_214",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_215",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 3, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 3, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_216",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 2, 1, 3, 6, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 2, 1, 3, 6, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_217",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 5, 8, 1, 6, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 5, 8, 1, 6, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_218",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 9, 6, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 9, 6, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_219",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 3, 8, 1, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 3, 8, 1, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_220",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 5, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 5, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_221",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 3, 8, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 3, 8, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_222",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 8, 8, 8, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 8, 8, 8, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_223",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 9, 9, 3, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 9, 9, 3, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_224",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 2, 8, 5, 4, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 2, 8, 5, 4, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_225",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 4, 1, 0, 9, 7, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 4, 1, 0, 9, 7, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_226",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 4, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 4, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_227",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 9, 4, 7, 0, 4, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 9, 4, 7, 0, 4, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_228",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_229",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 8, 3, 0, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 8, 3, 0, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_230",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_231",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 9, 5, 6, 9, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 9, 5, 6, 9, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_232",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 1, 0, 6, 5, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 1, 0, 6, 5, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_233",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_234",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 3, 7, 1, 0, 0, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 3, 7, 1, 0, 0, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_235",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 7, 3, 8, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 7, 3, 8, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_236",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 0, 3, 4, 7, 4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 0, 3, 4, 7, 4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_237",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 4, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 4, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_238",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 5, 0, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 5, 0, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_239",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 5, 3, 8, 3, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 5, 3, 8, 3, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_240",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_241",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 0, 1, 5, 2, 4, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 0, 1, 5, 2, 4, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_242",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_243",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 7, 6, 6, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 7, 6, 6, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_244",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 0, 7, 3, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 0, 7, 3, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_245",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_246",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 1, 8, 3, 4, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 1, 8, 3, 4, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_247",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_248",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 6, 2, 0, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 6, 2, 0, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_249",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 4, 5, 4, 0, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 4, 5, 4, 0, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_250",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_251",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_252",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 9, 8, 4, 4, 6, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 9, 8, 4, 4, 6, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_253",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_254",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_255",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_256",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 7, 1, 4, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 7, 1, 4, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_257",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_258",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_259",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 9, 4, 7, 1, 4, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 9, 4, 7, 1, 4, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_260",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 1, 9, 8, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 1, 9, 8, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_261",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 9, 0, 9, 7, 2, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 9, 0, 9, 7, 2, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_262",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 8, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 8, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_263",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_264",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_265",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 0, 3, 3, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 0, 3, 3, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_266",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_267",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_268",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 6, 9, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 6, 9, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_269",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 3, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 3, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_270",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 8, 4, 5, 4, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 8, 4, 5, 4, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_271",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_272",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 7, 2, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 7, 2, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_273",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_274",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 3, 1, 8, 7, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 3, 1, 8, 7, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_275",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 8, 7, 1, 6, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 8, 7, 1, 6, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_276",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_277",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 6, 3, 8, 4, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 6, 3, 8, 4, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_278",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 6, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 6, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_279",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 3, 8, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 3, 8, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_280",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_281",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_282",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 6, 5, 3, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 6, 5, 3, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_283",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 7, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 7, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_284",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 8, 1, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 8, 1, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_285",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_286",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_287",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_288",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 6, 1, 5, 2, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 6, 1, 5, 2, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_289",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 0, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 0, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_290",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_291",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_292",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 1, 2, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 1, 2, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_293",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 3, 2, 5, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 3, 2, 5, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_294",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 0, 2, 7, 9, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 0, 2, 7, 9, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_295",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_296",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_297",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_298",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 9, 5, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 9, 5, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_299",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 5, 9, 4, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 5, 9, 4, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_300",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 4, 1, 7, 3, 4, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 4, 1, 7, 3, 4, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_301",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_302",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_303",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 2, 2, 1, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 2, 2, 1, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_304",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_305",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 4, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 4, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_306",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 1, 2, 4, 4, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 1, 2, 4, 4, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_307",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 0, 7, 5, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 0, 7, 5, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_308",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 0, 7, 5, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 0, 7, 5, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_309",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 0, 4, 8, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 0, 4, 8, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_310",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 4, 9, 3, 0, 2, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 4, 9, 3, 0, 2, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_311",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_312",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_313",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_314",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_315",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_316",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 0, 2, 9, 2, 7, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 0, 2, 9, 2, 7, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_317",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_318",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 7, 5, 5, 7, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 7, 5, 5, 7, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_319",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_320",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 7, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 7, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_321",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 2, 0, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 2, 0, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_322",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 3, 3, 5, 3, 4, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 3, 3, 5, 3, 4, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_323",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 9, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 9, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_324",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_325",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 0, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 0, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_326",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_327",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_328",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 9, 0, 2, 0, 4, 8, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 9, 0, 2, 0, 4, 8, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_329",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_330",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 8, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 8, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_331",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 4, 5, 9, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 4, 5, 9, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_332",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 8, 5, 8, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 8, 5, 8, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_333",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6, 7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6, 7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_334",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 3, 9, 1, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 3, 9, 1, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_335",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 5, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 5, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_336",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_337",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 4, 0, 8, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 4, 0, 8, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_338",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 8, 5, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 8, 5, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_339",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_340",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_341",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 3, 6, 2, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 3, 6, 2, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_342",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 5, 1, 1, 6, 4, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 5, 1, 1, 6, 4, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_343",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_344",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 4, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 4, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_345",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 9, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 9, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_346",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 1, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 1, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_347",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 6, 8, 7, 7, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 6, 8, 7, 7, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_348",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 7, 2, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 7, 2, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_349",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_350",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_351",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_352",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_353",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_354",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 9, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 9, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_355",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 8, 0, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 8, 0, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_356",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 7, 6, 0, 3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 7, 6, 0, 3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_357",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 4, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 4, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_358",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_359",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 1, 0, 7, 6, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 1, 0, 7, 6, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_360",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_361",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_362",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_363",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 0, 3, 0, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 0, 3, 0, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_364",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_365",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 7, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 7, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_366",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_367",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_368",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_369",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 0, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 0, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_370",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1, 2, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1, 2, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_371",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_372",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 6, 2, 2, 1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 6, 2, 2, 1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_373",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 3, 1, 6, 1, 5, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 3, 1, 6, 1, 5, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_374",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 2, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 2, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_375",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_376",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 0, 4, 5, 8, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 0, 4, 5, 8, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_377",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_378",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 3, 4, 1, 8, 2, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 3, 4, 1, 8, 2, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_379",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_380",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 1, 4, 4, 2, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 1, 4, 4, 2, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_381",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_382",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 8, 5, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 8, 5, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_383",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 1, 3, 0, 1, 9, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 1, 3, 0, 1, 9, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_384",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_385",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 3, 7, 5, 5, 0, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 3, 7, 5, 5, 0, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_386",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 5, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 5, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_387",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 8, 6, 0, 1, 1, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 8, 6, 0, 1, 1, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_388",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 5, 1, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 5, 1, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_389",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_390",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_391",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 8, 5, 6, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 8, 5, 6, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_392",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 0, 6, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 0, 6, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_393",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 8, 9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 8, 9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_394",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 9, 7, 5, 5, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 9, 7, 5, 5, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_395",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_396",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_397",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 1, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 1, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_398",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_399",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 7, 0, 8, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 7, 0, 8, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_400",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_401",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 6, 2, 7, 0, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 6, 2, 7, 0, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_402",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_403",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_404",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 1, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 1, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_405",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 8, 2, 9, 0, 6, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 8, 2, 9, 0, 6, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_406",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 7, 9, 8, 4, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 7, 9, 8, 4, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_407",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_408",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_409",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 9, 0, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 9, 0, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_410",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 2, 3, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 2, 3, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_411",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 9, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 9, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_412",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_413",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 5, 1, 6, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 5, 1, 6, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_414",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 3, 7, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 3, 7, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_415",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 4, 0, 1, 5, 0, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 4, 0, 1, 5, 0, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_416",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 3, 0, 5, 0, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 3, 0, 5, 0, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_417",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_418",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 2, 1, 5, 3, 4, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 2, 1, 5, 3, 4, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_419",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 1, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 1, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_420",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_421",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_422",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 5, 4, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 5, 4, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_423",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_424",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 6, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 6, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_425",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0, 5, 7, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0, 5, 7, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_426",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 6, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 6, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_427",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_428",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 5, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 5, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_429",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_430",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_431",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_432",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 1, 8, 6, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 1, 8, 6, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_433",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_434",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 4, 9, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 4, 9, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_435",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 6, 4, 0, 6, 2, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 6, 4, 0, 6, 2, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_436",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 5, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 5, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_437",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 0, 8, 5, 4, 0, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 0, 8, 5, 4, 0, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_438",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 1, 9, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 1, 9, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_439",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_440",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 8, 2, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 8, 2, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_441",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 0, 3, 9, 2, 9, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 0, 3, 9, 2, 9, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_442",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 1, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 1, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_443",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 9, 0, 2, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 9, 0, 2, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_444",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 8, 9, 6, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 8, 9, 6, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_445",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 2, 9, 6, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 2, 9, 6, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_446",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_447",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_448",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_449",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_450",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_451",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 4, 8, 2, 7, 3, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 4, 8, 2, 7, 3, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_452",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_453",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_454",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 2, 0, 0, 3, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 2, 0, 0, 3, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_455",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 7, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 7, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_456",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 1, 6, 0, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 1, 6, 0, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_457",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_458",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 0, 9, 4, 2, 8, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 0, 9, 4, 2, 8, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_459",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_460",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 0, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 0, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_461",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 6, 4, 2, 6, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 6, 4, 2, 6, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_462",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_463",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 1, 0, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 1, 0, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_464",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 1, 5, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 1, 5, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_465",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_466",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 3, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 3, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_467",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 7, 0, 3, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 7, 0, 3, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_468",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 1, 2, 8, 0, 9, 9, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 1, 2, 8, 0, 9, 9, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_469",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 9, 9, 4, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 9, 9, 4, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_470",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_471",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_472",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_473",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_474",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 2, 1, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 2, 1, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_475",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 7, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 7, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_476",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 8, 4, 0, 2, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 8, 4, 0, 2, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_477",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 0, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 0, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_478",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 6, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 6, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_479",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_480",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_481",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 3, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 3, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_482",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 0, 2, 6, 4, 1, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 0, 2, 6, 4, 1, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_483",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 3, 1, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 3, 1, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_484",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_485",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 7, 7, 5, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 7, 7, 5, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_486",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 4, 0, 5, 2, 7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 4, 0, 5, 2, 7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_487",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 6, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 6, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_488",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_489",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 9, 3, 0, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 9, 3, 0, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_490",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 0, 5, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 0, 5, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_491",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_492",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 7, 5, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 7, 5, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_493",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 4, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 4, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_494",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 4, 7, 0, 3, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 4, 7, 0, 3, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_495",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_496",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_497",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_498",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 9, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 9, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_499",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 5, 6, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 5, 6, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_500",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 5, 2, 6, 7, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 5, 2, 6, 7, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_501",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 1, 5, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 1, 5, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_502",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 9, 5, 8, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 9, 5, 8, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_503",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_504",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_505",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_506",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_507",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_508",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_509",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_510",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_511",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_512",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_513",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_514",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1, 2, 2, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1, 2, 2, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_515",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 1, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 1, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_516",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 0, 1, 4, 9, 7, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 0, 1, 4, 9, 7, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_517",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_518",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 0, 0, 1, 9, 1, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 0, 0, 1, 9, 1, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_519",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 7, 3, 2, 2, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 7, 3, 2, 2, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_520",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_521",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_522",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_523",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 1, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 1, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_524",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_525",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_526",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 5, 6, 9, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 5, 6, 9, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_527",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 0, 6, 3, 6, 3, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 0, 6, 3, 6, 3, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_528",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_529",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 3, 4, 6, 4, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 3, 4, 6, 4, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_530",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 1, 5, 2, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 1, 5, 2, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_531",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 3, 0, 8, 7, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 3, 0, 8, 7, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_532",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5, 6, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5, 6, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_533",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 8, 9, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 8, 9, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_534",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 2, 4, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 2, 4, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_535",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 0, 0, 9, 0, 5, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 0, 0, 9, 0, 5, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_536",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_537",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_538",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 8, 8, 6, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 8, 8, 6, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_539",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_540",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 4, 5, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 4, 5, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_541",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_542",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_543",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 9, 8, 8, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 9, 8, 8, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_544",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 2, 8, 7, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 2, 8, 7, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_545",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 4, 4, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 4, 4, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_546",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 1, 5, 2, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 1, 5, 2, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_547",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_548",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 2, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 2, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_549",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 5, 6, 2, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 5, 6, 2, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_550",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 9, 4, 3, 9, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 9, 4, 3, 9, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_551",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 9, 3, 5, 0, 2, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 9, 3, 5, 0, 2, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_552",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_553",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_554",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_555",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 9, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 9, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_556",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 3, 1, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 3, 1, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_557",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_558",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 5, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 5, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_559",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_560",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 2, 0, 1, 4, 8, 9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 2, 0, 1, 4, 8, 9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_561",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_562",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 4, 3, 2, 2, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 4, 3, 2, 2, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_563",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_564",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_565",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 6, 3, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 6, 3, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_566",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_567",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_568",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_569",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 4, 9, 8, 2, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 4, 9, 8, 2, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_570",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5, 4, 7, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5, 4, 7, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_571",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_572",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 3, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 3, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_573",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1, 8, 8, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1, 8, 8, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_574",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_575",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_576",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 4, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 4, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_577",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 3, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 3, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_578",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 9, 7, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 9, 7, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_579",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_580",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 0, 1, 2, 3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 0, 1, 2, 3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_581",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 7, 0, 3, 4, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 7, 0, 3, 4, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_582",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 5, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 5, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_583",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 9, 5, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 9, 5, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_584",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 5, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 5, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_585",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 5, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 5, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_586",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 3, 7, 6, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 3, 7, 6, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_587",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 7, 5, 0, 0, 4, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 7, 5, 0, 0, 4, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_588",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 5, 8, 8, 3, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 5, 8, 8, 3, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_589",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0, 3, 6, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0, 3, 6, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_590",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_591",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0, 4, 6, 3, 1, 6, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0, 4, 6, 3, 1, 6, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_592",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 0, 3, 8, 5, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 0, 3, 8, 5, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_593",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 9, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 9, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_594",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_595",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 1, 6, 7, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 1, 6, 7, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_596",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 1, 3, 7, 6, 7, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 1, 3, 7, 6, 7, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_597",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 2, 5, 6, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 2, 5, 6, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_598",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 8, 3, 7, 3, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 8, 3, 7, 3, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_599",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_600",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 6, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 6, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_601",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_602",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 1, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 1, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_603",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_604",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_605",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 6, 9, 1, 9, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 6, 9, 1, 9, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_606",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 3, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 3, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_607",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 6, 0, 8, 0, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 6, 0, 8, 0, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_608",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 5, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 5, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_609",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 8, 6, 9, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 8, 6, 9, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_610",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_611",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 6, 7, 1, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 6, 7, 1, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_612",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 1, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 1, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_613",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 1, 4, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 1, 4, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_614",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 1, 0, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 1, 0, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_615",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 3, 8, 9, 3, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 3, 8, 9, 3, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_616",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 5, 9, 1, 3, 3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 5, 9, 1, 3, 3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_617",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_618",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 2, 4, 6, 5, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 2, 4, 6, 5, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_619",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 0, 2, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 0, 2, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_620",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_621",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 1, 3, 1, 7, 9, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 1, 3, 1, 7, 9, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_622",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_623",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 8, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 8, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_624",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 5, 6, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 5, 6, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_625",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_626",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 4, 7, 4, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 4, 7, 4, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_627",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 4, 6, 0, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 4, 6, 0, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_628",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 6, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 6, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_629",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_630",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 3, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 3, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_631",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 3, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 3, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_632",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 2, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 2, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_633",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 5, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 5, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_634",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 8, 0, 1, 1, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 8, 0, 1, 1, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_635",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_636",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 5, 6, 5, 4, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 5, 6, 5, 4, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_637",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 0, 8, 7, 1, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 0, 8, 7, 1, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_638",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_639",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 2, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 2, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_640",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_641",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 9, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 9, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_642",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_643",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 0, 7, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 0, 7, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_644",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_645",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 2, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 2, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_646",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 7, 9, 1, 0, 5, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 7, 9, 1, 0, 5, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_647",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 3, 8, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 3, 8, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_648",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 8, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 8, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_649",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 0, 7, 9, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 0, 7, 9, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_650",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 0, 0, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 0, 0, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_651",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_652",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 8, 0, 9, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 8, 0, 9, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_653",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 1, 7, 6, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 1, 7, 6, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_654",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 8, 2, 8, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 8, 2, 8, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_655",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 5, 8, 5, 6, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 5, 8, 5, 6, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_656",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 9, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 9, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_657",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_658",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 6, 5, 4, 5, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 6, 5, 4, 5, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_659",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_660",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 9, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 9, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_661",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 5, 4, 3, 6, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 5, 4, 3, 6, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_662",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 7, 8, 5, 2, 4, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 7, 8, 5, 2, 4, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_663",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 1, 3, 5, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 1, 3, 5, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_664",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_665",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 6, 7, 1, 5, 1, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 6, 7, 1, 5, 1, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_666",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 6, 0, 7, 6, 6, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 6, 0, 7, 6, 6, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_667",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 8, 1, 8, 5, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 8, 1, 8, 5, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_668",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 4, 4, 5, 1, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 4, 4, 5, 1, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_669",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 5, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 5, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_670",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 6, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 6, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_671",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_672",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_673",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_674",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 7, 2, 0, 6, 9, 0, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 7, 2, 0, 6, 9, 0, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_675",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 4, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 4, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_676",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_677",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_678",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 3, 3, 4, 0, 6, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 3, 3, 4, 0, 6, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_679",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 3, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 3, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_680",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_681",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 7, 4, 9, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 7, 4, 9, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_682",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 3, 6, 2, 5, 1, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 3, 6, 2, 5, 1, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_683",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 6, 2, 3, 8, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 6, 2, 3, 8, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_684",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_685",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 0, 6, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 0, 6, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_686",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_687",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 6, 1, 4, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 6, 1, 4, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_688",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 7, 6, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 7, 6, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_689",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_690",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 6, 5, 6, 1, 5, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 6, 5, 6, 1, 5, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_691",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 9, 0, 4, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 9, 0, 4, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_692",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_693",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 6, 2, 7, 2, 5, 9, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 6, 2, 7, 2, 5, 9, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_694",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 5, 9, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 5, 9, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_695",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 5, 4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 5, 4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_696",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_697",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_698",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 0, 6, 7, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 0, 6, 7, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_699",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 0, 8, 5, 3, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 0, 8, 5, 3, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_700",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_701",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_702",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_703",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 7, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 7, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_704",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 8, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 8, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_705",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 8, 4, 5, 8, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 8, 4, 5, 8, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_706",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_707",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_708",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 2, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 2, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_709",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_710",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_711",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_712",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 3, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 3, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_713",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 3, 0, 3, 6, 8, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 3, 0, 3, 6, 8, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_714",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 2, 8, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 2, 8, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_715",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 3, 8, 2, 6, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 3, 8, 2, 6, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_716",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 9, 8, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 9, 8, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_717",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_718",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_719",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 8, 9, 2, 1, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 8, 9, 2, 1, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_720",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 8, 3, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 8, 3, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_721",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_722",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_723",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_724",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 0, 5, 9, 2, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 0, 5, 9, 2, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_725",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_726",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_727",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 8, 1, 2, 6, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 8, 1, 2, 6, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_728",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_729",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 4, 4, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 4, 4, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_730",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_731",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 3, 7, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 3, 7, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_732",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 2, 8, 9, 2, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 2, 8, 9, 2, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_733",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 0, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 0, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_734",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_735",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 4, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 4, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_736",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 5, 2, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 5, 2, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_737",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 9, 7, 1, 6, 0, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 9, 7, 1, 6, 0, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_738",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 2, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 2, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_739",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_740",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 5, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 5, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_741",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_742",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_743",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_744",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 8, 3, 4, 0, 1, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 8, 3, 4, 0, 1, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_745",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_746",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 5, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 5, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_747",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 6, 1, 2, 5, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 6, 1, 2, 5, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_748",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 9, 9, 6, 8, 3, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 9, 9, 6, 8, 3, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_749",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 2, 6, 8, 6, 1, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 2, 6, 8, 6, 1, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_750",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_751",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 0, 3, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 0, 3, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_752",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 9, 2, 8, 3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 9, 2, 8, 3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_753",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 8, 1, 6, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 8, 1, 6, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_754",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 8, 7, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 8, 7, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_755",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 7, 0, 9, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 7, 0, 9, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_756",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 3, 7, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 3, 7, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_757",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 3, 8, 5, 6, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 3, 8, 5, 6, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_758",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 5, 7, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 5, 7, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_759",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 5, 3, 8, 0, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 5, 3, 8, 0, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_760",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 6, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 6, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_761",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_762",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 0, 7, 1, 3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 0, 7, 1, 3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_763",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 1, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 1, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_764",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_765",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 0, 3, 2, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 0, 3, 2, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_766",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 5, 4, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 5, 4, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_767",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_768",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 7, 9, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 7, 9, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_769",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 2, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 2, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_770",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 0, 2, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 0, 2, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_771",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 8, 5, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 8, 5, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_772",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 4, 2, 8, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 4, 2, 8, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_773",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_774",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_775",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_776",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 3, 2, 0, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 3, 2, 0, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_777",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_778",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 5, 8, 7, 6, 0, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 5, 8, 7, 6, 0, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_779",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 6, 2, 4, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 6, 2, 4, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_780",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_781",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 1, 2, 5, 1, 4, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 1, 2, 5, 1, 4, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_782",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 8, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 8, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_783",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_784",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 4, 2, 2, 2, 0, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 4, 2, 2, 2, 0, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_785",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 9, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 9, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_786",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_787",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 5, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 5, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_788",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 3, 6, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 3, 6, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_789",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 4, 0, 8, 7, 0, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 4, 0, 8, 7, 0, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_790",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 1, 9, 3, 5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 1, 9, 3, 5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_791",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 3, 7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 3, 7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_792",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 9, 8, 3, 6, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 9, 8, 3, 6, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_793",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 5, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 5, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_794",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_795",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 8, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 8, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_796",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 9, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 9, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_797",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_798",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 8, 2, 3, 0, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 8, 2, 3, 0, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_799",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 8, 2, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 8, 2, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_800",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 1, 9, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 1, 9, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_801",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_802",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 5, 7, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 5, 7, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_803",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 5, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 5, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_804",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 3, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 3, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_805",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_806",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 7, 1, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 7, 1, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_807",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 4, 9, 5, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 4, 9, 5, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_808",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 9, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 9, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_809",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 8, 6, 3, 6, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 8, 6, 3, 6, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_810",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 1, 2, 0, 9, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 1, 2, 0, 9, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_811",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 7, 3, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 7, 3, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_812",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_813",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 8, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 8, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_814",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_815",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 9, 0, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 9, 0, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_816",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 4, 8, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 4, 8, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_817",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 0, 6, 4, 3, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 0, 6, 4, 3, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_818",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 9, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 9, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_819",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 9, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 9, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_820",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 4, 3, 6, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 4, 3, 6, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_821",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 3, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 3, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_822",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 2, 9, 7, 5, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 2, 9, 7, 5, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_823",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 4, 6, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 4, 6, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_824",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 1, 4, 3, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 1, 4, 3, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_825",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 5, 9, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 5, 9, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_826",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 0, 9, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 0, 9, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_827",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 5, 8, 3, 6, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 5, 8, 3, 6, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_828",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_829",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 0, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 0, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_830",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 5, 1, 8, 9, 8, 0, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 5, 1, 8, 9, 8, 0, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_831",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_832",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_833",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 0, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 0, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_834",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 5, 3, 6, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 5, 3, 6, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_835",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 4, 3, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 4, 3, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_836",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_837",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_838",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 8, 1, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 8, 1, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_839",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_840",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 3, 6, 4, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 3, 6, 4, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_841",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_842",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 9, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 9, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_843",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 3, 0, 3, 9, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 3, 0, 3, 9, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_844",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 6, 7, 4, 1, 0, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 6, 7, 4, 1, 0, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_845",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_846",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 4, 7, 4, 0, 4, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 4, 7, 4, 0, 4, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_847",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 1, 6, 0, 9, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 1, 6, 0, 9, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_848",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 6, 7, 9, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 6, 7, 9, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_849",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_850",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 1, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 1, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_851",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 1, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 1, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_852",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 1, 6, 0, 8, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 1, 6, 0, 8, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_853",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 0, 9, 4, 5, 7, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 0, 9, 4, 5, 7, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_854",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 5, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 5, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_855",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 4, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 4, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_856",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 9, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 9, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_857",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_858",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 3, 7, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 3, 7, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_859",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 3, 6, 1, 6, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 3, 6, 1, 6, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_860",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 9, 3, 0, 0, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 9, 3, 0, 0, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_861",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 2, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 2, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_862",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_863",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 0, 6, 2, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 0, 6, 2, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_864",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 1, 6, 4, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 1, 6, 4, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_865",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_866",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2, 1, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2, 1, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_867",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 2, 2, 3, 5, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 2, 2, 3, 5, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_868",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 6, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 6, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_869",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 1, 8, 7, 8, 3, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 1, 8, 7, 8, 3, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_870",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 8, 5, 9, 9, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 8, 5, 9, 9, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_871",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 5, 9, 3, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 5, 9, 3, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_872",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_873",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_874",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 8, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 8, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_875",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 4, 7, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 4, 7, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_876",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 7, 5, 1, 2, 8, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 7, 5, 1, 2, 8, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_877",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 3, 7, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 3, 7, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_878",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 6, 8, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 6, 8, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_879",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 7, 3, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 7, 3, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_880",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 0, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 0, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_881",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 8, 9, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 8, 9, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_882",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 6, 0, 1, 9, 0, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 6, 0, 1, 9, 0, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_883",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_884",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 0, 8, 8, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 0, 8, 8, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_885",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 8, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 8, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_886",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 0, 5, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 0, 5, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_887",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 2, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 2, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_888",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 8, 8, 8, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 8, 8, 8, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_889",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_890",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 1, 9, 1, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 1, 9, 1, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_891",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_892",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 5, 4, 6, 5, 0, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 5, 4, 6, 5, 0, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_893",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 3, 7, 8, 0, 5, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 3, 7, 8, 0, 5, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_894",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 3, 2, 0, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 3, 2, 0, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_895",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 0, 7, 3, 3, 2, 3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 0, 7, 3, 3, 2, 3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_896",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 4, 9, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 4, 9, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_897",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_898",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 7, 2, 6, 2, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 7, 2, 6, 2, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_899",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 5, 0, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 5, 0, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_900",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 7, 5, 7, 7, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 7, 5, 7, 7, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_901",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5, 3, 6, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5, 3, 6, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_902",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 3, 7, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 3, 7, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_903",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_904",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 4, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 4, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_905",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 3, 7, 2, 2, 0, 5, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 3, 7, 2, 2, 0, 5, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_906",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 0, 8, 0, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 0, 8, 0, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_907",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 4, 3, 2, 8, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 4, 3, 2, 8, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_908",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 3, 3, 5, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 3, 3, 5, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_909",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_910",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 8, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 8, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_911",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 5, 4, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 5, 4, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_912",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 0, 0, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 0, 0, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_913",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 9, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 9, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_914",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 9, 1, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 9, 1, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_915",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 3, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 3, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_916",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_917",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 0, 3, 8, 8, 6, 4, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 0, 3, 8, 8, 6, 4, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_918",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 8, 2, 2, 6, 5, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 8, 2, 2, 6, 5, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_919",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_920",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 6, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 6, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_921",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 1, 8, 4, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 1, 8, 4, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_922",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 0, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 0, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_923",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 3, 7, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 3, 7, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_924",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 5, 3, 4, 1, 3, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 5, 3, 4, 1, 3, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_925",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 1, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 1, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_926",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 6, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 6, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_927",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_928",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 8, 4, 9, 5, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 8, 4, 9, 5, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_929",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 3, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 3, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_930",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 2, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 2, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_931",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 8, 6, 2, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 8, 6, 2, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_932",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 6, 8, 3, 3, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 6, 8, 3, 3, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_933",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 1, 8, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 1, 8, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_934",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 2, 6, 6, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 2, 6, 6, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_935",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 3, 9, 8, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 3, 9, 8, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_936",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 6, 2, 2, 0, 4, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 6, 2, 2, 0, 4, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_937",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 4, 0, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 4, 0, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_938",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 8, 9, 1, 1, 1, 2, 6, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 8, 9, 1, 1, 1, 2, 6, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_939",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_940",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 8, 6, 5, 0, 7, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 8, 6, 5, 0, 7, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_941",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 8, 9, 3, 4, 6, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 8, 9, 3, 4, 6, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_942",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 7, 6, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 7, 6, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_943",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 1, 2, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 1, 2, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_944",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_945",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 2, 7, 5, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 2, 7, 5, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_946",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 6, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 6, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_947",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 1, 3, 9, 3, 0, 1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 1, 3, 9, 3, 0, 1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_948",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 0, 0, 2, 4, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 0, 0, 2, 4, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_949",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 9, 2, 4, 7, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 9, 2, 4, 7, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_950",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 2, 7, 3, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 2, 7, 3, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_951",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 0, 4, 3, 0, 9, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 0, 4, 3, 0, 9, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_952",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 7, 8, 9, 9, 4, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 7, 8, 9, 9, 4, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_953",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_954",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 6, 3, 1, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 6, 3, 1, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_955",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 0, 4, 4, 8, 1, 8, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 0, 4, 4, 8, 1, 8, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_956",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_957",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 6, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 6, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_958",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 5, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 5, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_959",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 1, 0, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 1, 0, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_960",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 8, 2, 2, 1, 1, 3, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 8, 2, 2, 1, 1, 3, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_961",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 1, 6, 7, 7, 9, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 1, 6, 7, 7, 9, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_962",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 2, 6, 1, 3, 8, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 2, 6, 1, 3, 8, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_963",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 1, 1, 8, 4, 3, 2, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 1, 1, 8, 4, 3, 2, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_964",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 1, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 1, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_965",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 1, 3, 5, 6, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 1, 3, 5, 6, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_966",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 5, 2, 2, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 5, 2, 2, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_967",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[4, 9, 4, 2, 2, 9, 3, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[4, 9, 4, 2, 2, 9, 3, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_968",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 2, 4, 0, 1, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 2, 4, 0, 1, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_969",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[0, 0, 2, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[0, 0, 2, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_970",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 8, 1, 1, 1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 8, 1, 1, 1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_971",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 9, 8, 8, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 9, 8, 8, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_972",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 4, 1, 4, 9, 2, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 4, 1, 4, 9, 2, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_973",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_974",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_975",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 2, 2, 5]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 2, 2, 5]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_976",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 3, 4, 8, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 3, 4, 8, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_977",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 5, 1, 4, 6, 9, 6, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 5, 1, 4, 6, 9, 6, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_978",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 8, 2, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 8, 2, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_979",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 3, 4, 3, 3, 8, 2, 2, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 3, 4, 3, 3, 8, 2, 2, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_980",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 8, 1, 3, 0, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 8, 1, 3, 0, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_981",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 5, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 5, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_982",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 0, 2, 1, 4, 4, 7, 8, 6]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 0, 2, 1, 4, 4, 7, 8, 6]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_983",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 9, 4, 8, 4, 7]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 9, 4, 8, 4, 7]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_984",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_985",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 7, 9, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 7, 9, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_986",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 1, 0, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 1, 0, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_987",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 8, 9, 8, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 8, 9, 8, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_988",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 4, 8]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 4, 8]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_989",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[2, 5, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[2, 5, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_990",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[3, 9, 1, 3, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[3, 9, 1, 3, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_991",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 0, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 0, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_992",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 4, 0, 9]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 4, 0, 9]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_993",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 7, 4, 9, 7, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 7, 4, 9, 7, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_994",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[7, 1, 4]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[7, 1, 4]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_995",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[8, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[8, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_996",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[9, 2, 1]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[9, 2, 1]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_997",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[6, 5, 1, 8, 1, 9, 8, 1, 2]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[6, 5, 1, 8, 1, 9, 8, 1, 2]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_998",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[1, 4, 0, 2, 0, 9, 0, 0]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[1, 4, 0, 2, 0, 9, 0, 0]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Nim_999",
    "sat": "def sat(cert: List[List[int]], heaps: List[int]=[5, 5, 3, 0, 1, 3]):\n    assert type(cert) is list and all(type(a) is list and all(type(b) is int for b in a) for a in cert), 'cert must be of type List[List[int]]'  # cert is a sufficient list of desirable states to leave for opponent\n    good_leaves = {tuple(h) for h in cert}  # for efficiency, we keep track of h as a tuple of n non-negative ints\n    cache = {}\n\n    def is_good_leave(h):\n        if h in cache:\n            return cache[h]\n        next_states = [(*h[:i], k, *h[i + 1:]) for i in range(len(h)) for k in range(h[i])]\n        conjecture = (h in good_leaves)\n        if conjecture:  # check that it is a good leave\n            assert not any(is_good_leave(s) for s in next_states)\n        else:  # check that it is a bad leave, only need to check one move\n            assert is_good_leave(next(s for s in next_states if s in good_leaves))\n        cache[h] = conjecture\n        return conjecture\n\n    return is_good_leave(tuple(heaps)) == (tuple(heaps) in good_leaves)",
    "sols": [
      "def sol(heaps=[5, 5, 3, 0, 1, 3]):\n    import itertools\n\n    def val(h):  # return True if h is a good state to leave things in\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    return [list(h) for h in itertools.product(*[range(i + 1) for i in heaps]) if val(h)]"
    ],
    "timeout": 10
  },
  {
    "name": "Mastermind_0",
    "sat": "def sat(transcripts: List[str], max_moves: int=10):\n    assert type(transcripts) is list and all(type(a) is str for a in transcripts), 'transcripts must be of type List[str]'\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=10):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "timeout": 10
  },
  {
    "name": "Mastermind_1",
    "sat": "def sat(transcripts: List[str], max_moves: int=6):\n    assert type(transcripts) is list and all(type(a) is str for a in transcripts), 'transcripts must be of type List[str]'\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=6):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "timeout": 10
  },
  {
    "name": "Mastermind_2",
    "sat": "def sat(transcripts: List[str], max_moves: int=8):\n    assert type(transcripts) is list and all(type(a) is str for a in transcripts), 'transcripts must be of type List[str]'\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "sols": [
      "def sol(max_moves=8):\n    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "timeout": 10
  },
  {
    "name": "TicTacToeX_0",
    "sat": "def sat(good_boards: List[str]):\n    assert type(good_boards) is list and all(type(a) is str for a in good_boards), 'good_boards must be of type List[str]'\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.\n        x |= 1 << next(i for i in range(9) if (x | (1 << i), o) in board_bit_reps)\n        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))\n\n    return tie(0, 0)",
    "sols": [
      "def sol():\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[o]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and o_move(x | (1 << i), o):\n                good_boards.append(\"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + (i == j)] for j in range(9)))\n                return True\n        return False  # O wins\n\n    def o_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[x] or x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not x_move(x, o | (1 << i)):\n                return False\n        return True  # O wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ]
  },
  {
    "name": "TicTacToeO_0",
    "sat": "def sat(good_boards: List[str]):\n    assert type(good_boards) is list and all(type(a) is str for a in good_boards), 'good_boards must be of type List[str]'\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.\n        if o | x != 511:\n            o |= 1 << next(i for i in range(9) if (x, o | (1 << i)) in board_bit_reps)\n        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))\n\n    return all(tie(1 << i, 0) for i in range(9))",
    "sols": [
      "def sol():\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if o wins or ties, x's turn to move\n        if win[o] or x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not o_move(x | (1 << i), o):\n                return False\n        return True  # O wins/ties\n\n    def o_move(x, o):  # returns True if o wins or ties, o's turn to move\n        if win[x]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and x_move(x, o | (1 << i)):\n                good_boards.append(\n                    \"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + 2 * (i == j)] for j in range(9)))\n                return True\n        return False  # X wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ]
  },
  {
    "name": "RockPaperScissors_0",
    "sat": "def sat(probs: List[float]):\n    assert type(probs) is list and all(type(a) is float for a in probs), 'probs must be of type List[float]'  # rock prob, paper prob, scissors prob\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6",
    "sols": [
      "def sol():\n    return [1 / 3] * 3"
    ]
  }
]