[
  {
    "name": "BirthdayParadox_0",
    "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_1",
    "sat": "def sat(n: int, year_len: int=60182):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_2",
    "sat": "def sat(n: int, year_len: int=2):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_3",
    "sat": "def sat(n: int, year_len: int=3):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_4",
    "sat": "def sat(n: int, year_len: int=4):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_5",
    "sat": "def sat(n: int, year_len: int=5):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_6",
    "sat": "def sat(n: int, year_len: int=6):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_7",
    "sat": "def sat(n: int, year_len: int=7):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_8",
    "sat": "def sat(n: int, year_len: int=8):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_9",
    "sat": "def sat(n: int, year_len: int=9):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_10",
    "sat": "def sat(n: int, year_len: int=10):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=10):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_11",
    "sat": "def sat(n: int, year_len: int=11):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=11):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_12",
    "sat": "def sat(n: int, year_len: int=12):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=12):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_13",
    "sat": "def sat(n: int, year_len: int=13):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=13):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_14",
    "sat": "def sat(n: int, year_len: int=14):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=14):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_15",
    "sat": "def sat(n: int, year_len: int=15):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=15):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_16",
    "sat": "def sat(n: int, year_len: int=16):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=16):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_17",
    "sat": "def sat(n: int, year_len: int=17):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=17):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_18",
    "sat": "def sat(n: int, year_len: int=18):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=18):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_19",
    "sat": "def sat(n: int, year_len: int=19):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=19):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_20",
    "sat": "def sat(n: int, year_len: int=20):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=20):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_21",
    "sat": "def sat(n: int, year_len: int=21):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=21):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_22",
    "sat": "def sat(n: int, year_len: int=22):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=22):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_23",
    "sat": "def sat(n: int, year_len: int=23):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=23):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_24",
    "sat": "def sat(n: int, year_len: int=24):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=24):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_25",
    "sat": "def sat(n: int, year_len: int=25):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=25):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_26",
    "sat": "def sat(n: int, year_len: int=26):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=26):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_27",
    "sat": "def sat(n: int, year_len: int=27):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=27):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_28",
    "sat": "def sat(n: int, year_len: int=28):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=28):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_29",
    "sat": "def sat(n: int, year_len: int=29):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=29):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_30",
    "sat": "def sat(n: int, year_len: int=30):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=30):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_31",
    "sat": "def sat(n: int, year_len: int=31):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=31):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_32",
    "sat": "def sat(n: int, year_len: int=32):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=32):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_33",
    "sat": "def sat(n: int, year_len: int=33):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=33):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_34",
    "sat": "def sat(n: int, year_len: int=34):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=34):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_35",
    "sat": "def sat(n: int, year_len: int=35):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=35):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_36",
    "sat": "def sat(n: int, year_len: int=36):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=36):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_37",
    "sat": "def sat(n: int, year_len: int=37):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=37):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_38",
    "sat": "def sat(n: int, year_len: int=38):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=38):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_39",
    "sat": "def sat(n: int, year_len: int=39):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=39):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_40",
    "sat": "def sat(n: int, year_len: int=40):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=40):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_41",
    "sat": "def sat(n: int, year_len: int=41):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=41):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_42",
    "sat": "def sat(n: int, year_len: int=42):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=42):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_43",
    "sat": "def sat(n: int, year_len: int=43):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=43):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_44",
    "sat": "def sat(n: int, year_len: int=44):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=44):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_45",
    "sat": "def sat(n: int, year_len: int=45):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=45):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_46",
    "sat": "def sat(n: int, year_len: int=46):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=46):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_47",
    "sat": "def sat(n: int, year_len: int=47):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=47):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_48",
    "sat": "def sat(n: int, year_len: int=48):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=48):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_49",
    "sat": "def sat(n: int, year_len: int=49):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=49):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_50",
    "sat": "def sat(n: int, year_len: int=50):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=50):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_51",
    "sat": "def sat(n: int, year_len: int=51):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=51):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_52",
    "sat": "def sat(n: int, year_len: int=52):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=52):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_53",
    "sat": "def sat(n: int, year_len: int=53):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=53):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_54",
    "sat": "def sat(n: int, year_len: int=54):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=54):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_55",
    "sat": "def sat(n: int, year_len: int=55):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=55):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_56",
    "sat": "def sat(n: int, year_len: int=56):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=56):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_57",
    "sat": "def sat(n: int, year_len: int=57):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=57):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_58",
    "sat": "def sat(n: int, year_len: int=58):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=58):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_59",
    "sat": "def sat(n: int, year_len: int=59):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=59):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_60",
    "sat": "def sat(n: int, year_len: int=60):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=60):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_61",
    "sat": "def sat(n: int, year_len: int=61):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=61):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_62",
    "sat": "def sat(n: int, year_len: int=62):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=62):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_63",
    "sat": "def sat(n: int, year_len: int=63):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=63):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_64",
    "sat": "def sat(n: int, year_len: int=64):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=64):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_65",
    "sat": "def sat(n: int, year_len: int=65):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=65):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_66",
    "sat": "def sat(n: int, year_len: int=66):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=66):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_67",
    "sat": "def sat(n: int, year_len: int=67):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=67):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_68",
    "sat": "def sat(n: int, year_len: int=68):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=68):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_69",
    "sat": "def sat(n: int, year_len: int=69):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=69):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_70",
    "sat": "def sat(n: int, year_len: int=70):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=70):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_71",
    "sat": "def sat(n: int, year_len: int=71):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=71):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_72",
    "sat": "def sat(n: int, year_len: int=72):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=72):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_73",
    "sat": "def sat(n: int, year_len: int=73):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=73):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_74",
    "sat": "def sat(n: int, year_len: int=74):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=74):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_75",
    "sat": "def sat(n: int, year_len: int=75):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=75):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_76",
    "sat": "def sat(n: int, year_len: int=76):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=76):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_77",
    "sat": "def sat(n: int, year_len: int=77):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=77):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_78",
    "sat": "def sat(n: int, year_len: int=78):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=78):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_79",
    "sat": "def sat(n: int, year_len: int=79):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=79):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_80",
    "sat": "def sat(n: int, year_len: int=80):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=80):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_81",
    "sat": "def sat(n: int, year_len: int=81):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=81):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_82",
    "sat": "def sat(n: int, year_len: int=82):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=82):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_83",
    "sat": "def sat(n: int, year_len: int=83):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=83):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_84",
    "sat": "def sat(n: int, year_len: int=84):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=84):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_85",
    "sat": "def sat(n: int, year_len: int=85):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=85):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_86",
    "sat": "def sat(n: int, year_len: int=86):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=86):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_87",
    "sat": "def sat(n: int, year_len: int=87):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=87):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_88",
    "sat": "def sat(n: int, year_len: int=88):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=88):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_89",
    "sat": "def sat(n: int, year_len: int=89):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=89):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_90",
    "sat": "def sat(n: int, year_len: int=90):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=90):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_91",
    "sat": "def sat(n: int, year_len: int=91):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=91):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_92",
    "sat": "def sat(n: int, year_len: int=92):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=92):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_93",
    "sat": "def sat(n: int, year_len: int=93):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=93):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_94",
    "sat": "def sat(n: int, year_len: int=94):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=94):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_95",
    "sat": "def sat(n: int, year_len: int=95):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=95):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_96",
    "sat": "def sat(n: int, year_len: int=96):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=96):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_97",
    "sat": "def sat(n: int, year_len: int=97):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=97):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_98",
    "sat": "def sat(n: int, year_len: int=98):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=98):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_99",
    "sat": "def sat(n: int, year_len: int=99):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=99):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_100",
    "sat": "def sat(n: int, year_len: int=100):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=100):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_101",
    "sat": "def sat(n: int, year_len: int=101):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=101):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_102",
    "sat": "def sat(n: int, year_len: int=102):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=102):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_103",
    "sat": "def sat(n: int, year_len: int=103):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=103):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_104",
    "sat": "def sat(n: int, year_len: int=104):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=104):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_105",
    "sat": "def sat(n: int, year_len: int=105):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=105):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_106",
    "sat": "def sat(n: int, year_len: int=106):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=106):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_107",
    "sat": "def sat(n: int, year_len: int=107):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=107):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_108",
    "sat": "def sat(n: int, year_len: int=108):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=108):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_109",
    "sat": "def sat(n: int, year_len: int=109):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=109):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_110",
    "sat": "def sat(n: int, year_len: int=110):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=110):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_111",
    "sat": "def sat(n: int, year_len: int=111):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=111):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_112",
    "sat": "def sat(n: int, year_len: int=112):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=112):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_113",
    "sat": "def sat(n: int, year_len: int=113):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=113):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_114",
    "sat": "def sat(n: int, year_len: int=114):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=114):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_115",
    "sat": "def sat(n: int, year_len: int=115):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=115):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_116",
    "sat": "def sat(n: int, year_len: int=116):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=116):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_117",
    "sat": "def sat(n: int, year_len: int=117):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=117):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_118",
    "sat": "def sat(n: int, year_len: int=118):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=118):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_119",
    "sat": "def sat(n: int, year_len: int=119):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=119):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_120",
    "sat": "def sat(n: int, year_len: int=120):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=120):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_121",
    "sat": "def sat(n: int, year_len: int=121):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=121):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_122",
    "sat": "def sat(n: int, year_len: int=122):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=122):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_123",
    "sat": "def sat(n: int, year_len: int=123):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=123):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_124",
    "sat": "def sat(n: int, year_len: int=124):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=124):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_125",
    "sat": "def sat(n: int, year_len: int=125):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=125):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_126",
    "sat": "def sat(n: int, year_len: int=126):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=126):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_127",
    "sat": "def sat(n: int, year_len: int=127):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=127):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_128",
    "sat": "def sat(n: int, year_len: int=128):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=128):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_129",
    "sat": "def sat(n: int, year_len: int=129):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=129):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_130",
    "sat": "def sat(n: int, year_len: int=130):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=130):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_131",
    "sat": "def sat(n: int, year_len: int=131):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=131):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_132",
    "sat": "def sat(n: int, year_len: int=132):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=132):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_133",
    "sat": "def sat(n: int, year_len: int=133):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=133):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_134",
    "sat": "def sat(n: int, year_len: int=134):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=134):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_135",
    "sat": "def sat(n: int, year_len: int=135):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=135):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_136",
    "sat": "def sat(n: int, year_len: int=136):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=136):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_137",
    "sat": "def sat(n: int, year_len: int=137):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=137):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_138",
    "sat": "def sat(n: int, year_len: int=138):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=138):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_139",
    "sat": "def sat(n: int, year_len: int=139):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=139):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_140",
    "sat": "def sat(n: int, year_len: int=140):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=140):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_141",
    "sat": "def sat(n: int, year_len: int=141):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=141):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_142",
    "sat": "def sat(n: int, year_len: int=142):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=142):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_143",
    "sat": "def sat(n: int, year_len: int=143):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=143):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_144",
    "sat": "def sat(n: int, year_len: int=144):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=144):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_145",
    "sat": "def sat(n: int, year_len: int=145):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=145):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_146",
    "sat": "def sat(n: int, year_len: int=146):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=146):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_147",
    "sat": "def sat(n: int, year_len: int=147):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=147):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_148",
    "sat": "def sat(n: int, year_len: int=148):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=148):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_149",
    "sat": "def sat(n: int, year_len: int=149):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=149):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_150",
    "sat": "def sat(n: int, year_len: int=150):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=150):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_151",
    "sat": "def sat(n: int, year_len: int=151):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=151):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_152",
    "sat": "def sat(n: int, year_len: int=152):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=152):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_153",
    "sat": "def sat(n: int, year_len: int=153):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=153):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_154",
    "sat": "def sat(n: int, year_len: int=154):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=154):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_155",
    "sat": "def sat(n: int, year_len: int=155):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=155):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_156",
    "sat": "def sat(n: int, year_len: int=156):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=156):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_157",
    "sat": "def sat(n: int, year_len: int=157):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=157):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_158",
    "sat": "def sat(n: int, year_len: int=158):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=158):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_159",
    "sat": "def sat(n: int, year_len: int=159):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=159):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_160",
    "sat": "def sat(n: int, year_len: int=160):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=160):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_161",
    "sat": "def sat(n: int, year_len: int=161):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=161):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_162",
    "sat": "def sat(n: int, year_len: int=162):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=162):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_163",
    "sat": "def sat(n: int, year_len: int=163):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=163):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_164",
    "sat": "def sat(n: int, year_len: int=164):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=164):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_165",
    "sat": "def sat(n: int, year_len: int=165):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=165):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_166",
    "sat": "def sat(n: int, year_len: int=166):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=166):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_167",
    "sat": "def sat(n: int, year_len: int=167):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=167):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_168",
    "sat": "def sat(n: int, year_len: int=168):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=168):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_169",
    "sat": "def sat(n: int, year_len: int=169):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=169):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_170",
    "sat": "def sat(n: int, year_len: int=170):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=170):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_171",
    "sat": "def sat(n: int, year_len: int=171):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=171):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_172",
    "sat": "def sat(n: int, year_len: int=172):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=172):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_173",
    "sat": "def sat(n: int, year_len: int=173):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=173):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_174",
    "sat": "def sat(n: int, year_len: int=174):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=174):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_175",
    "sat": "def sat(n: int, year_len: int=175):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=175):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_176",
    "sat": "def sat(n: int, year_len: int=176):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=176):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_177",
    "sat": "def sat(n: int, year_len: int=177):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=177):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_178",
    "sat": "def sat(n: int, year_len: int=178):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=178):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_179",
    "sat": "def sat(n: int, year_len: int=179):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=179):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_180",
    "sat": "def sat(n: int, year_len: int=180):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=180):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_181",
    "sat": "def sat(n: int, year_len: int=181):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=181):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_182",
    "sat": "def sat(n: int, year_len: int=182):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_183",
    "sat": "def sat(n: int, year_len: int=183):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=183):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_184",
    "sat": "def sat(n: int, year_len: int=184):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=184):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_185",
    "sat": "def sat(n: int, year_len: int=185):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=185):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_186",
    "sat": "def sat(n: int, year_len: int=186):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=186):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_187",
    "sat": "def sat(n: int, year_len: int=187):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=187):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_188",
    "sat": "def sat(n: int, year_len: int=188):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=188):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_189",
    "sat": "def sat(n: int, year_len: int=189):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=189):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_190",
    "sat": "def sat(n: int, year_len: int=190):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=190):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_191",
    "sat": "def sat(n: int, year_len: int=191):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=191):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_192",
    "sat": "def sat(n: int, year_len: int=192):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=192):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_193",
    "sat": "def sat(n: int, year_len: int=193):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=193):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_194",
    "sat": "def sat(n: int, year_len: int=194):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=194):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_195",
    "sat": "def sat(n: int, year_len: int=195):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=195):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_196",
    "sat": "def sat(n: int, year_len: int=196):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=196):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_197",
    "sat": "def sat(n: int, year_len: int=197):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=197):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_198",
    "sat": "def sat(n: int, year_len: int=198):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=198):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_199",
    "sat": "def sat(n: int, year_len: int=199):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=199):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_200",
    "sat": "def sat(n: int, year_len: int=200):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=200):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_201",
    "sat": "def sat(n: int, year_len: int=201):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=201):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_202",
    "sat": "def sat(n: int, year_len: int=202):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=202):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_203",
    "sat": "def sat(n: int, year_len: int=203):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=203):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_204",
    "sat": "def sat(n: int, year_len: int=204):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=204):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_205",
    "sat": "def sat(n: int, year_len: int=205):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=205):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_206",
    "sat": "def sat(n: int, year_len: int=206):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=206):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_207",
    "sat": "def sat(n: int, year_len: int=207):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=207):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_208",
    "sat": "def sat(n: int, year_len: int=208):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=208):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_209",
    "sat": "def sat(n: int, year_len: int=209):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=209):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_210",
    "sat": "def sat(n: int, year_len: int=210):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=210):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_211",
    "sat": "def sat(n: int, year_len: int=211):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=211):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_212",
    "sat": "def sat(n: int, year_len: int=212):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=212):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_213",
    "sat": "def sat(n: int, year_len: int=213):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=213):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_214",
    "sat": "def sat(n: int, year_len: int=214):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=214):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_215",
    "sat": "def sat(n: int, year_len: int=215):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=215):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_216",
    "sat": "def sat(n: int, year_len: int=216):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=216):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_217",
    "sat": "def sat(n: int, year_len: int=217):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=217):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_218",
    "sat": "def sat(n: int, year_len: int=218):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=218):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_219",
    "sat": "def sat(n: int, year_len: int=219):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=219):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_220",
    "sat": "def sat(n: int, year_len: int=220):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=220):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_221",
    "sat": "def sat(n: int, year_len: int=221):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=221):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_222",
    "sat": "def sat(n: int, year_len: int=222):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=222):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_223",
    "sat": "def sat(n: int, year_len: int=223):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=223):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_224",
    "sat": "def sat(n: int, year_len: int=224):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=224):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_225",
    "sat": "def sat(n: int, year_len: int=225):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=225):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_226",
    "sat": "def sat(n: int, year_len: int=226):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=226):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_227",
    "sat": "def sat(n: int, year_len: int=227):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=227):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_228",
    "sat": "def sat(n: int, year_len: int=228):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=228):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_229",
    "sat": "def sat(n: int, year_len: int=229):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=229):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_230",
    "sat": "def sat(n: int, year_len: int=230):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=230):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_231",
    "sat": "def sat(n: int, year_len: int=231):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=231):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_232",
    "sat": "def sat(n: int, year_len: int=232):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=232):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_233",
    "sat": "def sat(n: int, year_len: int=233):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=233):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_234",
    "sat": "def sat(n: int, year_len: int=234):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=234):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_235",
    "sat": "def sat(n: int, year_len: int=235):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=235):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_236",
    "sat": "def sat(n: int, year_len: int=236):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=236):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_237",
    "sat": "def sat(n: int, year_len: int=237):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=237):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_238",
    "sat": "def sat(n: int, year_len: int=238):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=238):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_239",
    "sat": "def sat(n: int, year_len: int=239):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=239):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_240",
    "sat": "def sat(n: int, year_len: int=240):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=240):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_241",
    "sat": "def sat(n: int, year_len: int=241):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=241):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_242",
    "sat": "def sat(n: int, year_len: int=242):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=242):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_243",
    "sat": "def sat(n: int, year_len: int=243):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=243):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_244",
    "sat": "def sat(n: int, year_len: int=244):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=244):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_245",
    "sat": "def sat(n: int, year_len: int=245):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=245):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_246",
    "sat": "def sat(n: int, year_len: int=246):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=246):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_247",
    "sat": "def sat(n: int, year_len: int=247):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=247):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_248",
    "sat": "def sat(n: int, year_len: int=248):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=248):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_249",
    "sat": "def sat(n: int, year_len: int=249):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=249):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_250",
    "sat": "def sat(n: int, year_len: int=250):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=250):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_251",
    "sat": "def sat(n: int, year_len: int=251):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=251):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_252",
    "sat": "def sat(n: int, year_len: int=252):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=252):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_253",
    "sat": "def sat(n: int, year_len: int=253):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=253):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_254",
    "sat": "def sat(n: int, year_len: int=254):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=254):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_255",
    "sat": "def sat(n: int, year_len: int=255):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=255):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_256",
    "sat": "def sat(n: int, year_len: int=256):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=256):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_257",
    "sat": "def sat(n: int, year_len: int=257):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=257):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_258",
    "sat": "def sat(n: int, year_len: int=258):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=258):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_259",
    "sat": "def sat(n: int, year_len: int=259):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=259):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_260",
    "sat": "def sat(n: int, year_len: int=260):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=260):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_261",
    "sat": "def sat(n: int, year_len: int=261):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=261):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_262",
    "sat": "def sat(n: int, year_len: int=262):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=262):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_263",
    "sat": "def sat(n: int, year_len: int=263):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=263):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_264",
    "sat": "def sat(n: int, year_len: int=264):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=264):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_265",
    "sat": "def sat(n: int, year_len: int=265):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=265):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_266",
    "sat": "def sat(n: int, year_len: int=266):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=266):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_267",
    "sat": "def sat(n: int, year_len: int=267):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=267):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_268",
    "sat": "def sat(n: int, year_len: int=268):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=268):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_269",
    "sat": "def sat(n: int, year_len: int=269):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=269):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_270",
    "sat": "def sat(n: int, year_len: int=270):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=270):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_271",
    "sat": "def sat(n: int, year_len: int=271):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=271):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_272",
    "sat": "def sat(n: int, year_len: int=272):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=272):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_273",
    "sat": "def sat(n: int, year_len: int=273):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=273):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_274",
    "sat": "def sat(n: int, year_len: int=274):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=274):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_275",
    "sat": "def sat(n: int, year_len: int=275):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=275):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_276",
    "sat": "def sat(n: int, year_len: int=276):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=276):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_277",
    "sat": "def sat(n: int, year_len: int=277):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=277):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_278",
    "sat": "def sat(n: int, year_len: int=278):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=278):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_279",
    "sat": "def sat(n: int, year_len: int=279):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=279):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_280",
    "sat": "def sat(n: int, year_len: int=280):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=280):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_281",
    "sat": "def sat(n: int, year_len: int=281):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=281):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_282",
    "sat": "def sat(n: int, year_len: int=282):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=282):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_283",
    "sat": "def sat(n: int, year_len: int=283):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=283):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_284",
    "sat": "def sat(n: int, year_len: int=284):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=284):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_285",
    "sat": "def sat(n: int, year_len: int=285):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=285):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_286",
    "sat": "def sat(n: int, year_len: int=286):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=286):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_287",
    "sat": "def sat(n: int, year_len: int=287):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=287):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_288",
    "sat": "def sat(n: int, year_len: int=288):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=288):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_289",
    "sat": "def sat(n: int, year_len: int=289):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=289):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_290",
    "sat": "def sat(n: int, year_len: int=290):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=290):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_291",
    "sat": "def sat(n: int, year_len: int=291):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=291):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_292",
    "sat": "def sat(n: int, year_len: int=292):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=292):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_293",
    "sat": "def sat(n: int, year_len: int=293):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=293):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_294",
    "sat": "def sat(n: int, year_len: int=294):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=294):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_295",
    "sat": "def sat(n: int, year_len: int=295):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=295):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_296",
    "sat": "def sat(n: int, year_len: int=296):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=296):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_297",
    "sat": "def sat(n: int, year_len: int=297):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=297):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_298",
    "sat": "def sat(n: int, year_len: int=298):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=298):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_299",
    "sat": "def sat(n: int, year_len: int=299):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=299):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_300",
    "sat": "def sat(n: int, year_len: int=300):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=300):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_301",
    "sat": "def sat(n: int, year_len: int=301):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=301):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_302",
    "sat": "def sat(n: int, year_len: int=302):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=302):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_303",
    "sat": "def sat(n: int, year_len: int=303):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=303):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_304",
    "sat": "def sat(n: int, year_len: int=304):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=304):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_305",
    "sat": "def sat(n: int, year_len: int=305):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=305):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_306",
    "sat": "def sat(n: int, year_len: int=306):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=306):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_307",
    "sat": "def sat(n: int, year_len: int=307):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=307):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_308",
    "sat": "def sat(n: int, year_len: int=308):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=308):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_309",
    "sat": "def sat(n: int, year_len: int=309):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=309):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_310",
    "sat": "def sat(n: int, year_len: int=310):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=310):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_311",
    "sat": "def sat(n: int, year_len: int=311):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=311):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_312",
    "sat": "def sat(n: int, year_len: int=312):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=312):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_313",
    "sat": "def sat(n: int, year_len: int=313):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=313):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_314",
    "sat": "def sat(n: int, year_len: int=314):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=314):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_315",
    "sat": "def sat(n: int, year_len: int=315):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=315):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_316",
    "sat": "def sat(n: int, year_len: int=316):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=316):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_317",
    "sat": "def sat(n: int, year_len: int=317):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=317):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_318",
    "sat": "def sat(n: int, year_len: int=318):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=318):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_319",
    "sat": "def sat(n: int, year_len: int=319):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=319):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_320",
    "sat": "def sat(n: int, year_len: int=320):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=320):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_321",
    "sat": "def sat(n: int, year_len: int=321):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=321):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_322",
    "sat": "def sat(n: int, year_len: int=322):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=322):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_323",
    "sat": "def sat(n: int, year_len: int=323):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=323):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_324",
    "sat": "def sat(n: int, year_len: int=324):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=324):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_325",
    "sat": "def sat(n: int, year_len: int=325):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=325):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_326",
    "sat": "def sat(n: int, year_len: int=326):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=326):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_327",
    "sat": "def sat(n: int, year_len: int=327):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=327):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_328",
    "sat": "def sat(n: int, year_len: int=328):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=328):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_329",
    "sat": "def sat(n: int, year_len: int=329):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=329):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_330",
    "sat": "def sat(n: int, year_len: int=330):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=330):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_331",
    "sat": "def sat(n: int, year_len: int=331):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=331):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_332",
    "sat": "def sat(n: int, year_len: int=332):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=332):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_333",
    "sat": "def sat(n: int, year_len: int=333):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=333):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_334",
    "sat": "def sat(n: int, year_len: int=334):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=334):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_335",
    "sat": "def sat(n: int, year_len: int=335):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=335):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_336",
    "sat": "def sat(n: int, year_len: int=336):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=336):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_337",
    "sat": "def sat(n: int, year_len: int=337):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=337):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_338",
    "sat": "def sat(n: int, year_len: int=338):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=338):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_339",
    "sat": "def sat(n: int, year_len: int=339):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=339):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_340",
    "sat": "def sat(n: int, year_len: int=340):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=340):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_341",
    "sat": "def sat(n: int, year_len: int=341):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=341):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_342",
    "sat": "def sat(n: int, year_len: int=342):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=342):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_343",
    "sat": "def sat(n: int, year_len: int=343):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=343):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_344",
    "sat": "def sat(n: int, year_len: int=344):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=344):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_345",
    "sat": "def sat(n: int, year_len: int=345):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=345):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_346",
    "sat": "def sat(n: int, year_len: int=346):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=346):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_347",
    "sat": "def sat(n: int, year_len: int=347):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=347):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_348",
    "sat": "def sat(n: int, year_len: int=348):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=348):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_349",
    "sat": "def sat(n: int, year_len: int=349):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=349):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_350",
    "sat": "def sat(n: int, year_len: int=350):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=350):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_351",
    "sat": "def sat(n: int, year_len: int=351):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=351):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_352",
    "sat": "def sat(n: int, year_len: int=352):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=352):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_353",
    "sat": "def sat(n: int, year_len: int=353):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=353):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_354",
    "sat": "def sat(n: int, year_len: int=354):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=354):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_355",
    "sat": "def sat(n: int, year_len: int=355):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=355):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_356",
    "sat": "def sat(n: int, year_len: int=356):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=356):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_357",
    "sat": "def sat(n: int, year_len: int=357):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=357):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_358",
    "sat": "def sat(n: int, year_len: int=358):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=358):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_359",
    "sat": "def sat(n: int, year_len: int=359):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=359):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_360",
    "sat": "def sat(n: int, year_len: int=360):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=360):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_361",
    "sat": "def sat(n: int, year_len: int=361):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=361):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_362",
    "sat": "def sat(n: int, year_len: int=362):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=362):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_363",
    "sat": "def sat(n: int, year_len: int=363):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=363):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_364",
    "sat": "def sat(n: int, year_len: int=364):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=364):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_365",
    "sat": "def sat(n: int, year_len: int=366):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=366):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_366",
    "sat": "def sat(n: int, year_len: int=367):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=367):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_367",
    "sat": "def sat(n: int, year_len: int=368):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=368):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_368",
    "sat": "def sat(n: int, year_len: int=369):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=369):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_369",
    "sat": "def sat(n: int, year_len: int=370):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=370):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_370",
    "sat": "def sat(n: int, year_len: int=371):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=371):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_371",
    "sat": "def sat(n: int, year_len: int=372):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=372):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_372",
    "sat": "def sat(n: int, year_len: int=373):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=373):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_373",
    "sat": "def sat(n: int, year_len: int=374):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=374):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_374",
    "sat": "def sat(n: int, year_len: int=375):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=375):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_375",
    "sat": "def sat(n: int, year_len: int=376):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=376):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_376",
    "sat": "def sat(n: int, year_len: int=377):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=377):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_377",
    "sat": "def sat(n: int, year_len: int=378):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=378):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_378",
    "sat": "def sat(n: int, year_len: int=379):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=379):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_379",
    "sat": "def sat(n: int, year_len: int=380):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=380):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_380",
    "sat": "def sat(n: int, year_len: int=381):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=381):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_381",
    "sat": "def sat(n: int, year_len: int=382):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=382):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_382",
    "sat": "def sat(n: int, year_len: int=383):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=383):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_383",
    "sat": "def sat(n: int, year_len: int=384):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=384):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_384",
    "sat": "def sat(n: int, year_len: int=385):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=385):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_385",
    "sat": "def sat(n: int, year_len: int=386):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=386):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_386",
    "sat": "def sat(n: int, year_len: int=387):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=387):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_387",
    "sat": "def sat(n: int, year_len: int=388):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=388):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_388",
    "sat": "def sat(n: int, year_len: int=389):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=389):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_389",
    "sat": "def sat(n: int, year_len: int=390):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=390):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_390",
    "sat": "def sat(n: int, year_len: int=391):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=391):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_391",
    "sat": "def sat(n: int, year_len: int=392):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=392):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_392",
    "sat": "def sat(n: int, year_len: int=393):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=393):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_393",
    "sat": "def sat(n: int, year_len: int=394):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=394):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_394",
    "sat": "def sat(n: int, year_len: int=395):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=395):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_395",
    "sat": "def sat(n: int, year_len: int=396):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=396):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_396",
    "sat": "def sat(n: int, year_len: int=397):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=397):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_397",
    "sat": "def sat(n: int, year_len: int=398):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=398):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_398",
    "sat": "def sat(n: int, year_len: int=399):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=399):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_399",
    "sat": "def sat(n: int, year_len: int=400):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=400):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_400",
    "sat": "def sat(n: int, year_len: int=401):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=401):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_401",
    "sat": "def sat(n: int, year_len: int=402):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=402):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_402",
    "sat": "def sat(n: int, year_len: int=403):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=403):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_403",
    "sat": "def sat(n: int, year_len: int=404):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=404):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_404",
    "sat": "def sat(n: int, year_len: int=405):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=405):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_405",
    "sat": "def sat(n: int, year_len: int=406):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=406):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_406",
    "sat": "def sat(n: int, year_len: int=407):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=407):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_407",
    "sat": "def sat(n: int, year_len: int=408):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=408):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_408",
    "sat": "def sat(n: int, year_len: int=409):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=409):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_409",
    "sat": "def sat(n: int, year_len: int=410):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=410):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_410",
    "sat": "def sat(n: int, year_len: int=411):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=411):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_411",
    "sat": "def sat(n: int, year_len: int=412):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=412):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_412",
    "sat": "def sat(n: int, year_len: int=413):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=413):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_413",
    "sat": "def sat(n: int, year_len: int=414):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=414):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_414",
    "sat": "def sat(n: int, year_len: int=415):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=415):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_415",
    "sat": "def sat(n: int, year_len: int=416):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=416):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_416",
    "sat": "def sat(n: int, year_len: int=417):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=417):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_417",
    "sat": "def sat(n: int, year_len: int=418):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=418):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_418",
    "sat": "def sat(n: int, year_len: int=419):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=419):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_419",
    "sat": "def sat(n: int, year_len: int=420):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=420):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_420",
    "sat": "def sat(n: int, year_len: int=421):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=421):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_421",
    "sat": "def sat(n: int, year_len: int=422):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=422):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_422",
    "sat": "def sat(n: int, year_len: int=423):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=423):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_423",
    "sat": "def sat(n: int, year_len: int=424):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=424):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_424",
    "sat": "def sat(n: int, year_len: int=425):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=425):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_425",
    "sat": "def sat(n: int, year_len: int=426):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=426):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_426",
    "sat": "def sat(n: int, year_len: int=427):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=427):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_427",
    "sat": "def sat(n: int, year_len: int=428):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=428):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_428",
    "sat": "def sat(n: int, year_len: int=429):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=429):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_429",
    "sat": "def sat(n: int, year_len: int=430):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=430):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_430",
    "sat": "def sat(n: int, year_len: int=431):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=431):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_431",
    "sat": "def sat(n: int, year_len: int=432):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=432):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_432",
    "sat": "def sat(n: int, year_len: int=433):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=433):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_433",
    "sat": "def sat(n: int, year_len: int=434):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=434):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_434",
    "sat": "def sat(n: int, year_len: int=435):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=435):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_435",
    "sat": "def sat(n: int, year_len: int=436):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=436):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_436",
    "sat": "def sat(n: int, year_len: int=437):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=437):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_437",
    "sat": "def sat(n: int, year_len: int=438):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=438):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_438",
    "sat": "def sat(n: int, year_len: int=439):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=439):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_439",
    "sat": "def sat(n: int, year_len: int=440):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=440):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_440",
    "sat": "def sat(n: int, year_len: int=441):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=441):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_441",
    "sat": "def sat(n: int, year_len: int=442):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=442):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_442",
    "sat": "def sat(n: int, year_len: int=443):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=443):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_443",
    "sat": "def sat(n: int, year_len: int=444):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=444):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_444",
    "sat": "def sat(n: int, year_len: int=445):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=445):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_445",
    "sat": "def sat(n: int, year_len: int=446):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=446):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_446",
    "sat": "def sat(n: int, year_len: int=447):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=447):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_447",
    "sat": "def sat(n: int, year_len: int=448):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=448):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_448",
    "sat": "def sat(n: int, year_len: int=449):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=449):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_449",
    "sat": "def sat(n: int, year_len: int=450):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=450):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_450",
    "sat": "def sat(n: int, year_len: int=451):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=451):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_451",
    "sat": "def sat(n: int, year_len: int=452):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=452):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_452",
    "sat": "def sat(n: int, year_len: int=453):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=453):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_453",
    "sat": "def sat(n: int, year_len: int=454):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=454):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_454",
    "sat": "def sat(n: int, year_len: int=455):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=455):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_455",
    "sat": "def sat(n: int, year_len: int=456):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=456):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_456",
    "sat": "def sat(n: int, year_len: int=457):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=457):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_457",
    "sat": "def sat(n: int, year_len: int=458):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=458):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_458",
    "sat": "def sat(n: int, year_len: int=459):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=459):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_459",
    "sat": "def sat(n: int, year_len: int=460):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=460):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_460",
    "sat": "def sat(n: int, year_len: int=461):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=461):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_461",
    "sat": "def sat(n: int, year_len: int=462):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=462):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_462",
    "sat": "def sat(n: int, year_len: int=463):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=463):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_463",
    "sat": "def sat(n: int, year_len: int=464):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=464):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_464",
    "sat": "def sat(n: int, year_len: int=465):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=465):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_465",
    "sat": "def sat(n: int, year_len: int=466):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=466):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_466",
    "sat": "def sat(n: int, year_len: int=467):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=467):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_467",
    "sat": "def sat(n: int, year_len: int=468):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=468):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_468",
    "sat": "def sat(n: int, year_len: int=469):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=469):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_469",
    "sat": "def sat(n: int, year_len: int=470):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=470):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_470",
    "sat": "def sat(n: int, year_len: int=471):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=471):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_471",
    "sat": "def sat(n: int, year_len: int=472):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=472):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_472",
    "sat": "def sat(n: int, year_len: int=473):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=473):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_473",
    "sat": "def sat(n: int, year_len: int=474):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=474):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_474",
    "sat": "def sat(n: int, year_len: int=475):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=475):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_475",
    "sat": "def sat(n: int, year_len: int=476):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=476):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_476",
    "sat": "def sat(n: int, year_len: int=477):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=477):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_477",
    "sat": "def sat(n: int, year_len: int=478):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=478):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_478",
    "sat": "def sat(n: int, year_len: int=479):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=479):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_479",
    "sat": "def sat(n: int, year_len: int=480):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=480):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_480",
    "sat": "def sat(n: int, year_len: int=481):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=481):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_481",
    "sat": "def sat(n: int, year_len: int=482):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=482):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_482",
    "sat": "def sat(n: int, year_len: int=483):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=483):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_483",
    "sat": "def sat(n: int, year_len: int=484):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=484):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_484",
    "sat": "def sat(n: int, year_len: int=485):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=485):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_485",
    "sat": "def sat(n: int, year_len: int=486):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=486):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_486",
    "sat": "def sat(n: int, year_len: int=487):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=487):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_487",
    "sat": "def sat(n: int, year_len: int=488):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=488):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_488",
    "sat": "def sat(n: int, year_len: int=489):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=489):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_489",
    "sat": "def sat(n: int, year_len: int=490):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=490):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_490",
    "sat": "def sat(n: int, year_len: int=491):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=491):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_491",
    "sat": "def sat(n: int, year_len: int=492):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=492):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_492",
    "sat": "def sat(n: int, year_len: int=493):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=493):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_493",
    "sat": "def sat(n: int, year_len: int=494):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=494):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_494",
    "sat": "def sat(n: int, year_len: int=495):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=495):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_495",
    "sat": "def sat(n: int, year_len: int=496):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=496):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_496",
    "sat": "def sat(n: int, year_len: int=497):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=497):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_497",
    "sat": "def sat(n: int, year_len: int=498):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=498):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_498",
    "sat": "def sat(n: int, year_len: int=499):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=499):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_499",
    "sat": "def sat(n: int, year_len: int=500):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=500):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_500",
    "sat": "def sat(n: int, year_len: int=501):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=501):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_501",
    "sat": "def sat(n: int, year_len: int=502):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=502):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_502",
    "sat": "def sat(n: int, year_len: int=503):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=503):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_503",
    "sat": "def sat(n: int, year_len: int=504):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=504):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_504",
    "sat": "def sat(n: int, year_len: int=505):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=505):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_505",
    "sat": "def sat(n: int, year_len: int=506):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=506):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_506",
    "sat": "def sat(n: int, year_len: int=507):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=507):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_507",
    "sat": "def sat(n: int, year_len: int=508):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=508):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_508",
    "sat": "def sat(n: int, year_len: int=509):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=509):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_509",
    "sat": "def sat(n: int, year_len: int=510):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=510):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_510",
    "sat": "def sat(n: int, year_len: int=511):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=511):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_511",
    "sat": "def sat(n: int, year_len: int=512):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=512):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_512",
    "sat": "def sat(n: int, year_len: int=513):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=513):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_513",
    "sat": "def sat(n: int, year_len: int=514):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=514):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_514",
    "sat": "def sat(n: int, year_len: int=515):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=515):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_515",
    "sat": "def sat(n: int, year_len: int=516):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=516):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_516",
    "sat": "def sat(n: int, year_len: int=517):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=517):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_517",
    "sat": "def sat(n: int, year_len: int=518):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=518):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_518",
    "sat": "def sat(n: int, year_len: int=519):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=519):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_519",
    "sat": "def sat(n: int, year_len: int=520):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=520):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_520",
    "sat": "def sat(n: int, year_len: int=521):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=521):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_521",
    "sat": "def sat(n: int, year_len: int=522):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=522):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_522",
    "sat": "def sat(n: int, year_len: int=523):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=523):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_523",
    "sat": "def sat(n: int, year_len: int=524):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=524):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_524",
    "sat": "def sat(n: int, year_len: int=525):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=525):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_525",
    "sat": "def sat(n: int, year_len: int=526):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=526):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_526",
    "sat": "def sat(n: int, year_len: int=527):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=527):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_527",
    "sat": "def sat(n: int, year_len: int=528):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=528):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_528",
    "sat": "def sat(n: int, year_len: int=529):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=529):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_529",
    "sat": "def sat(n: int, year_len: int=530):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=530):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_530",
    "sat": "def sat(n: int, year_len: int=531):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=531):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_531",
    "sat": "def sat(n: int, year_len: int=532):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=532):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_532",
    "sat": "def sat(n: int, year_len: int=533):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=533):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_533",
    "sat": "def sat(n: int, year_len: int=534):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=534):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_534",
    "sat": "def sat(n: int, year_len: int=535):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=535):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_535",
    "sat": "def sat(n: int, year_len: int=536):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=536):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_536",
    "sat": "def sat(n: int, year_len: int=537):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=537):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_537",
    "sat": "def sat(n: int, year_len: int=538):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=538):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_538",
    "sat": "def sat(n: int, year_len: int=539):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=539):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_539",
    "sat": "def sat(n: int, year_len: int=540):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=540):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_540",
    "sat": "def sat(n: int, year_len: int=541):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=541):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_541",
    "sat": "def sat(n: int, year_len: int=542):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=542):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_542",
    "sat": "def sat(n: int, year_len: int=543):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=543):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_543",
    "sat": "def sat(n: int, year_len: int=544):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=544):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_544",
    "sat": "def sat(n: int, year_len: int=545):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=545):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_545",
    "sat": "def sat(n: int, year_len: int=546):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=546):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_546",
    "sat": "def sat(n: int, year_len: int=547):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=547):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_547",
    "sat": "def sat(n: int, year_len: int=548):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=548):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_548",
    "sat": "def sat(n: int, year_len: int=549):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=549):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_549",
    "sat": "def sat(n: int, year_len: int=550):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=550):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_550",
    "sat": "def sat(n: int, year_len: int=551):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=551):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_551",
    "sat": "def sat(n: int, year_len: int=552):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=552):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_552",
    "sat": "def sat(n: int, year_len: int=553):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=553):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_553",
    "sat": "def sat(n: int, year_len: int=554):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=554):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_554",
    "sat": "def sat(n: int, year_len: int=555):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=555):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_555",
    "sat": "def sat(n: int, year_len: int=556):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=556):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_556",
    "sat": "def sat(n: int, year_len: int=557):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=557):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_557",
    "sat": "def sat(n: int, year_len: int=558):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=558):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_558",
    "sat": "def sat(n: int, year_len: int=559):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=559):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_559",
    "sat": "def sat(n: int, year_len: int=560):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=560):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_560",
    "sat": "def sat(n: int, year_len: int=561):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=561):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_561",
    "sat": "def sat(n: int, year_len: int=562):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=562):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_562",
    "sat": "def sat(n: int, year_len: int=563):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=563):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_563",
    "sat": "def sat(n: int, year_len: int=564):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=564):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_564",
    "sat": "def sat(n: int, year_len: int=565):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=565):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_565",
    "sat": "def sat(n: int, year_len: int=566):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=566):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_566",
    "sat": "def sat(n: int, year_len: int=567):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=567):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_567",
    "sat": "def sat(n: int, year_len: int=568):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=568):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_568",
    "sat": "def sat(n: int, year_len: int=569):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=569):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_569",
    "sat": "def sat(n: int, year_len: int=570):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=570):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_570",
    "sat": "def sat(n: int, year_len: int=571):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=571):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_571",
    "sat": "def sat(n: int, year_len: int=572):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=572):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_572",
    "sat": "def sat(n: int, year_len: int=573):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=573):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_573",
    "sat": "def sat(n: int, year_len: int=574):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=574):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_574",
    "sat": "def sat(n: int, year_len: int=575):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=575):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_575",
    "sat": "def sat(n: int, year_len: int=576):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=576):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_576",
    "sat": "def sat(n: int, year_len: int=577):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=577):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_577",
    "sat": "def sat(n: int, year_len: int=578):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=578):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_578",
    "sat": "def sat(n: int, year_len: int=579):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=579):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_579",
    "sat": "def sat(n: int, year_len: int=580):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=580):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_580",
    "sat": "def sat(n: int, year_len: int=581):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=581):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_581",
    "sat": "def sat(n: int, year_len: int=582):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=582):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_582",
    "sat": "def sat(n: int, year_len: int=583):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=583):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_583",
    "sat": "def sat(n: int, year_len: int=584):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=584):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_584",
    "sat": "def sat(n: int, year_len: int=585):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=585):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_585",
    "sat": "def sat(n: int, year_len: int=586):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=586):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_586",
    "sat": "def sat(n: int, year_len: int=587):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=587):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_587",
    "sat": "def sat(n: int, year_len: int=588):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=588):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_588",
    "sat": "def sat(n: int, year_len: int=589):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=589):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_589",
    "sat": "def sat(n: int, year_len: int=590):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=590):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_590",
    "sat": "def sat(n: int, year_len: int=591):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=591):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_591",
    "sat": "def sat(n: int, year_len: int=592):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=592):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_592",
    "sat": "def sat(n: int, year_len: int=593):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=593):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_593",
    "sat": "def sat(n: int, year_len: int=594):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=594):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_594",
    "sat": "def sat(n: int, year_len: int=595):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=595):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_595",
    "sat": "def sat(n: int, year_len: int=596):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=596):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_596",
    "sat": "def sat(n: int, year_len: int=597):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=597):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_597",
    "sat": "def sat(n: int, year_len: int=598):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=598):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_598",
    "sat": "def sat(n: int, year_len: int=599):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=599):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_599",
    "sat": "def sat(n: int, year_len: int=600):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=600):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_600",
    "sat": "def sat(n: int, year_len: int=601):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=601):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_601",
    "sat": "def sat(n: int, year_len: int=602):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=602):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_602",
    "sat": "def sat(n: int, year_len: int=603):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=603):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_603",
    "sat": "def sat(n: int, year_len: int=604):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=604):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_604",
    "sat": "def sat(n: int, year_len: int=605):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=605):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_605",
    "sat": "def sat(n: int, year_len: int=606):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=606):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_606",
    "sat": "def sat(n: int, year_len: int=607):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=607):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_607",
    "sat": "def sat(n: int, year_len: int=608):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=608):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_608",
    "sat": "def sat(n: int, year_len: int=609):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=609):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_609",
    "sat": "def sat(n: int, year_len: int=610):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=610):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_610",
    "sat": "def sat(n: int, year_len: int=611):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=611):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_611",
    "sat": "def sat(n: int, year_len: int=612):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=612):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_612",
    "sat": "def sat(n: int, year_len: int=613):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=613):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_613",
    "sat": "def sat(n: int, year_len: int=614):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=614):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_614",
    "sat": "def sat(n: int, year_len: int=615):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=615):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_615",
    "sat": "def sat(n: int, year_len: int=616):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=616):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_616",
    "sat": "def sat(n: int, year_len: int=617):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=617):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_617",
    "sat": "def sat(n: int, year_len: int=618):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=618):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_618",
    "sat": "def sat(n: int, year_len: int=619):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=619):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_619",
    "sat": "def sat(n: int, year_len: int=620):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=620):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_620",
    "sat": "def sat(n: int, year_len: int=621):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=621):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_621",
    "sat": "def sat(n: int, year_len: int=622):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=622):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_622",
    "sat": "def sat(n: int, year_len: int=623):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=623):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_623",
    "sat": "def sat(n: int, year_len: int=624):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=624):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_624",
    "sat": "def sat(n: int, year_len: int=625):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=625):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_625",
    "sat": "def sat(n: int, year_len: int=626):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=626):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_626",
    "sat": "def sat(n: int, year_len: int=627):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=627):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_627",
    "sat": "def sat(n: int, year_len: int=628):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=628):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_628",
    "sat": "def sat(n: int, year_len: int=629):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=629):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_629",
    "sat": "def sat(n: int, year_len: int=630):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=630):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_630",
    "sat": "def sat(n: int, year_len: int=631):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=631):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_631",
    "sat": "def sat(n: int, year_len: int=632):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=632):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_632",
    "sat": "def sat(n: int, year_len: int=633):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=633):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_633",
    "sat": "def sat(n: int, year_len: int=634):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=634):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_634",
    "sat": "def sat(n: int, year_len: int=635):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=635):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_635",
    "sat": "def sat(n: int, year_len: int=636):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=636):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_636",
    "sat": "def sat(n: int, year_len: int=637):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=637):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_637",
    "sat": "def sat(n: int, year_len: int=638):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=638):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_638",
    "sat": "def sat(n: int, year_len: int=639):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=639):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_639",
    "sat": "def sat(n: int, year_len: int=640):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=640):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_640",
    "sat": "def sat(n: int, year_len: int=641):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=641):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_641",
    "sat": "def sat(n: int, year_len: int=642):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=642):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_642",
    "sat": "def sat(n: int, year_len: int=643):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=643):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_643",
    "sat": "def sat(n: int, year_len: int=644):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=644):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_644",
    "sat": "def sat(n: int, year_len: int=645):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=645):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_645",
    "sat": "def sat(n: int, year_len: int=646):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=646):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_646",
    "sat": "def sat(n: int, year_len: int=647):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=647):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_647",
    "sat": "def sat(n: int, year_len: int=648):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=648):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_648",
    "sat": "def sat(n: int, year_len: int=649):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=649):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_649",
    "sat": "def sat(n: int, year_len: int=650):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=650):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_650",
    "sat": "def sat(n: int, year_len: int=651):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=651):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_651",
    "sat": "def sat(n: int, year_len: int=652):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=652):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_652",
    "sat": "def sat(n: int, year_len: int=653):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=653):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_653",
    "sat": "def sat(n: int, year_len: int=654):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=654):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_654",
    "sat": "def sat(n: int, year_len: int=655):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=655):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_655",
    "sat": "def sat(n: int, year_len: int=656):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=656):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_656",
    "sat": "def sat(n: int, year_len: int=657):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=657):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_657",
    "sat": "def sat(n: int, year_len: int=658):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=658):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_658",
    "sat": "def sat(n: int, year_len: int=659):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=659):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_659",
    "sat": "def sat(n: int, year_len: int=660):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=660):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_660",
    "sat": "def sat(n: int, year_len: int=661):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=661):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_661",
    "sat": "def sat(n: int, year_len: int=662):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=662):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_662",
    "sat": "def sat(n: int, year_len: int=663):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=663):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_663",
    "sat": "def sat(n: int, year_len: int=664):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=664):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_664",
    "sat": "def sat(n: int, year_len: int=665):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=665):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_665",
    "sat": "def sat(n: int, year_len: int=666):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=666):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_666",
    "sat": "def sat(n: int, year_len: int=667):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=667):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_667",
    "sat": "def sat(n: int, year_len: int=668):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=668):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_668",
    "sat": "def sat(n: int, year_len: int=669):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=669):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_669",
    "sat": "def sat(n: int, year_len: int=670):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=670):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_670",
    "sat": "def sat(n: int, year_len: int=671):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=671):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_671",
    "sat": "def sat(n: int, year_len: int=672):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=672):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_672",
    "sat": "def sat(n: int, year_len: int=673):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=673):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_673",
    "sat": "def sat(n: int, year_len: int=674):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=674):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_674",
    "sat": "def sat(n: int, year_len: int=675):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=675):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_675",
    "sat": "def sat(n: int, year_len: int=676):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=676):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_676",
    "sat": "def sat(n: int, year_len: int=677):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=677):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_677",
    "sat": "def sat(n: int, year_len: int=678):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=678):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_678",
    "sat": "def sat(n: int, year_len: int=679):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=679):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_679",
    "sat": "def sat(n: int, year_len: int=680):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=680):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_680",
    "sat": "def sat(n: int, year_len: int=681):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=681):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_681",
    "sat": "def sat(n: int, year_len: int=682):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=682):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_682",
    "sat": "def sat(n: int, year_len: int=683):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=683):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_683",
    "sat": "def sat(n: int, year_len: int=684):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=684):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_684",
    "sat": "def sat(n: int, year_len: int=685):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=685):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_685",
    "sat": "def sat(n: int, year_len: int=686):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=686):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_686",
    "sat": "def sat(n: int, year_len: int=687):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=687):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_687",
    "sat": "def sat(n: int, year_len: int=688):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=688):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_688",
    "sat": "def sat(n: int, year_len: int=689):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=689):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_689",
    "sat": "def sat(n: int, year_len: int=690):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=690):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_690",
    "sat": "def sat(n: int, year_len: int=691):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=691):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_691",
    "sat": "def sat(n: int, year_len: int=692):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=692):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_692",
    "sat": "def sat(n: int, year_len: int=693):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=693):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_693",
    "sat": "def sat(n: int, year_len: int=694):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=694):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_694",
    "sat": "def sat(n: int, year_len: int=695):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=695):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_695",
    "sat": "def sat(n: int, year_len: int=696):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=696):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_696",
    "sat": "def sat(n: int, year_len: int=697):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=697):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_697",
    "sat": "def sat(n: int, year_len: int=698):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=698):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_698",
    "sat": "def sat(n: int, year_len: int=699):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=699):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_699",
    "sat": "def sat(n: int, year_len: int=700):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=700):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_700",
    "sat": "def sat(n: int, year_len: int=701):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=701):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_701",
    "sat": "def sat(n: int, year_len: int=702):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=702):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_702",
    "sat": "def sat(n: int, year_len: int=703):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=703):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_703",
    "sat": "def sat(n: int, year_len: int=704):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=704):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_704",
    "sat": "def sat(n: int, year_len: int=705):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=705):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_705",
    "sat": "def sat(n: int, year_len: int=706):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=706):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_706",
    "sat": "def sat(n: int, year_len: int=707):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=707):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_707",
    "sat": "def sat(n: int, year_len: int=708):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=708):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_708",
    "sat": "def sat(n: int, year_len: int=709):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=709):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_709",
    "sat": "def sat(n: int, year_len: int=710):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=710):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_710",
    "sat": "def sat(n: int, year_len: int=711):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=711):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_711",
    "sat": "def sat(n: int, year_len: int=712):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=712):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_712",
    "sat": "def sat(n: int, year_len: int=713):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=713):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_713",
    "sat": "def sat(n: int, year_len: int=714):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=714):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_714",
    "sat": "def sat(n: int, year_len: int=715):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=715):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_715",
    "sat": "def sat(n: int, year_len: int=716):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=716):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_716",
    "sat": "def sat(n: int, year_len: int=717):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=717):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_717",
    "sat": "def sat(n: int, year_len: int=718):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=718):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_718",
    "sat": "def sat(n: int, year_len: int=719):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=719):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_719",
    "sat": "def sat(n: int, year_len: int=720):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=720):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_720",
    "sat": "def sat(n: int, year_len: int=721):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=721):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_721",
    "sat": "def sat(n: int, year_len: int=722):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=722):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_722",
    "sat": "def sat(n: int, year_len: int=723):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=723):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_723",
    "sat": "def sat(n: int, year_len: int=724):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=724):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_724",
    "sat": "def sat(n: int, year_len: int=725):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=725):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_725",
    "sat": "def sat(n: int, year_len: int=726):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=726):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_726",
    "sat": "def sat(n: int, year_len: int=727):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=727):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_727",
    "sat": "def sat(n: int, year_len: int=728):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=728):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_728",
    "sat": "def sat(n: int, year_len: int=729):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=729):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_729",
    "sat": "def sat(n: int, year_len: int=730):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=730):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_730",
    "sat": "def sat(n: int, year_len: int=731):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=731):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_731",
    "sat": "def sat(n: int, year_len: int=732):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=732):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_732",
    "sat": "def sat(n: int, year_len: int=733):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=733):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_733",
    "sat": "def sat(n: int, year_len: int=734):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=734):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_734",
    "sat": "def sat(n: int, year_len: int=735):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=735):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_735",
    "sat": "def sat(n: int, year_len: int=736):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=736):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_736",
    "sat": "def sat(n: int, year_len: int=737):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=737):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_737",
    "sat": "def sat(n: int, year_len: int=738):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=738):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_738",
    "sat": "def sat(n: int, year_len: int=739):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=739):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_739",
    "sat": "def sat(n: int, year_len: int=740):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=740):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_740",
    "sat": "def sat(n: int, year_len: int=741):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=741):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_741",
    "sat": "def sat(n: int, year_len: int=742):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=742):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_742",
    "sat": "def sat(n: int, year_len: int=743):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=743):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_743",
    "sat": "def sat(n: int, year_len: int=744):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=744):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_744",
    "sat": "def sat(n: int, year_len: int=745):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=745):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_745",
    "sat": "def sat(n: int, year_len: int=746):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=746):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_746",
    "sat": "def sat(n: int, year_len: int=747):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=747):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_747",
    "sat": "def sat(n: int, year_len: int=748):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=748):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_748",
    "sat": "def sat(n: int, year_len: int=749):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=749):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_749",
    "sat": "def sat(n: int, year_len: int=750):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=750):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_750",
    "sat": "def sat(n: int, year_len: int=751):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=751):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_751",
    "sat": "def sat(n: int, year_len: int=752):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=752):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_752",
    "sat": "def sat(n: int, year_len: int=753):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=753):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_753",
    "sat": "def sat(n: int, year_len: int=754):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=754):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_754",
    "sat": "def sat(n: int, year_len: int=755):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=755):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_755",
    "sat": "def sat(n: int, year_len: int=756):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=756):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_756",
    "sat": "def sat(n: int, year_len: int=757):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=757):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_757",
    "sat": "def sat(n: int, year_len: int=758):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=758):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_758",
    "sat": "def sat(n: int, year_len: int=759):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=759):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_759",
    "sat": "def sat(n: int, year_len: int=760):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=760):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_760",
    "sat": "def sat(n: int, year_len: int=761):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=761):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_761",
    "sat": "def sat(n: int, year_len: int=762):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=762):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_762",
    "sat": "def sat(n: int, year_len: int=763):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=763):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_763",
    "sat": "def sat(n: int, year_len: int=764):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=764):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_764",
    "sat": "def sat(n: int, year_len: int=765):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=765):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_765",
    "sat": "def sat(n: int, year_len: int=766):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=766):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_766",
    "sat": "def sat(n: int, year_len: int=767):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=767):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_767",
    "sat": "def sat(n: int, year_len: int=768):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=768):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_768",
    "sat": "def sat(n: int, year_len: int=769):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=769):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_769",
    "sat": "def sat(n: int, year_len: int=770):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=770):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_770",
    "sat": "def sat(n: int, year_len: int=771):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=771):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_771",
    "sat": "def sat(n: int, year_len: int=772):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=772):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_772",
    "sat": "def sat(n: int, year_len: int=773):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=773):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_773",
    "sat": "def sat(n: int, year_len: int=774):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=774):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_774",
    "sat": "def sat(n: int, year_len: int=775):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=775):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_775",
    "sat": "def sat(n: int, year_len: int=776):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=776):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_776",
    "sat": "def sat(n: int, year_len: int=777):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=777):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_777",
    "sat": "def sat(n: int, year_len: int=778):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=778):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_778",
    "sat": "def sat(n: int, year_len: int=779):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=779):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_779",
    "sat": "def sat(n: int, year_len: int=780):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=780):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_780",
    "sat": "def sat(n: int, year_len: int=781):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=781):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_781",
    "sat": "def sat(n: int, year_len: int=782):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=782):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_782",
    "sat": "def sat(n: int, year_len: int=783):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=783):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_783",
    "sat": "def sat(n: int, year_len: int=784):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=784):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_784",
    "sat": "def sat(n: int, year_len: int=785):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=785):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_785",
    "sat": "def sat(n: int, year_len: int=786):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=786):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_786",
    "sat": "def sat(n: int, year_len: int=787):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=787):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_787",
    "sat": "def sat(n: int, year_len: int=788):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=788):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_788",
    "sat": "def sat(n: int, year_len: int=789):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=789):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_789",
    "sat": "def sat(n: int, year_len: int=790):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=790):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_790",
    "sat": "def sat(n: int, year_len: int=791):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=791):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_791",
    "sat": "def sat(n: int, year_len: int=792):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=792):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_792",
    "sat": "def sat(n: int, year_len: int=793):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=793):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_793",
    "sat": "def sat(n: int, year_len: int=794):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=794):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_794",
    "sat": "def sat(n: int, year_len: int=795):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=795):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_795",
    "sat": "def sat(n: int, year_len: int=796):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=796):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_796",
    "sat": "def sat(n: int, year_len: int=797):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=797):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_797",
    "sat": "def sat(n: int, year_len: int=798):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=798):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_798",
    "sat": "def sat(n: int, year_len: int=799):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=799):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_799",
    "sat": "def sat(n: int, year_len: int=800):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=800):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_800",
    "sat": "def sat(n: int, year_len: int=801):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=801):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_801",
    "sat": "def sat(n: int, year_len: int=802):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=802):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_802",
    "sat": "def sat(n: int, year_len: int=803):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=803):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_803",
    "sat": "def sat(n: int, year_len: int=804):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=804):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_804",
    "sat": "def sat(n: int, year_len: int=805):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=805):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_805",
    "sat": "def sat(n: int, year_len: int=806):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=806):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_806",
    "sat": "def sat(n: int, year_len: int=807):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=807):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_807",
    "sat": "def sat(n: int, year_len: int=808):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=808):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_808",
    "sat": "def sat(n: int, year_len: int=809):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=809):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_809",
    "sat": "def sat(n: int, year_len: int=810):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=810):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_810",
    "sat": "def sat(n: int, year_len: int=811):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=811):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_811",
    "sat": "def sat(n: int, year_len: int=812):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=812):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_812",
    "sat": "def sat(n: int, year_len: int=813):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=813):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_813",
    "sat": "def sat(n: int, year_len: int=814):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=814):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_814",
    "sat": "def sat(n: int, year_len: int=815):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=815):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_815",
    "sat": "def sat(n: int, year_len: int=816):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=816):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_816",
    "sat": "def sat(n: int, year_len: int=817):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=817):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_817",
    "sat": "def sat(n: int, year_len: int=818):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=818):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_818",
    "sat": "def sat(n: int, year_len: int=819):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=819):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_819",
    "sat": "def sat(n: int, year_len: int=820):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=820):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_820",
    "sat": "def sat(n: int, year_len: int=821):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=821):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_821",
    "sat": "def sat(n: int, year_len: int=822):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=822):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_822",
    "sat": "def sat(n: int, year_len: int=823):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=823):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_823",
    "sat": "def sat(n: int, year_len: int=824):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=824):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_824",
    "sat": "def sat(n: int, year_len: int=825):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=825):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_825",
    "sat": "def sat(n: int, year_len: int=826):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=826):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_826",
    "sat": "def sat(n: int, year_len: int=827):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=827):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_827",
    "sat": "def sat(n: int, year_len: int=828):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=828):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_828",
    "sat": "def sat(n: int, year_len: int=829):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=829):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_829",
    "sat": "def sat(n: int, year_len: int=830):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=830):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_830",
    "sat": "def sat(n: int, year_len: int=831):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=831):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_831",
    "sat": "def sat(n: int, year_len: int=832):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=832):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_832",
    "sat": "def sat(n: int, year_len: int=833):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=833):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_833",
    "sat": "def sat(n: int, year_len: int=834):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=834):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_834",
    "sat": "def sat(n: int, year_len: int=835):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=835):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_835",
    "sat": "def sat(n: int, year_len: int=836):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=836):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_836",
    "sat": "def sat(n: int, year_len: int=837):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=837):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_837",
    "sat": "def sat(n: int, year_len: int=838):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=838):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_838",
    "sat": "def sat(n: int, year_len: int=839):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=839):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_839",
    "sat": "def sat(n: int, year_len: int=840):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=840):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_840",
    "sat": "def sat(n: int, year_len: int=841):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=841):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_841",
    "sat": "def sat(n: int, year_len: int=842):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=842):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_842",
    "sat": "def sat(n: int, year_len: int=843):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=843):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_843",
    "sat": "def sat(n: int, year_len: int=844):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=844):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_844",
    "sat": "def sat(n: int, year_len: int=845):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=845):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_845",
    "sat": "def sat(n: int, year_len: int=846):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=846):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_846",
    "sat": "def sat(n: int, year_len: int=847):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=847):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_847",
    "sat": "def sat(n: int, year_len: int=848):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=848):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_848",
    "sat": "def sat(n: int, year_len: int=849):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=849):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_849",
    "sat": "def sat(n: int, year_len: int=850):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=850):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_850",
    "sat": "def sat(n: int, year_len: int=851):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=851):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_851",
    "sat": "def sat(n: int, year_len: int=852):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=852):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_852",
    "sat": "def sat(n: int, year_len: int=853):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=853):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_853",
    "sat": "def sat(n: int, year_len: int=854):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=854):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_854",
    "sat": "def sat(n: int, year_len: int=855):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=855):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_855",
    "sat": "def sat(n: int, year_len: int=856):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=856):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_856",
    "sat": "def sat(n: int, year_len: int=857):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=857):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_857",
    "sat": "def sat(n: int, year_len: int=858):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=858):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_858",
    "sat": "def sat(n: int, year_len: int=859):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=859):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_859",
    "sat": "def sat(n: int, year_len: int=860):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=860):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_860",
    "sat": "def sat(n: int, year_len: int=861):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=861):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_861",
    "sat": "def sat(n: int, year_len: int=862):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=862):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_862",
    "sat": "def sat(n: int, year_len: int=863):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=863):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_863",
    "sat": "def sat(n: int, year_len: int=864):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=864):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_864",
    "sat": "def sat(n: int, year_len: int=865):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=865):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_865",
    "sat": "def sat(n: int, year_len: int=866):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=866):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_866",
    "sat": "def sat(n: int, year_len: int=867):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=867):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_867",
    "sat": "def sat(n: int, year_len: int=868):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=868):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_868",
    "sat": "def sat(n: int, year_len: int=869):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=869):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_869",
    "sat": "def sat(n: int, year_len: int=870):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=870):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_870",
    "sat": "def sat(n: int, year_len: int=871):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=871):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_871",
    "sat": "def sat(n: int, year_len: int=872):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=872):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_872",
    "sat": "def sat(n: int, year_len: int=873):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=873):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_873",
    "sat": "def sat(n: int, year_len: int=874):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=874):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_874",
    "sat": "def sat(n: int, year_len: int=875):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=875):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_875",
    "sat": "def sat(n: int, year_len: int=876):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=876):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_876",
    "sat": "def sat(n: int, year_len: int=877):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=877):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_877",
    "sat": "def sat(n: int, year_len: int=878):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=878):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_878",
    "sat": "def sat(n: int, year_len: int=879):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=879):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_879",
    "sat": "def sat(n: int, year_len: int=880):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=880):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_880",
    "sat": "def sat(n: int, year_len: int=881):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=881):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_881",
    "sat": "def sat(n: int, year_len: int=882):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=882):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_882",
    "sat": "def sat(n: int, year_len: int=883):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=883):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_883",
    "sat": "def sat(n: int, year_len: int=884):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=884):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_884",
    "sat": "def sat(n: int, year_len: int=885):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=885):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_885",
    "sat": "def sat(n: int, year_len: int=886):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=886):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_886",
    "sat": "def sat(n: int, year_len: int=887):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=887):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_887",
    "sat": "def sat(n: int, year_len: int=888):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=888):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_888",
    "sat": "def sat(n: int, year_len: int=889):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=889):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_889",
    "sat": "def sat(n: int, year_len: int=890):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=890):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_890",
    "sat": "def sat(n: int, year_len: int=891):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=891):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_891",
    "sat": "def sat(n: int, year_len: int=892):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=892):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_892",
    "sat": "def sat(n: int, year_len: int=893):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=893):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_893",
    "sat": "def sat(n: int, year_len: int=894):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=894):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_894",
    "sat": "def sat(n: int, year_len: int=895):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=895):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_895",
    "sat": "def sat(n: int, year_len: int=896):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=896):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_896",
    "sat": "def sat(n: int, year_len: int=897):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=897):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_897",
    "sat": "def sat(n: int, year_len: int=898):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=898):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_898",
    "sat": "def sat(n: int, year_len: int=899):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=899):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_899",
    "sat": "def sat(n: int, year_len: int=900):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=900):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_900",
    "sat": "def sat(n: int, year_len: int=901):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=901):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_901",
    "sat": "def sat(n: int, year_len: int=902):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=902):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_902",
    "sat": "def sat(n: int, year_len: int=903):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=903):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_903",
    "sat": "def sat(n: int, year_len: int=904):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=904):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_904",
    "sat": "def sat(n: int, year_len: int=905):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=905):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_905",
    "sat": "def sat(n: int, year_len: int=906):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=906):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_906",
    "sat": "def sat(n: int, year_len: int=907):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=907):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_907",
    "sat": "def sat(n: int, year_len: int=908):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=908):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_908",
    "sat": "def sat(n: int, year_len: int=909):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=909):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_909",
    "sat": "def sat(n: int, year_len: int=910):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=910):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_910",
    "sat": "def sat(n: int, year_len: int=911):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=911):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_911",
    "sat": "def sat(n: int, year_len: int=912):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=912):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_912",
    "sat": "def sat(n: int, year_len: int=913):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=913):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_913",
    "sat": "def sat(n: int, year_len: int=914):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=914):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_914",
    "sat": "def sat(n: int, year_len: int=915):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=915):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_915",
    "sat": "def sat(n: int, year_len: int=916):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=916):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_916",
    "sat": "def sat(n: int, year_len: int=917):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=917):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_917",
    "sat": "def sat(n: int, year_len: int=918):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=918):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_918",
    "sat": "def sat(n: int, year_len: int=919):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=919):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_919",
    "sat": "def sat(n: int, year_len: int=920):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=920):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_920",
    "sat": "def sat(n: int, year_len: int=921):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=921):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_921",
    "sat": "def sat(n: int, year_len: int=922):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=922):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_922",
    "sat": "def sat(n: int, year_len: int=923):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=923):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_923",
    "sat": "def sat(n: int, year_len: int=924):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=924):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_924",
    "sat": "def sat(n: int, year_len: int=925):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=925):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_925",
    "sat": "def sat(n: int, year_len: int=926):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=926):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_926",
    "sat": "def sat(n: int, year_len: int=927):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=927):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_927",
    "sat": "def sat(n: int, year_len: int=928):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=928):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_928",
    "sat": "def sat(n: int, year_len: int=929):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=929):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_929",
    "sat": "def sat(n: int, year_len: int=930):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=930):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_930",
    "sat": "def sat(n: int, year_len: int=931):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=931):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_931",
    "sat": "def sat(n: int, year_len: int=932):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=932):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_932",
    "sat": "def sat(n: int, year_len: int=933):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=933):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_933",
    "sat": "def sat(n: int, year_len: int=934):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=934):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_934",
    "sat": "def sat(n: int, year_len: int=935):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=935):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_935",
    "sat": "def sat(n: int, year_len: int=936):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=936):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_936",
    "sat": "def sat(n: int, year_len: int=937):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=937):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_937",
    "sat": "def sat(n: int, year_len: int=938):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=938):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_938",
    "sat": "def sat(n: int, year_len: int=939):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=939):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_939",
    "sat": "def sat(n: int, year_len: int=940):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=940):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_940",
    "sat": "def sat(n: int, year_len: int=941):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=941):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_941",
    "sat": "def sat(n: int, year_len: int=942):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=942):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_942",
    "sat": "def sat(n: int, year_len: int=943):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=943):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_943",
    "sat": "def sat(n: int, year_len: int=944):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=944):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_944",
    "sat": "def sat(n: int, year_len: int=945):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=945):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_945",
    "sat": "def sat(n: int, year_len: int=946):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=946):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_946",
    "sat": "def sat(n: int, year_len: int=947):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=947):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_947",
    "sat": "def sat(n: int, year_len: int=948):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=948):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_948",
    "sat": "def sat(n: int, year_len: int=949):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=949):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_949",
    "sat": "def sat(n: int, year_len: int=950):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=950):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_950",
    "sat": "def sat(n: int, year_len: int=951):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=951):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_951",
    "sat": "def sat(n: int, year_len: int=952):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=952):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_952",
    "sat": "def sat(n: int, year_len: int=953):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=953):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_953",
    "sat": "def sat(n: int, year_len: int=954):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=954):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_954",
    "sat": "def sat(n: int, year_len: int=955):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=955):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_955",
    "sat": "def sat(n: int, year_len: int=956):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=956):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_956",
    "sat": "def sat(n: int, year_len: int=957):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=957):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_957",
    "sat": "def sat(n: int, year_len: int=958):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=958):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_958",
    "sat": "def sat(n: int, year_len: int=959):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=959):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_959",
    "sat": "def sat(n: int, year_len: int=960):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=960):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_960",
    "sat": "def sat(n: int, year_len: int=961):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=961):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_961",
    "sat": "def sat(n: int, year_len: int=962):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=962):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_962",
    "sat": "def sat(n: int, year_len: int=963):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=963):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_963",
    "sat": "def sat(n: int, year_len: int=964):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=964):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_964",
    "sat": "def sat(n: int, year_len: int=965):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=965):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_965",
    "sat": "def sat(n: int, year_len: int=966):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=966):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_966",
    "sat": "def sat(n: int, year_len: int=967):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=967):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_967",
    "sat": "def sat(n: int, year_len: int=968):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=968):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_968",
    "sat": "def sat(n: int, year_len: int=969):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=969):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_969",
    "sat": "def sat(n: int, year_len: int=970):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=970):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_970",
    "sat": "def sat(n: int, year_len: int=971):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=971):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_971",
    "sat": "def sat(n: int, year_len: int=972):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=972):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_972",
    "sat": "def sat(n: int, year_len: int=973):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=973):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_973",
    "sat": "def sat(n: int, year_len: int=974):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=974):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_974",
    "sat": "def sat(n: int, year_len: int=975):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=975):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_975",
    "sat": "def sat(n: int, year_len: int=976):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=976):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_976",
    "sat": "def sat(n: int, year_len: int=977):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=977):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_977",
    "sat": "def sat(n: int, year_len: int=978):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=978):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_978",
    "sat": "def sat(n: int, year_len: int=979):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=979):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_979",
    "sat": "def sat(n: int, year_len: int=980):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=980):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_980",
    "sat": "def sat(n: int, year_len: int=981):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=981):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_981",
    "sat": "def sat(n: int, year_len: int=982):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=982):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_982",
    "sat": "def sat(n: int, year_len: int=983):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=983):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_983",
    "sat": "def sat(n: int, year_len: int=984):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=984):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_984",
    "sat": "def sat(n: int, year_len: int=985):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=985):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_985",
    "sat": "def sat(n: int, year_len: int=986):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=986):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_986",
    "sat": "def sat(n: int, year_len: int=987):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=987):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_987",
    "sat": "def sat(n: int, year_len: int=988):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=988):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_988",
    "sat": "def sat(n: int, year_len: int=989):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=989):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_989",
    "sat": "def sat(n: int, year_len: int=990):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=990):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_990",
    "sat": "def sat(n: int, year_len: int=991):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=991):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_991",
    "sat": "def sat(n: int, year_len: int=992):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=992):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_992",
    "sat": "def sat(n: int, year_len: int=993):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=993):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_993",
    "sat": "def sat(n: int, year_len: int=994):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=994):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_994",
    "sat": "def sat(n: int, year_len: int=995):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=995):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_995",
    "sat": "def sat(n: int, year_len: int=996):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=996):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_996",
    "sat": "def sat(n: int, year_len: int=997):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=997):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_997",
    "sat": "def sat(n: int, year_len: int=998):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=998):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_998",
    "sat": "def sat(n: int, year_len: int=999):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=999):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_999",
    "sat": "def sat(n: int, year_len: int=1000):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=1000):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_0",
    "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_1",
    "sat": "def sat(n: int, year_len: int=60182):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_2",
    "sat": "def sat(n: int, year_len: int=2):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_3",
    "sat": "def sat(n: int, year_len: int=3):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_4",
    "sat": "def sat(n: int, year_len: int=4):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_5",
    "sat": "def sat(n: int, year_len: int=5):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_6",
    "sat": "def sat(n: int, year_len: int=6):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_7",
    "sat": "def sat(n: int, year_len: int=7):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_8",
    "sat": "def sat(n: int, year_len: int=8):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_9",
    "sat": "def sat(n: int, year_len: int=9):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_10",
    "sat": "def sat(n: int, year_len: int=10):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=10):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_11",
    "sat": "def sat(n: int, year_len: int=11):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=11):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_12",
    "sat": "def sat(n: int, year_len: int=12):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=12):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_13",
    "sat": "def sat(n: int, year_len: int=13):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=13):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_14",
    "sat": "def sat(n: int, year_len: int=14):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=14):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_15",
    "sat": "def sat(n: int, year_len: int=15):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=15):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_16",
    "sat": "def sat(n: int, year_len: int=16):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=16):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_17",
    "sat": "def sat(n: int, year_len: int=17):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=17):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_18",
    "sat": "def sat(n: int, year_len: int=18):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=18):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_19",
    "sat": "def sat(n: int, year_len: int=19):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=19):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_20",
    "sat": "def sat(n: int, year_len: int=20):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=20):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_21",
    "sat": "def sat(n: int, year_len: int=21):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=21):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_22",
    "sat": "def sat(n: int, year_len: int=22):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=22):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_23",
    "sat": "def sat(n: int, year_len: int=23):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=23):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_24",
    "sat": "def sat(n: int, year_len: int=24):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=24):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_25",
    "sat": "def sat(n: int, year_len: int=25):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=25):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_26",
    "sat": "def sat(n: int, year_len: int=26):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=26):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_27",
    "sat": "def sat(n: int, year_len: int=27):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=27):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_28",
    "sat": "def sat(n: int, year_len: int=28):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=28):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_29",
    "sat": "def sat(n: int, year_len: int=29):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=29):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_30",
    "sat": "def sat(n: int, year_len: int=30):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=30):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_31",
    "sat": "def sat(n: int, year_len: int=31):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=31):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_32",
    "sat": "def sat(n: int, year_len: int=32):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=32):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_33",
    "sat": "def sat(n: int, year_len: int=33):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=33):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_34",
    "sat": "def sat(n: int, year_len: int=34):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=34):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_35",
    "sat": "def sat(n: int, year_len: int=35):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=35):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_36",
    "sat": "def sat(n: int, year_len: int=36):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=36):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_37",
    "sat": "def sat(n: int, year_len: int=37):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=37):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_38",
    "sat": "def sat(n: int, year_len: int=38):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=38):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_39",
    "sat": "def sat(n: int, year_len: int=39):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=39):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_40",
    "sat": "def sat(n: int, year_len: int=40):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=40):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_41",
    "sat": "def sat(n: int, year_len: int=41):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=41):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_42",
    "sat": "def sat(n: int, year_len: int=42):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=42):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_43",
    "sat": "def sat(n: int, year_len: int=43):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=43):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_44",
    "sat": "def sat(n: int, year_len: int=44):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=44):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_45",
    "sat": "def sat(n: int, year_len: int=45):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=45):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_46",
    "sat": "def sat(n: int, year_len: int=46):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=46):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_47",
    "sat": "def sat(n: int, year_len: int=47):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=47):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_48",
    "sat": "def sat(n: int, year_len: int=48):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=48):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_49",
    "sat": "def sat(n: int, year_len: int=49):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=49):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_50",
    "sat": "def sat(n: int, year_len: int=50):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=50):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_51",
    "sat": "def sat(n: int, year_len: int=51):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=51):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_52",
    "sat": "def sat(n: int, year_len: int=52):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=52):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_53",
    "sat": "def sat(n: int, year_len: int=53):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=53):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_54",
    "sat": "def sat(n: int, year_len: int=54):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=54):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_55",
    "sat": "def sat(n: int, year_len: int=55):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=55):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_56",
    "sat": "def sat(n: int, year_len: int=56):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=56):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_57",
    "sat": "def sat(n: int, year_len: int=57):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=57):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_58",
    "sat": "def sat(n: int, year_len: int=58):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=58):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_59",
    "sat": "def sat(n: int, year_len: int=59):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=59):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_60",
    "sat": "def sat(n: int, year_len: int=60):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=60):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_61",
    "sat": "def sat(n: int, year_len: int=61):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=61):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_62",
    "sat": "def sat(n: int, year_len: int=62):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=62):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_63",
    "sat": "def sat(n: int, year_len: int=63):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=63):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_64",
    "sat": "def sat(n: int, year_len: int=64):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=64):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_65",
    "sat": "def sat(n: int, year_len: int=65):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=65):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_66",
    "sat": "def sat(n: int, year_len: int=66):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=66):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_67",
    "sat": "def sat(n: int, year_len: int=67):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=67):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_68",
    "sat": "def sat(n: int, year_len: int=68):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=68):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_69",
    "sat": "def sat(n: int, year_len: int=69):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=69):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_70",
    "sat": "def sat(n: int, year_len: int=70):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=70):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_71",
    "sat": "def sat(n: int, year_len: int=71):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=71):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_72",
    "sat": "def sat(n: int, year_len: int=72):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=72):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_73",
    "sat": "def sat(n: int, year_len: int=73):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=73):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_74",
    "sat": "def sat(n: int, year_len: int=74):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=74):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_75",
    "sat": "def sat(n: int, year_len: int=75):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=75):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_76",
    "sat": "def sat(n: int, year_len: int=76):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=76):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_77",
    "sat": "def sat(n: int, year_len: int=77):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=77):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_78",
    "sat": "def sat(n: int, year_len: int=78):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=78):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_79",
    "sat": "def sat(n: int, year_len: int=79):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=79):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_80",
    "sat": "def sat(n: int, year_len: int=80):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=80):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_81",
    "sat": "def sat(n: int, year_len: int=81):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=81):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_82",
    "sat": "def sat(n: int, year_len: int=82):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=82):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_83",
    "sat": "def sat(n: int, year_len: int=83):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=83):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_84",
    "sat": "def sat(n: int, year_len: int=84):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=84):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_85",
    "sat": "def sat(n: int, year_len: int=85):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=85):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_86",
    "sat": "def sat(n: int, year_len: int=86):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=86):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_87",
    "sat": "def sat(n: int, year_len: int=87):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=87):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_88",
    "sat": "def sat(n: int, year_len: int=88):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=88):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_89",
    "sat": "def sat(n: int, year_len: int=89):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=89):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_90",
    "sat": "def sat(n: int, year_len: int=90):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=90):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_91",
    "sat": "def sat(n: int, year_len: int=91):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=91):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_92",
    "sat": "def sat(n: int, year_len: int=92):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=92):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_93",
    "sat": "def sat(n: int, year_len: int=93):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=93):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_94",
    "sat": "def sat(n: int, year_len: int=94):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=94):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_95",
    "sat": "def sat(n: int, year_len: int=95):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=95):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_96",
    "sat": "def sat(n: int, year_len: int=96):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=96):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_97",
    "sat": "def sat(n: int, year_len: int=97):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=97):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_98",
    "sat": "def sat(n: int, year_len: int=98):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=98):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_99",
    "sat": "def sat(n: int, year_len: int=99):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=99):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_100",
    "sat": "def sat(n: int, year_len: int=100):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=100):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_101",
    "sat": "def sat(n: int, year_len: int=101):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=101):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_102",
    "sat": "def sat(n: int, year_len: int=102):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=102):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_103",
    "sat": "def sat(n: int, year_len: int=103):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=103):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_104",
    "sat": "def sat(n: int, year_len: int=104):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=104):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_105",
    "sat": "def sat(n: int, year_len: int=105):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=105):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_106",
    "sat": "def sat(n: int, year_len: int=106):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=106):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_107",
    "sat": "def sat(n: int, year_len: int=107):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=107):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_108",
    "sat": "def sat(n: int, year_len: int=108):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=108):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_109",
    "sat": "def sat(n: int, year_len: int=109):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=109):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_110",
    "sat": "def sat(n: int, year_len: int=110):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=110):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_111",
    "sat": "def sat(n: int, year_len: int=111):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=111):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_112",
    "sat": "def sat(n: int, year_len: int=112):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=112):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_113",
    "sat": "def sat(n: int, year_len: int=113):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=113):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_114",
    "sat": "def sat(n: int, year_len: int=114):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=114):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_115",
    "sat": "def sat(n: int, year_len: int=115):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=115):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_116",
    "sat": "def sat(n: int, year_len: int=116):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=116):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_117",
    "sat": "def sat(n: int, year_len: int=117):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=117):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_118",
    "sat": "def sat(n: int, year_len: int=118):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=118):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_119",
    "sat": "def sat(n: int, year_len: int=119):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=119):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_120",
    "sat": "def sat(n: int, year_len: int=120):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=120):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_121",
    "sat": "def sat(n: int, year_len: int=121):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=121):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_122",
    "sat": "def sat(n: int, year_len: int=122):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=122):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_123",
    "sat": "def sat(n: int, year_len: int=123):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=123):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_124",
    "sat": "def sat(n: int, year_len: int=124):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=124):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_125",
    "sat": "def sat(n: int, year_len: int=125):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=125):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_126",
    "sat": "def sat(n: int, year_len: int=126):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=126):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_127",
    "sat": "def sat(n: int, year_len: int=127):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=127):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_128",
    "sat": "def sat(n: int, year_len: int=128):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=128):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_129",
    "sat": "def sat(n: int, year_len: int=129):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=129):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_130",
    "sat": "def sat(n: int, year_len: int=130):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=130):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_131",
    "sat": "def sat(n: int, year_len: int=131):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=131):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_132",
    "sat": "def sat(n: int, year_len: int=132):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=132):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_133",
    "sat": "def sat(n: int, year_len: int=133):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=133):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_134",
    "sat": "def sat(n: int, year_len: int=134):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=134):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_135",
    "sat": "def sat(n: int, year_len: int=135):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=135):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_136",
    "sat": "def sat(n: int, year_len: int=136):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=136):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_137",
    "sat": "def sat(n: int, year_len: int=137):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=137):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_138",
    "sat": "def sat(n: int, year_len: int=138):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=138):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_139",
    "sat": "def sat(n: int, year_len: int=139):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=139):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_140",
    "sat": "def sat(n: int, year_len: int=140):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=140):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_141",
    "sat": "def sat(n: int, year_len: int=141):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=141):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_142",
    "sat": "def sat(n: int, year_len: int=142):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=142):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_143",
    "sat": "def sat(n: int, year_len: int=143):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=143):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_144",
    "sat": "def sat(n: int, year_len: int=144):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=144):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_145",
    "sat": "def sat(n: int, year_len: int=145):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=145):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_146",
    "sat": "def sat(n: int, year_len: int=146):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=146):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_147",
    "sat": "def sat(n: int, year_len: int=147):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=147):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_148",
    "sat": "def sat(n: int, year_len: int=148):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=148):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_149",
    "sat": "def sat(n: int, year_len: int=149):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=149):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_150",
    "sat": "def sat(n: int, year_len: int=150):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=150):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_151",
    "sat": "def sat(n: int, year_len: int=151):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=151):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_152",
    "sat": "def sat(n: int, year_len: int=152):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=152):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_153",
    "sat": "def sat(n: int, year_len: int=153):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=153):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_154",
    "sat": "def sat(n: int, year_len: int=154):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=154):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_155",
    "sat": "def sat(n: int, year_len: int=155):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=155):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_156",
    "sat": "def sat(n: int, year_len: int=156):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=156):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_157",
    "sat": "def sat(n: int, year_len: int=157):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=157):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_158",
    "sat": "def sat(n: int, year_len: int=158):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=158):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_159",
    "sat": "def sat(n: int, year_len: int=159):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=159):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_160",
    "sat": "def sat(n: int, year_len: int=160):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=160):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_161",
    "sat": "def sat(n: int, year_len: int=161):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=161):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_162",
    "sat": "def sat(n: int, year_len: int=162):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=162):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_163",
    "sat": "def sat(n: int, year_len: int=163):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=163):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_164",
    "sat": "def sat(n: int, year_len: int=164):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=164):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_165",
    "sat": "def sat(n: int, year_len: int=165):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=165):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_166",
    "sat": "def sat(n: int, year_len: int=166):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=166):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_167",
    "sat": "def sat(n: int, year_len: int=167):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=167):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_168",
    "sat": "def sat(n: int, year_len: int=168):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=168):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_169",
    "sat": "def sat(n: int, year_len: int=169):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=169):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_170",
    "sat": "def sat(n: int, year_len: int=170):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=170):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_171",
    "sat": "def sat(n: int, year_len: int=171):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=171):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_172",
    "sat": "def sat(n: int, year_len: int=172):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=172):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_173",
    "sat": "def sat(n: int, year_len: int=173):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=173):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_174",
    "sat": "def sat(n: int, year_len: int=174):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=174):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_175",
    "sat": "def sat(n: int, year_len: int=175):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=175):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_176",
    "sat": "def sat(n: int, year_len: int=176):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=176):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_177",
    "sat": "def sat(n: int, year_len: int=177):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=177):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_178",
    "sat": "def sat(n: int, year_len: int=178):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=178):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_179",
    "sat": "def sat(n: int, year_len: int=179):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=179):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_180",
    "sat": "def sat(n: int, year_len: int=180):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=180):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_181",
    "sat": "def sat(n: int, year_len: int=181):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=181):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_182",
    "sat": "def sat(n: int, year_len: int=182):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_183",
    "sat": "def sat(n: int, year_len: int=183):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=183):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_184",
    "sat": "def sat(n: int, year_len: int=184):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=184):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_185",
    "sat": "def sat(n: int, year_len: int=185):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=185):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_186",
    "sat": "def sat(n: int, year_len: int=186):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=186):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_187",
    "sat": "def sat(n: int, year_len: int=187):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=187):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_188",
    "sat": "def sat(n: int, year_len: int=188):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=188):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_189",
    "sat": "def sat(n: int, year_len: int=189):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=189):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_190",
    "sat": "def sat(n: int, year_len: int=190):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=190):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_191",
    "sat": "def sat(n: int, year_len: int=191):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=191):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_192",
    "sat": "def sat(n: int, year_len: int=192):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=192):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_193",
    "sat": "def sat(n: int, year_len: int=193):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=193):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_194",
    "sat": "def sat(n: int, year_len: int=194):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=194):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_195",
    "sat": "def sat(n: int, year_len: int=195):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=195):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_196",
    "sat": "def sat(n: int, year_len: int=196):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=196):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_197",
    "sat": "def sat(n: int, year_len: int=197):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=197):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_198",
    "sat": "def sat(n: int, year_len: int=198):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=198):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_199",
    "sat": "def sat(n: int, year_len: int=199):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=199):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_200",
    "sat": "def sat(n: int, year_len: int=200):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=200):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_201",
    "sat": "def sat(n: int, year_len: int=201):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=201):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_202",
    "sat": "def sat(n: int, year_len: int=202):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=202):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_203",
    "sat": "def sat(n: int, year_len: int=203):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=203):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_204",
    "sat": "def sat(n: int, year_len: int=204):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=204):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_205",
    "sat": "def sat(n: int, year_len: int=205):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=205):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_206",
    "sat": "def sat(n: int, year_len: int=206):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=206):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_207",
    "sat": "def sat(n: int, year_len: int=207):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=207):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_208",
    "sat": "def sat(n: int, year_len: int=208):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=208):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_209",
    "sat": "def sat(n: int, year_len: int=209):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=209):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_210",
    "sat": "def sat(n: int, year_len: int=210):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=210):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_211",
    "sat": "def sat(n: int, year_len: int=211):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=211):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_212",
    "sat": "def sat(n: int, year_len: int=212):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=212):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_213",
    "sat": "def sat(n: int, year_len: int=213):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=213):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_214",
    "sat": "def sat(n: int, year_len: int=214):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=214):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_215",
    "sat": "def sat(n: int, year_len: int=215):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=215):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_216",
    "sat": "def sat(n: int, year_len: int=216):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=216):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_217",
    "sat": "def sat(n: int, year_len: int=217):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=217):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_218",
    "sat": "def sat(n: int, year_len: int=218):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=218):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_219",
    "sat": "def sat(n: int, year_len: int=219):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=219):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_220",
    "sat": "def sat(n: int, year_len: int=220):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=220):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_221",
    "sat": "def sat(n: int, year_len: int=221):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=221):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_222",
    "sat": "def sat(n: int, year_len: int=222):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=222):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_223",
    "sat": "def sat(n: int, year_len: int=223):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=223):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_224",
    "sat": "def sat(n: int, year_len: int=224):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=224):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_225",
    "sat": "def sat(n: int, year_len: int=225):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=225):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_226",
    "sat": "def sat(n: int, year_len: int=226):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=226):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_227",
    "sat": "def sat(n: int, year_len: int=227):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=227):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_228",
    "sat": "def sat(n: int, year_len: int=228):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=228):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_229",
    "sat": "def sat(n: int, year_len: int=229):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=229):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_230",
    "sat": "def sat(n: int, year_len: int=230):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=230):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_231",
    "sat": "def sat(n: int, year_len: int=231):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=231):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_232",
    "sat": "def sat(n: int, year_len: int=232):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=232):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_233",
    "sat": "def sat(n: int, year_len: int=233):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=233):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_234",
    "sat": "def sat(n: int, year_len: int=234):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=234):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_235",
    "sat": "def sat(n: int, year_len: int=235):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=235):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_236",
    "sat": "def sat(n: int, year_len: int=236):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=236):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_237",
    "sat": "def sat(n: int, year_len: int=237):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=237):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_238",
    "sat": "def sat(n: int, year_len: int=238):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=238):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_239",
    "sat": "def sat(n: int, year_len: int=239):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=239):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_240",
    "sat": "def sat(n: int, year_len: int=240):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=240):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_241",
    "sat": "def sat(n: int, year_len: int=241):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=241):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_242",
    "sat": "def sat(n: int, year_len: int=242):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=242):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_243",
    "sat": "def sat(n: int, year_len: int=243):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=243):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_244",
    "sat": "def sat(n: int, year_len: int=244):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=244):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_245",
    "sat": "def sat(n: int, year_len: int=245):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=245):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_246",
    "sat": "def sat(n: int, year_len: int=246):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=246):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_247",
    "sat": "def sat(n: int, year_len: int=247):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=247):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_248",
    "sat": "def sat(n: int, year_len: int=248):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=248):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_249",
    "sat": "def sat(n: int, year_len: int=249):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=249):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_250",
    "sat": "def sat(n: int, year_len: int=250):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=250):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_251",
    "sat": "def sat(n: int, year_len: int=251):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=251):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_252",
    "sat": "def sat(n: int, year_len: int=252):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=252):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_253",
    "sat": "def sat(n: int, year_len: int=253):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=253):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_254",
    "sat": "def sat(n: int, year_len: int=254):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=254):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_255",
    "sat": "def sat(n: int, year_len: int=255):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=255):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_256",
    "sat": "def sat(n: int, year_len: int=256):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=256):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_257",
    "sat": "def sat(n: int, year_len: int=257):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=257):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_258",
    "sat": "def sat(n: int, year_len: int=258):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=258):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_259",
    "sat": "def sat(n: int, year_len: int=259):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=259):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_260",
    "sat": "def sat(n: int, year_len: int=260):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=260):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_261",
    "sat": "def sat(n: int, year_len: int=261):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=261):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_262",
    "sat": "def sat(n: int, year_len: int=262):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=262):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_263",
    "sat": "def sat(n: int, year_len: int=263):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=263):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_264",
    "sat": "def sat(n: int, year_len: int=264):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=264):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_265",
    "sat": "def sat(n: int, year_len: int=265):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=265):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_266",
    "sat": "def sat(n: int, year_len: int=266):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=266):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_267",
    "sat": "def sat(n: int, year_len: int=267):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=267):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_268",
    "sat": "def sat(n: int, year_len: int=268):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=268):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_269",
    "sat": "def sat(n: int, year_len: int=269):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=269):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_270",
    "sat": "def sat(n: int, year_len: int=270):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=270):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_271",
    "sat": "def sat(n: int, year_len: int=271):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=271):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_272",
    "sat": "def sat(n: int, year_len: int=272):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=272):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_273",
    "sat": "def sat(n: int, year_len: int=273):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=273):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_274",
    "sat": "def sat(n: int, year_len: int=274):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=274):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_275",
    "sat": "def sat(n: int, year_len: int=275):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=275):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_276",
    "sat": "def sat(n: int, year_len: int=276):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=276):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_277",
    "sat": "def sat(n: int, year_len: int=277):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=277):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_278",
    "sat": "def sat(n: int, year_len: int=278):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=278):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_279",
    "sat": "def sat(n: int, year_len: int=279):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=279):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_280",
    "sat": "def sat(n: int, year_len: int=280):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=280):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_281",
    "sat": "def sat(n: int, year_len: int=281):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=281):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_282",
    "sat": "def sat(n: int, year_len: int=282):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=282):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_283",
    "sat": "def sat(n: int, year_len: int=283):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=283):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_284",
    "sat": "def sat(n: int, year_len: int=284):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=284):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_285",
    "sat": "def sat(n: int, year_len: int=285):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=285):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_286",
    "sat": "def sat(n: int, year_len: int=286):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=286):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_287",
    "sat": "def sat(n: int, year_len: int=287):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=287):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_288",
    "sat": "def sat(n: int, year_len: int=288):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=288):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_289",
    "sat": "def sat(n: int, year_len: int=289):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=289):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_290",
    "sat": "def sat(n: int, year_len: int=290):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=290):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_291",
    "sat": "def sat(n: int, year_len: int=291):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=291):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_292",
    "sat": "def sat(n: int, year_len: int=292):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=292):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_293",
    "sat": "def sat(n: int, year_len: int=293):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=293):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_294",
    "sat": "def sat(n: int, year_len: int=294):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=294):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_295",
    "sat": "def sat(n: int, year_len: int=295):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=295):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_296",
    "sat": "def sat(n: int, year_len: int=296):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=296):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_297",
    "sat": "def sat(n: int, year_len: int=297):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=297):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_298",
    "sat": "def sat(n: int, year_len: int=298):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=298):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_299",
    "sat": "def sat(n: int, year_len: int=299):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=299):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_300",
    "sat": "def sat(n: int, year_len: int=300):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=300):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_301",
    "sat": "def sat(n: int, year_len: int=301):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=301):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_302",
    "sat": "def sat(n: int, year_len: int=302):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=302):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_303",
    "sat": "def sat(n: int, year_len: int=303):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=303):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_304",
    "sat": "def sat(n: int, year_len: int=304):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=304):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_305",
    "sat": "def sat(n: int, year_len: int=305):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=305):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_306",
    "sat": "def sat(n: int, year_len: int=306):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=306):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_307",
    "sat": "def sat(n: int, year_len: int=307):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=307):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_308",
    "sat": "def sat(n: int, year_len: int=308):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=308):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_309",
    "sat": "def sat(n: int, year_len: int=309):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=309):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_310",
    "sat": "def sat(n: int, year_len: int=310):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=310):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_311",
    "sat": "def sat(n: int, year_len: int=311):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=311):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_312",
    "sat": "def sat(n: int, year_len: int=312):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=312):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_313",
    "sat": "def sat(n: int, year_len: int=313):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=313):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_314",
    "sat": "def sat(n: int, year_len: int=314):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=314):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_315",
    "sat": "def sat(n: int, year_len: int=315):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=315):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_316",
    "sat": "def sat(n: int, year_len: int=316):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=316):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_317",
    "sat": "def sat(n: int, year_len: int=317):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=317):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_318",
    "sat": "def sat(n: int, year_len: int=318):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=318):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_319",
    "sat": "def sat(n: int, year_len: int=319):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=319):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_320",
    "sat": "def sat(n: int, year_len: int=320):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=320):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_321",
    "sat": "def sat(n: int, year_len: int=321):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=321):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_322",
    "sat": "def sat(n: int, year_len: int=322):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=322):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_323",
    "sat": "def sat(n: int, year_len: int=323):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=323):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_324",
    "sat": "def sat(n: int, year_len: int=324):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=324):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_325",
    "sat": "def sat(n: int, year_len: int=325):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=325):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_326",
    "sat": "def sat(n: int, year_len: int=326):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=326):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_327",
    "sat": "def sat(n: int, year_len: int=327):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=327):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_328",
    "sat": "def sat(n: int, year_len: int=328):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=328):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_329",
    "sat": "def sat(n: int, year_len: int=329):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=329):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_330",
    "sat": "def sat(n: int, year_len: int=330):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=330):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_331",
    "sat": "def sat(n: int, year_len: int=331):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=331):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_332",
    "sat": "def sat(n: int, year_len: int=332):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=332):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_333",
    "sat": "def sat(n: int, year_len: int=333):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=333):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_334",
    "sat": "def sat(n: int, year_len: int=334):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=334):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_335",
    "sat": "def sat(n: int, year_len: int=335):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=335):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_336",
    "sat": "def sat(n: int, year_len: int=336):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=336):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_337",
    "sat": "def sat(n: int, year_len: int=337):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=337):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_338",
    "sat": "def sat(n: int, year_len: int=338):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=338):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_339",
    "sat": "def sat(n: int, year_len: int=339):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=339):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_340",
    "sat": "def sat(n: int, year_len: int=340):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=340):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_341",
    "sat": "def sat(n: int, year_len: int=341):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=341):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_342",
    "sat": "def sat(n: int, year_len: int=342):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=342):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_343",
    "sat": "def sat(n: int, year_len: int=343):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=343):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_344",
    "sat": "def sat(n: int, year_len: int=344):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=344):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_345",
    "sat": "def sat(n: int, year_len: int=345):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=345):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_346",
    "sat": "def sat(n: int, year_len: int=346):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=346):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_347",
    "sat": "def sat(n: int, year_len: int=347):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=347):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_348",
    "sat": "def sat(n: int, year_len: int=348):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=348):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_349",
    "sat": "def sat(n: int, year_len: int=349):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=349):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_350",
    "sat": "def sat(n: int, year_len: int=350):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=350):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_351",
    "sat": "def sat(n: int, year_len: int=351):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=351):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_352",
    "sat": "def sat(n: int, year_len: int=352):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=352):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_353",
    "sat": "def sat(n: int, year_len: int=353):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=353):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_354",
    "sat": "def sat(n: int, year_len: int=354):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=354):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_355",
    "sat": "def sat(n: int, year_len: int=355):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=355):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_356",
    "sat": "def sat(n: int, year_len: int=356):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=356):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_357",
    "sat": "def sat(n: int, year_len: int=357):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=357):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_358",
    "sat": "def sat(n: int, year_len: int=358):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=358):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_359",
    "sat": "def sat(n: int, year_len: int=359):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=359):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_360",
    "sat": "def sat(n: int, year_len: int=360):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=360):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_361",
    "sat": "def sat(n: int, year_len: int=361):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=361):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_362",
    "sat": "def sat(n: int, year_len: int=362):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=362):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_363",
    "sat": "def sat(n: int, year_len: int=363):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=363):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_364",
    "sat": "def sat(n: int, year_len: int=364):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=364):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_365",
    "sat": "def sat(n: int, year_len: int=366):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=366):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_366",
    "sat": "def sat(n: int, year_len: int=367):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=367):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_367",
    "sat": "def sat(n: int, year_len: int=368):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=368):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_368",
    "sat": "def sat(n: int, year_len: int=369):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=369):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_369",
    "sat": "def sat(n: int, year_len: int=370):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=370):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_370",
    "sat": "def sat(n: int, year_len: int=371):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=371):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_371",
    "sat": "def sat(n: int, year_len: int=372):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=372):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_372",
    "sat": "def sat(n: int, year_len: int=373):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=373):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_373",
    "sat": "def sat(n: int, year_len: int=374):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=374):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_374",
    "sat": "def sat(n: int, year_len: int=375):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=375):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_375",
    "sat": "def sat(n: int, year_len: int=376):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=376):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_376",
    "sat": "def sat(n: int, year_len: int=377):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=377):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_377",
    "sat": "def sat(n: int, year_len: int=378):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=378):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_378",
    "sat": "def sat(n: int, year_len: int=379):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=379):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_379",
    "sat": "def sat(n: int, year_len: int=380):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=380):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_380",
    "sat": "def sat(n: int, year_len: int=381):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=381):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_381",
    "sat": "def sat(n: int, year_len: int=382):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=382):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_382",
    "sat": "def sat(n: int, year_len: int=383):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=383):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_383",
    "sat": "def sat(n: int, year_len: int=384):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=384):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_384",
    "sat": "def sat(n: int, year_len: int=385):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=385):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_385",
    "sat": "def sat(n: int, year_len: int=386):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=386):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_386",
    "sat": "def sat(n: int, year_len: int=387):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=387):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_387",
    "sat": "def sat(n: int, year_len: int=388):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=388):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_388",
    "sat": "def sat(n: int, year_len: int=389):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=389):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_389",
    "sat": "def sat(n: int, year_len: int=390):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=390):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_390",
    "sat": "def sat(n: int, year_len: int=391):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=391):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_391",
    "sat": "def sat(n: int, year_len: int=392):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=392):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_392",
    "sat": "def sat(n: int, year_len: int=393):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=393):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_393",
    "sat": "def sat(n: int, year_len: int=394):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=394):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_394",
    "sat": "def sat(n: int, year_len: int=395):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=395):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_395",
    "sat": "def sat(n: int, year_len: int=396):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=396):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_396",
    "sat": "def sat(n: int, year_len: int=397):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=397):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_397",
    "sat": "def sat(n: int, year_len: int=398):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=398):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_398",
    "sat": "def sat(n: int, year_len: int=399):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=399):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_399",
    "sat": "def sat(n: int, year_len: int=400):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=400):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_400",
    "sat": "def sat(n: int, year_len: int=401):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=401):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_401",
    "sat": "def sat(n: int, year_len: int=402):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=402):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_402",
    "sat": "def sat(n: int, year_len: int=403):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=403):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_403",
    "sat": "def sat(n: int, year_len: int=404):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=404):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_404",
    "sat": "def sat(n: int, year_len: int=405):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=405):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_405",
    "sat": "def sat(n: int, year_len: int=406):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=406):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_406",
    "sat": "def sat(n: int, year_len: int=407):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=407):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_407",
    "sat": "def sat(n: int, year_len: int=408):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=408):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_408",
    "sat": "def sat(n: int, year_len: int=409):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=409):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_409",
    "sat": "def sat(n: int, year_len: int=410):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=410):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_410",
    "sat": "def sat(n: int, year_len: int=411):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=411):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_411",
    "sat": "def sat(n: int, year_len: int=412):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=412):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_412",
    "sat": "def sat(n: int, year_len: int=413):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=413):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_413",
    "sat": "def sat(n: int, year_len: int=414):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=414):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_414",
    "sat": "def sat(n: int, year_len: int=415):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=415):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_415",
    "sat": "def sat(n: int, year_len: int=416):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=416):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_416",
    "sat": "def sat(n: int, year_len: int=417):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=417):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_417",
    "sat": "def sat(n: int, year_len: int=418):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=418):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_418",
    "sat": "def sat(n: int, year_len: int=419):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=419):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_419",
    "sat": "def sat(n: int, year_len: int=420):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=420):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_420",
    "sat": "def sat(n: int, year_len: int=421):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=421):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_421",
    "sat": "def sat(n: int, year_len: int=422):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=422):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_422",
    "sat": "def sat(n: int, year_len: int=423):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=423):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_423",
    "sat": "def sat(n: int, year_len: int=424):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=424):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_424",
    "sat": "def sat(n: int, year_len: int=425):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=425):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_425",
    "sat": "def sat(n: int, year_len: int=426):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=426):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_426",
    "sat": "def sat(n: int, year_len: int=427):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=427):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_427",
    "sat": "def sat(n: int, year_len: int=428):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=428):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_428",
    "sat": "def sat(n: int, year_len: int=429):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=429):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_429",
    "sat": "def sat(n: int, year_len: int=430):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=430):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_430",
    "sat": "def sat(n: int, year_len: int=431):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=431):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_431",
    "sat": "def sat(n: int, year_len: int=432):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=432):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_432",
    "sat": "def sat(n: int, year_len: int=433):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=433):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_433",
    "sat": "def sat(n: int, year_len: int=434):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=434):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_434",
    "sat": "def sat(n: int, year_len: int=435):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=435):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_435",
    "sat": "def sat(n: int, year_len: int=436):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=436):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_436",
    "sat": "def sat(n: int, year_len: int=437):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=437):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_437",
    "sat": "def sat(n: int, year_len: int=438):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=438):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_438",
    "sat": "def sat(n: int, year_len: int=439):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=439):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_439",
    "sat": "def sat(n: int, year_len: int=440):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=440):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_440",
    "sat": "def sat(n: int, year_len: int=441):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=441):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_441",
    "sat": "def sat(n: int, year_len: int=442):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=442):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_442",
    "sat": "def sat(n: int, year_len: int=443):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=443):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_443",
    "sat": "def sat(n: int, year_len: int=444):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=444):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_444",
    "sat": "def sat(n: int, year_len: int=445):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=445):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_445",
    "sat": "def sat(n: int, year_len: int=446):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=446):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_446",
    "sat": "def sat(n: int, year_len: int=447):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=447):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_447",
    "sat": "def sat(n: int, year_len: int=448):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=448):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_448",
    "sat": "def sat(n: int, year_len: int=449):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=449):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_449",
    "sat": "def sat(n: int, year_len: int=450):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=450):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_450",
    "sat": "def sat(n: int, year_len: int=451):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=451):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_451",
    "sat": "def sat(n: int, year_len: int=452):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=452):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_452",
    "sat": "def sat(n: int, year_len: int=453):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=453):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_453",
    "sat": "def sat(n: int, year_len: int=454):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=454):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_454",
    "sat": "def sat(n: int, year_len: int=455):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=455):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_455",
    "sat": "def sat(n: int, year_len: int=456):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=456):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_456",
    "sat": "def sat(n: int, year_len: int=457):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=457):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_457",
    "sat": "def sat(n: int, year_len: int=458):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=458):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_458",
    "sat": "def sat(n: int, year_len: int=459):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=459):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_459",
    "sat": "def sat(n: int, year_len: int=460):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=460):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_460",
    "sat": "def sat(n: int, year_len: int=461):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=461):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_461",
    "sat": "def sat(n: int, year_len: int=462):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=462):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_462",
    "sat": "def sat(n: int, year_len: int=463):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=463):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_463",
    "sat": "def sat(n: int, year_len: int=464):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=464):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_464",
    "sat": "def sat(n: int, year_len: int=465):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=465):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_465",
    "sat": "def sat(n: int, year_len: int=466):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=466):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_466",
    "sat": "def sat(n: int, year_len: int=467):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=467):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_467",
    "sat": "def sat(n: int, year_len: int=468):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=468):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_468",
    "sat": "def sat(n: int, year_len: int=469):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=469):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_469",
    "sat": "def sat(n: int, year_len: int=470):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=470):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_470",
    "sat": "def sat(n: int, year_len: int=471):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=471):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_471",
    "sat": "def sat(n: int, year_len: int=472):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=472):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_472",
    "sat": "def sat(n: int, year_len: int=473):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=473):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_473",
    "sat": "def sat(n: int, year_len: int=474):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=474):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_474",
    "sat": "def sat(n: int, year_len: int=475):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=475):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_475",
    "sat": "def sat(n: int, year_len: int=476):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=476):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_476",
    "sat": "def sat(n: int, year_len: int=477):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=477):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_477",
    "sat": "def sat(n: int, year_len: int=478):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=478):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_478",
    "sat": "def sat(n: int, year_len: int=479):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=479):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_479",
    "sat": "def sat(n: int, year_len: int=480):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=480):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_480",
    "sat": "def sat(n: int, year_len: int=481):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=481):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_481",
    "sat": "def sat(n: int, year_len: int=482):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=482):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_482",
    "sat": "def sat(n: int, year_len: int=483):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=483):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_483",
    "sat": "def sat(n: int, year_len: int=484):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=484):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_484",
    "sat": "def sat(n: int, year_len: int=485):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=485):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_485",
    "sat": "def sat(n: int, year_len: int=486):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=486):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_486",
    "sat": "def sat(n: int, year_len: int=487):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=487):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_487",
    "sat": "def sat(n: int, year_len: int=488):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=488):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_488",
    "sat": "def sat(n: int, year_len: int=489):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=489):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_489",
    "sat": "def sat(n: int, year_len: int=490):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=490):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_490",
    "sat": "def sat(n: int, year_len: int=491):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=491):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_491",
    "sat": "def sat(n: int, year_len: int=492):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=492):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_492",
    "sat": "def sat(n: int, year_len: int=493):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=493):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_493",
    "sat": "def sat(n: int, year_len: int=494):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=494):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_494",
    "sat": "def sat(n: int, year_len: int=495):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=495):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_495",
    "sat": "def sat(n: int, year_len: int=496):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=496):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_496",
    "sat": "def sat(n: int, year_len: int=497):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=497):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_497",
    "sat": "def sat(n: int, year_len: int=498):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=498):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_498",
    "sat": "def sat(n: int, year_len: int=499):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=499):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_499",
    "sat": "def sat(n: int, year_len: int=500):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=500):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_500",
    "sat": "def sat(n: int, year_len: int=501):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=501):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_501",
    "sat": "def sat(n: int, year_len: int=502):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=502):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_502",
    "sat": "def sat(n: int, year_len: int=503):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=503):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_503",
    "sat": "def sat(n: int, year_len: int=504):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=504):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_504",
    "sat": "def sat(n: int, year_len: int=505):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=505):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_505",
    "sat": "def sat(n: int, year_len: int=506):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=506):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_506",
    "sat": "def sat(n: int, year_len: int=507):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=507):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_507",
    "sat": "def sat(n: int, year_len: int=508):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=508):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_508",
    "sat": "def sat(n: int, year_len: int=509):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=509):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_509",
    "sat": "def sat(n: int, year_len: int=510):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=510):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_510",
    "sat": "def sat(n: int, year_len: int=511):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=511):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_511",
    "sat": "def sat(n: int, year_len: int=512):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=512):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_512",
    "sat": "def sat(n: int, year_len: int=513):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=513):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_513",
    "sat": "def sat(n: int, year_len: int=514):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=514):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_514",
    "sat": "def sat(n: int, year_len: int=515):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=515):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_515",
    "sat": "def sat(n: int, year_len: int=516):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=516):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_516",
    "sat": "def sat(n: int, year_len: int=517):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=517):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_517",
    "sat": "def sat(n: int, year_len: int=518):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=518):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_518",
    "sat": "def sat(n: int, year_len: int=519):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=519):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_519",
    "sat": "def sat(n: int, year_len: int=520):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=520):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_520",
    "sat": "def sat(n: int, year_len: int=521):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=521):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_521",
    "sat": "def sat(n: int, year_len: int=522):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=522):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_522",
    "sat": "def sat(n: int, year_len: int=523):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=523):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_523",
    "sat": "def sat(n: int, year_len: int=524):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=524):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_524",
    "sat": "def sat(n: int, year_len: int=525):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=525):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_525",
    "sat": "def sat(n: int, year_len: int=526):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=526):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_526",
    "sat": "def sat(n: int, year_len: int=527):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=527):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_527",
    "sat": "def sat(n: int, year_len: int=528):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=528):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_528",
    "sat": "def sat(n: int, year_len: int=529):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=529):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_529",
    "sat": "def sat(n: int, year_len: int=530):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=530):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_530",
    "sat": "def sat(n: int, year_len: int=531):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=531):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_531",
    "sat": "def sat(n: int, year_len: int=532):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=532):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_532",
    "sat": "def sat(n: int, year_len: int=533):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=533):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_533",
    "sat": "def sat(n: int, year_len: int=534):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=534):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_534",
    "sat": "def sat(n: int, year_len: int=535):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=535):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_535",
    "sat": "def sat(n: int, year_len: int=536):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=536):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_536",
    "sat": "def sat(n: int, year_len: int=537):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=537):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_537",
    "sat": "def sat(n: int, year_len: int=538):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=538):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_538",
    "sat": "def sat(n: int, year_len: int=539):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=539):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_539",
    "sat": "def sat(n: int, year_len: int=540):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=540):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_540",
    "sat": "def sat(n: int, year_len: int=541):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=541):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_541",
    "sat": "def sat(n: int, year_len: int=542):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=542):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_542",
    "sat": "def sat(n: int, year_len: int=543):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=543):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_543",
    "sat": "def sat(n: int, year_len: int=544):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=544):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_544",
    "sat": "def sat(n: int, year_len: int=545):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=545):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_545",
    "sat": "def sat(n: int, year_len: int=546):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=546):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_546",
    "sat": "def sat(n: int, year_len: int=547):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=547):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_547",
    "sat": "def sat(n: int, year_len: int=548):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=548):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_548",
    "sat": "def sat(n: int, year_len: int=549):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=549):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_549",
    "sat": "def sat(n: int, year_len: int=550):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=550):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_550",
    "sat": "def sat(n: int, year_len: int=551):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=551):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_551",
    "sat": "def sat(n: int, year_len: int=552):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=552):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_552",
    "sat": "def sat(n: int, year_len: int=553):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=553):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_553",
    "sat": "def sat(n: int, year_len: int=554):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=554):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_554",
    "sat": "def sat(n: int, year_len: int=555):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=555):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_555",
    "sat": "def sat(n: int, year_len: int=556):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=556):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_556",
    "sat": "def sat(n: int, year_len: int=557):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=557):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_557",
    "sat": "def sat(n: int, year_len: int=558):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=558):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_558",
    "sat": "def sat(n: int, year_len: int=559):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=559):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_559",
    "sat": "def sat(n: int, year_len: int=560):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=560):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_560",
    "sat": "def sat(n: int, year_len: int=561):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=561):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_561",
    "sat": "def sat(n: int, year_len: int=562):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=562):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_562",
    "sat": "def sat(n: int, year_len: int=563):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=563):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_563",
    "sat": "def sat(n: int, year_len: int=564):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=564):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_564",
    "sat": "def sat(n: int, year_len: int=565):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=565):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_565",
    "sat": "def sat(n: int, year_len: int=566):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=566):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_566",
    "sat": "def sat(n: int, year_len: int=567):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=567):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_567",
    "sat": "def sat(n: int, year_len: int=568):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=568):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_568",
    "sat": "def sat(n: int, year_len: int=569):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=569):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_569",
    "sat": "def sat(n: int, year_len: int=570):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=570):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_570",
    "sat": "def sat(n: int, year_len: int=571):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=571):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_571",
    "sat": "def sat(n: int, year_len: int=572):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=572):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_572",
    "sat": "def sat(n: int, year_len: int=573):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=573):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_573",
    "sat": "def sat(n: int, year_len: int=574):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=574):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_574",
    "sat": "def sat(n: int, year_len: int=575):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=575):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_575",
    "sat": "def sat(n: int, year_len: int=576):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=576):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_576",
    "sat": "def sat(n: int, year_len: int=577):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=577):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_577",
    "sat": "def sat(n: int, year_len: int=578):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=578):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_578",
    "sat": "def sat(n: int, year_len: int=579):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=579):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_579",
    "sat": "def sat(n: int, year_len: int=580):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=580):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_580",
    "sat": "def sat(n: int, year_len: int=581):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=581):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_581",
    "sat": "def sat(n: int, year_len: int=582):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=582):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_582",
    "sat": "def sat(n: int, year_len: int=583):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=583):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_583",
    "sat": "def sat(n: int, year_len: int=584):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=584):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_584",
    "sat": "def sat(n: int, year_len: int=585):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=585):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_585",
    "sat": "def sat(n: int, year_len: int=586):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=586):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_586",
    "sat": "def sat(n: int, year_len: int=587):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=587):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_587",
    "sat": "def sat(n: int, year_len: int=588):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=588):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_588",
    "sat": "def sat(n: int, year_len: int=589):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=589):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_589",
    "sat": "def sat(n: int, year_len: int=590):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=590):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_590",
    "sat": "def sat(n: int, year_len: int=591):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=591):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_591",
    "sat": "def sat(n: int, year_len: int=592):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=592):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_592",
    "sat": "def sat(n: int, year_len: int=593):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=593):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_593",
    "sat": "def sat(n: int, year_len: int=594):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=594):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_594",
    "sat": "def sat(n: int, year_len: int=595):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=595):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_595",
    "sat": "def sat(n: int, year_len: int=596):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=596):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_596",
    "sat": "def sat(n: int, year_len: int=597):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=597):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_597",
    "sat": "def sat(n: int, year_len: int=598):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=598):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_598",
    "sat": "def sat(n: int, year_len: int=599):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=599):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_599",
    "sat": "def sat(n: int, year_len: int=600):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=600):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_600",
    "sat": "def sat(n: int, year_len: int=601):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=601):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_601",
    "sat": "def sat(n: int, year_len: int=602):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=602):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_602",
    "sat": "def sat(n: int, year_len: int=603):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=603):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_603",
    "sat": "def sat(n: int, year_len: int=604):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=604):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_604",
    "sat": "def sat(n: int, year_len: int=605):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=605):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_605",
    "sat": "def sat(n: int, year_len: int=606):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=606):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_606",
    "sat": "def sat(n: int, year_len: int=607):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=607):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_607",
    "sat": "def sat(n: int, year_len: int=608):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=608):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_608",
    "sat": "def sat(n: int, year_len: int=609):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=609):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_609",
    "sat": "def sat(n: int, year_len: int=610):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=610):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_610",
    "sat": "def sat(n: int, year_len: int=611):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=611):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_611",
    "sat": "def sat(n: int, year_len: int=612):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=612):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_612",
    "sat": "def sat(n: int, year_len: int=613):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=613):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_613",
    "sat": "def sat(n: int, year_len: int=614):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=614):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_614",
    "sat": "def sat(n: int, year_len: int=615):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=615):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_615",
    "sat": "def sat(n: int, year_len: int=616):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=616):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_616",
    "sat": "def sat(n: int, year_len: int=617):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=617):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_617",
    "sat": "def sat(n: int, year_len: int=618):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=618):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_618",
    "sat": "def sat(n: int, year_len: int=619):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=619):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_619",
    "sat": "def sat(n: int, year_len: int=620):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=620):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_620",
    "sat": "def sat(n: int, year_len: int=621):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=621):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_621",
    "sat": "def sat(n: int, year_len: int=622):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=622):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_622",
    "sat": "def sat(n: int, year_len: int=623):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=623):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_623",
    "sat": "def sat(n: int, year_len: int=624):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=624):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_624",
    "sat": "def sat(n: int, year_len: int=625):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=625):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_625",
    "sat": "def sat(n: int, year_len: int=626):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=626):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_626",
    "sat": "def sat(n: int, year_len: int=627):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=627):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_627",
    "sat": "def sat(n: int, year_len: int=628):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=628):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_628",
    "sat": "def sat(n: int, year_len: int=629):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=629):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_629",
    "sat": "def sat(n: int, year_len: int=630):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=630):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_630",
    "sat": "def sat(n: int, year_len: int=631):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=631):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_631",
    "sat": "def sat(n: int, year_len: int=632):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=632):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_632",
    "sat": "def sat(n: int, year_len: int=633):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=633):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_633",
    "sat": "def sat(n: int, year_len: int=634):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=634):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_634",
    "sat": "def sat(n: int, year_len: int=635):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=635):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_635",
    "sat": "def sat(n: int, year_len: int=636):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=636):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_636",
    "sat": "def sat(n: int, year_len: int=637):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=637):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_637",
    "sat": "def sat(n: int, year_len: int=638):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=638):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_638",
    "sat": "def sat(n: int, year_len: int=639):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=639):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_639",
    "sat": "def sat(n: int, year_len: int=640):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=640):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_640",
    "sat": "def sat(n: int, year_len: int=641):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=641):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_641",
    "sat": "def sat(n: int, year_len: int=642):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=642):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_642",
    "sat": "def sat(n: int, year_len: int=643):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=643):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_643",
    "sat": "def sat(n: int, year_len: int=644):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=644):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_644",
    "sat": "def sat(n: int, year_len: int=645):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=645):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_645",
    "sat": "def sat(n: int, year_len: int=646):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=646):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_646",
    "sat": "def sat(n: int, year_len: int=647):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=647):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_647",
    "sat": "def sat(n: int, year_len: int=648):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=648):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_648",
    "sat": "def sat(n: int, year_len: int=649):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=649):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_649",
    "sat": "def sat(n: int, year_len: int=650):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=650):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_650",
    "sat": "def sat(n: int, year_len: int=651):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=651):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_651",
    "sat": "def sat(n: int, year_len: int=652):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=652):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_652",
    "sat": "def sat(n: int, year_len: int=653):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=653):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_653",
    "sat": "def sat(n: int, year_len: int=654):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=654):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_654",
    "sat": "def sat(n: int, year_len: int=655):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=655):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_655",
    "sat": "def sat(n: int, year_len: int=656):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=656):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_656",
    "sat": "def sat(n: int, year_len: int=657):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=657):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_657",
    "sat": "def sat(n: int, year_len: int=658):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=658):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_658",
    "sat": "def sat(n: int, year_len: int=659):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=659):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_659",
    "sat": "def sat(n: int, year_len: int=660):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=660):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_660",
    "sat": "def sat(n: int, year_len: int=661):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=661):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_661",
    "sat": "def sat(n: int, year_len: int=662):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=662):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_662",
    "sat": "def sat(n: int, year_len: int=663):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=663):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_663",
    "sat": "def sat(n: int, year_len: int=664):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=664):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_664",
    "sat": "def sat(n: int, year_len: int=665):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=665):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_665",
    "sat": "def sat(n: int, year_len: int=666):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=666):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_666",
    "sat": "def sat(n: int, year_len: int=667):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=667):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_667",
    "sat": "def sat(n: int, year_len: int=668):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=668):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_668",
    "sat": "def sat(n: int, year_len: int=669):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=669):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_669",
    "sat": "def sat(n: int, year_len: int=670):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=670):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_670",
    "sat": "def sat(n: int, year_len: int=671):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=671):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_671",
    "sat": "def sat(n: int, year_len: int=672):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=672):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_672",
    "sat": "def sat(n: int, year_len: int=673):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=673):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_673",
    "sat": "def sat(n: int, year_len: int=674):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=674):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_674",
    "sat": "def sat(n: int, year_len: int=675):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=675):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_675",
    "sat": "def sat(n: int, year_len: int=676):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=676):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_676",
    "sat": "def sat(n: int, year_len: int=677):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=677):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_677",
    "sat": "def sat(n: int, year_len: int=678):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=678):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_678",
    "sat": "def sat(n: int, year_len: int=679):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=679):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_679",
    "sat": "def sat(n: int, year_len: int=680):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=680):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_680",
    "sat": "def sat(n: int, year_len: int=681):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=681):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_681",
    "sat": "def sat(n: int, year_len: int=682):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=682):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_682",
    "sat": "def sat(n: int, year_len: int=683):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=683):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_683",
    "sat": "def sat(n: int, year_len: int=684):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=684):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_684",
    "sat": "def sat(n: int, year_len: int=685):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=685):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_685",
    "sat": "def sat(n: int, year_len: int=686):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=686):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_686",
    "sat": "def sat(n: int, year_len: int=687):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=687):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_687",
    "sat": "def sat(n: int, year_len: int=688):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=688):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_688",
    "sat": "def sat(n: int, year_len: int=689):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=689):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_689",
    "sat": "def sat(n: int, year_len: int=690):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=690):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_690",
    "sat": "def sat(n: int, year_len: int=691):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=691):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_691",
    "sat": "def sat(n: int, year_len: int=692):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=692):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_692",
    "sat": "def sat(n: int, year_len: int=693):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=693):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_693",
    "sat": "def sat(n: int, year_len: int=694):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=694):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_694",
    "sat": "def sat(n: int, year_len: int=695):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=695):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_695",
    "sat": "def sat(n: int, year_len: int=696):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=696):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_696",
    "sat": "def sat(n: int, year_len: int=697):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=697):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_697",
    "sat": "def sat(n: int, year_len: int=698):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=698):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_698",
    "sat": "def sat(n: int, year_len: int=699):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=699):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_699",
    "sat": "def sat(n: int, year_len: int=700):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=700):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_700",
    "sat": "def sat(n: int, year_len: int=701):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=701):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_701",
    "sat": "def sat(n: int, year_len: int=702):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=702):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_702",
    "sat": "def sat(n: int, year_len: int=703):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=703):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_703",
    "sat": "def sat(n: int, year_len: int=704):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=704):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_704",
    "sat": "def sat(n: int, year_len: int=705):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=705):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_705",
    "sat": "def sat(n: int, year_len: int=706):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=706):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_706",
    "sat": "def sat(n: int, year_len: int=707):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=707):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_707",
    "sat": "def sat(n: int, year_len: int=708):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=708):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_708",
    "sat": "def sat(n: int, year_len: int=709):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=709):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_709",
    "sat": "def sat(n: int, year_len: int=710):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=710):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_710",
    "sat": "def sat(n: int, year_len: int=711):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=711):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_711",
    "sat": "def sat(n: int, year_len: int=712):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=712):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_712",
    "sat": "def sat(n: int, year_len: int=713):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=713):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_713",
    "sat": "def sat(n: int, year_len: int=714):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=714):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_714",
    "sat": "def sat(n: int, year_len: int=715):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=715):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_715",
    "sat": "def sat(n: int, year_len: int=716):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=716):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_716",
    "sat": "def sat(n: int, year_len: int=717):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=717):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_717",
    "sat": "def sat(n: int, year_len: int=718):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=718):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_718",
    "sat": "def sat(n: int, year_len: int=719):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=719):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_719",
    "sat": "def sat(n: int, year_len: int=720):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=720):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_720",
    "sat": "def sat(n: int, year_len: int=721):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=721):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_721",
    "sat": "def sat(n: int, year_len: int=722):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=722):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_722",
    "sat": "def sat(n: int, year_len: int=723):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=723):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_723",
    "sat": "def sat(n: int, year_len: int=724):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=724):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_724",
    "sat": "def sat(n: int, year_len: int=725):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=725):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_725",
    "sat": "def sat(n: int, year_len: int=726):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=726):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_726",
    "sat": "def sat(n: int, year_len: int=727):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=727):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_727",
    "sat": "def sat(n: int, year_len: int=728):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=728):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_728",
    "sat": "def sat(n: int, year_len: int=729):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=729):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_729",
    "sat": "def sat(n: int, year_len: int=730):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=730):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_730",
    "sat": "def sat(n: int, year_len: int=731):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=731):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_731",
    "sat": "def sat(n: int, year_len: int=732):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=732):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_732",
    "sat": "def sat(n: int, year_len: int=733):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=733):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_733",
    "sat": "def sat(n: int, year_len: int=734):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=734):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_734",
    "sat": "def sat(n: int, year_len: int=735):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=735):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_735",
    "sat": "def sat(n: int, year_len: int=736):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=736):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_736",
    "sat": "def sat(n: int, year_len: int=737):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=737):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_737",
    "sat": "def sat(n: int, year_len: int=738):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=738):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_738",
    "sat": "def sat(n: int, year_len: int=739):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=739):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_739",
    "sat": "def sat(n: int, year_len: int=740):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=740):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_740",
    "sat": "def sat(n: int, year_len: int=741):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=741):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_741",
    "sat": "def sat(n: int, year_len: int=742):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=742):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_742",
    "sat": "def sat(n: int, year_len: int=743):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=743):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_743",
    "sat": "def sat(n: int, year_len: int=744):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=744):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_744",
    "sat": "def sat(n: int, year_len: int=745):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=745):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_745",
    "sat": "def sat(n: int, year_len: int=746):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=746):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_746",
    "sat": "def sat(n: int, year_len: int=747):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=747):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_747",
    "sat": "def sat(n: int, year_len: int=748):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=748):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_748",
    "sat": "def sat(n: int, year_len: int=749):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=749):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_749",
    "sat": "def sat(n: int, year_len: int=750):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=750):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_750",
    "sat": "def sat(n: int, year_len: int=751):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=751):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_751",
    "sat": "def sat(n: int, year_len: int=752):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=752):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_752",
    "sat": "def sat(n: int, year_len: int=753):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=753):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_753",
    "sat": "def sat(n: int, year_len: int=754):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=754):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_754",
    "sat": "def sat(n: int, year_len: int=755):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=755):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_755",
    "sat": "def sat(n: int, year_len: int=756):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=756):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_756",
    "sat": "def sat(n: int, year_len: int=757):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=757):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_757",
    "sat": "def sat(n: int, year_len: int=758):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=758):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_758",
    "sat": "def sat(n: int, year_len: int=759):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=759):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_759",
    "sat": "def sat(n: int, year_len: int=760):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=760):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_760",
    "sat": "def sat(n: int, year_len: int=761):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=761):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_761",
    "sat": "def sat(n: int, year_len: int=762):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=762):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_762",
    "sat": "def sat(n: int, year_len: int=763):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=763):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_763",
    "sat": "def sat(n: int, year_len: int=764):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=764):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_764",
    "sat": "def sat(n: int, year_len: int=765):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=765):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_765",
    "sat": "def sat(n: int, year_len: int=766):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=766):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_766",
    "sat": "def sat(n: int, year_len: int=767):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=767):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_767",
    "sat": "def sat(n: int, year_len: int=768):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=768):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_768",
    "sat": "def sat(n: int, year_len: int=769):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=769):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_769",
    "sat": "def sat(n: int, year_len: int=770):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=770):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_770",
    "sat": "def sat(n: int, year_len: int=771):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=771):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_771",
    "sat": "def sat(n: int, year_len: int=772):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=772):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_772",
    "sat": "def sat(n: int, year_len: int=773):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=773):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_773",
    "sat": "def sat(n: int, year_len: int=774):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=774):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_774",
    "sat": "def sat(n: int, year_len: int=775):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=775):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_775",
    "sat": "def sat(n: int, year_len: int=776):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=776):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_776",
    "sat": "def sat(n: int, year_len: int=777):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=777):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_777",
    "sat": "def sat(n: int, year_len: int=778):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=778):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_778",
    "sat": "def sat(n: int, year_len: int=779):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=779):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_779",
    "sat": "def sat(n: int, year_len: int=780):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=780):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_780",
    "sat": "def sat(n: int, year_len: int=781):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=781):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_781",
    "sat": "def sat(n: int, year_len: int=782):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=782):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_782",
    "sat": "def sat(n: int, year_len: int=783):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=783):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_783",
    "sat": "def sat(n: int, year_len: int=784):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=784):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_784",
    "sat": "def sat(n: int, year_len: int=785):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=785):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_785",
    "sat": "def sat(n: int, year_len: int=786):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=786):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_786",
    "sat": "def sat(n: int, year_len: int=787):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=787):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_787",
    "sat": "def sat(n: int, year_len: int=788):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=788):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_788",
    "sat": "def sat(n: int, year_len: int=789):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=789):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_789",
    "sat": "def sat(n: int, year_len: int=790):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=790):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_790",
    "sat": "def sat(n: int, year_len: int=791):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=791):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_791",
    "sat": "def sat(n: int, year_len: int=792):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=792):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_792",
    "sat": "def sat(n: int, year_len: int=793):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=793):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_793",
    "sat": "def sat(n: int, year_len: int=794):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=794):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_794",
    "sat": "def sat(n: int, year_len: int=795):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=795):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_795",
    "sat": "def sat(n: int, year_len: int=796):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=796):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_796",
    "sat": "def sat(n: int, year_len: int=797):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=797):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_797",
    "sat": "def sat(n: int, year_len: int=798):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=798):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_798",
    "sat": "def sat(n: int, year_len: int=799):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=799):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_799",
    "sat": "def sat(n: int, year_len: int=800):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=800):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_800",
    "sat": "def sat(n: int, year_len: int=801):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=801):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_801",
    "sat": "def sat(n: int, year_len: int=802):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=802):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_802",
    "sat": "def sat(n: int, year_len: int=803):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=803):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_803",
    "sat": "def sat(n: int, year_len: int=804):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=804):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_804",
    "sat": "def sat(n: int, year_len: int=805):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=805):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_805",
    "sat": "def sat(n: int, year_len: int=806):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=806):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_806",
    "sat": "def sat(n: int, year_len: int=807):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=807):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_807",
    "sat": "def sat(n: int, year_len: int=808):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=808):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_808",
    "sat": "def sat(n: int, year_len: int=809):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=809):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_809",
    "sat": "def sat(n: int, year_len: int=810):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=810):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_810",
    "sat": "def sat(n: int, year_len: int=811):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=811):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_811",
    "sat": "def sat(n: int, year_len: int=812):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=812):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_812",
    "sat": "def sat(n: int, year_len: int=813):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=813):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_813",
    "sat": "def sat(n: int, year_len: int=814):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=814):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_814",
    "sat": "def sat(n: int, year_len: int=815):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=815):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_815",
    "sat": "def sat(n: int, year_len: int=816):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=816):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_816",
    "sat": "def sat(n: int, year_len: int=817):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=817):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_817",
    "sat": "def sat(n: int, year_len: int=818):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=818):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_818",
    "sat": "def sat(n: int, year_len: int=819):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=819):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_819",
    "sat": "def sat(n: int, year_len: int=820):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=820):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_820",
    "sat": "def sat(n: int, year_len: int=821):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=821):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_821",
    "sat": "def sat(n: int, year_len: int=822):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=822):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_822",
    "sat": "def sat(n: int, year_len: int=823):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=823):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_823",
    "sat": "def sat(n: int, year_len: int=824):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=824):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_824",
    "sat": "def sat(n: int, year_len: int=825):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=825):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_825",
    "sat": "def sat(n: int, year_len: int=826):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=826):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_826",
    "sat": "def sat(n: int, year_len: int=827):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=827):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_827",
    "sat": "def sat(n: int, year_len: int=828):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=828):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_828",
    "sat": "def sat(n: int, year_len: int=829):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=829):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_829",
    "sat": "def sat(n: int, year_len: int=830):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=830):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_830",
    "sat": "def sat(n: int, year_len: int=831):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=831):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_831",
    "sat": "def sat(n: int, year_len: int=832):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=832):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_832",
    "sat": "def sat(n: int, year_len: int=833):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=833):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_833",
    "sat": "def sat(n: int, year_len: int=834):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=834):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_834",
    "sat": "def sat(n: int, year_len: int=835):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=835):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_835",
    "sat": "def sat(n: int, year_len: int=836):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=836):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_836",
    "sat": "def sat(n: int, year_len: int=837):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=837):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_837",
    "sat": "def sat(n: int, year_len: int=838):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=838):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_838",
    "sat": "def sat(n: int, year_len: int=839):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=839):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_839",
    "sat": "def sat(n: int, year_len: int=840):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=840):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_840",
    "sat": "def sat(n: int, year_len: int=841):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=841):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_841",
    "sat": "def sat(n: int, year_len: int=842):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=842):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_842",
    "sat": "def sat(n: int, year_len: int=843):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=843):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_843",
    "sat": "def sat(n: int, year_len: int=844):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=844):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_844",
    "sat": "def sat(n: int, year_len: int=845):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=845):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_845",
    "sat": "def sat(n: int, year_len: int=846):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=846):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_846",
    "sat": "def sat(n: int, year_len: int=847):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=847):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_847",
    "sat": "def sat(n: int, year_len: int=848):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=848):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_848",
    "sat": "def sat(n: int, year_len: int=849):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=849):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_849",
    "sat": "def sat(n: int, year_len: int=850):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=850):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_850",
    "sat": "def sat(n: int, year_len: int=851):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=851):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_851",
    "sat": "def sat(n: int, year_len: int=852):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=852):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_852",
    "sat": "def sat(n: int, year_len: int=853):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=853):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_853",
    "sat": "def sat(n: int, year_len: int=854):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=854):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_854",
    "sat": "def sat(n: int, year_len: int=855):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=855):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_855",
    "sat": "def sat(n: int, year_len: int=856):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=856):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_856",
    "sat": "def sat(n: int, year_len: int=857):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=857):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_857",
    "sat": "def sat(n: int, year_len: int=858):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=858):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_858",
    "sat": "def sat(n: int, year_len: int=859):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=859):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_859",
    "sat": "def sat(n: int, year_len: int=860):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=860):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_860",
    "sat": "def sat(n: int, year_len: int=861):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=861):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_861",
    "sat": "def sat(n: int, year_len: int=862):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=862):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_862",
    "sat": "def sat(n: int, year_len: int=863):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=863):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_863",
    "sat": "def sat(n: int, year_len: int=864):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=864):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_864",
    "sat": "def sat(n: int, year_len: int=865):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=865):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_865",
    "sat": "def sat(n: int, year_len: int=866):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=866):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_866",
    "sat": "def sat(n: int, year_len: int=867):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=867):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_867",
    "sat": "def sat(n: int, year_len: int=868):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=868):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_868",
    "sat": "def sat(n: int, year_len: int=869):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=869):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_869",
    "sat": "def sat(n: int, year_len: int=870):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=870):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_870",
    "sat": "def sat(n: int, year_len: int=871):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=871):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_871",
    "sat": "def sat(n: int, year_len: int=872):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=872):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_872",
    "sat": "def sat(n: int, year_len: int=873):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=873):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_873",
    "sat": "def sat(n: int, year_len: int=874):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=874):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_874",
    "sat": "def sat(n: int, year_len: int=875):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=875):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_875",
    "sat": "def sat(n: int, year_len: int=876):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=876):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_876",
    "sat": "def sat(n: int, year_len: int=877):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=877):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_877",
    "sat": "def sat(n: int, year_len: int=878):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=878):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_878",
    "sat": "def sat(n: int, year_len: int=879):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=879):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_879",
    "sat": "def sat(n: int, year_len: int=880):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=880):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_880",
    "sat": "def sat(n: int, year_len: int=881):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=881):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_881",
    "sat": "def sat(n: int, year_len: int=882):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=882):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_882",
    "sat": "def sat(n: int, year_len: int=883):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=883):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_883",
    "sat": "def sat(n: int, year_len: int=884):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=884):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_884",
    "sat": "def sat(n: int, year_len: int=885):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=885):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_885",
    "sat": "def sat(n: int, year_len: int=886):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=886):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_886",
    "sat": "def sat(n: int, year_len: int=887):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=887):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_887",
    "sat": "def sat(n: int, year_len: int=888):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=888):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_888",
    "sat": "def sat(n: int, year_len: int=889):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=889):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_889",
    "sat": "def sat(n: int, year_len: int=890):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=890):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_890",
    "sat": "def sat(n: int, year_len: int=891):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=891):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_891",
    "sat": "def sat(n: int, year_len: int=892):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=892):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_892",
    "sat": "def sat(n: int, year_len: int=893):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=893):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_893",
    "sat": "def sat(n: int, year_len: int=894):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=894):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_894",
    "sat": "def sat(n: int, year_len: int=895):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=895):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_895",
    "sat": "def sat(n: int, year_len: int=896):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=896):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_896",
    "sat": "def sat(n: int, year_len: int=897):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=897):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_897",
    "sat": "def sat(n: int, year_len: int=898):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=898):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_898",
    "sat": "def sat(n: int, year_len: int=899):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=899):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_899",
    "sat": "def sat(n: int, year_len: int=900):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=900):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_900",
    "sat": "def sat(n: int, year_len: int=901):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=901):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_901",
    "sat": "def sat(n: int, year_len: int=902):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=902):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_902",
    "sat": "def sat(n: int, year_len: int=903):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=903):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_903",
    "sat": "def sat(n: int, year_len: int=904):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=904):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_904",
    "sat": "def sat(n: int, year_len: int=905):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=905):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_905",
    "sat": "def sat(n: int, year_len: int=906):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=906):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_906",
    "sat": "def sat(n: int, year_len: int=907):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=907):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_907",
    "sat": "def sat(n: int, year_len: int=908):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=908):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_908",
    "sat": "def sat(n: int, year_len: int=909):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=909):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_909",
    "sat": "def sat(n: int, year_len: int=910):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=910):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_910",
    "sat": "def sat(n: int, year_len: int=911):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=911):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_911",
    "sat": "def sat(n: int, year_len: int=912):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=912):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_912",
    "sat": "def sat(n: int, year_len: int=913):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=913):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_913",
    "sat": "def sat(n: int, year_len: int=914):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=914):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_914",
    "sat": "def sat(n: int, year_len: int=915):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=915):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_915",
    "sat": "def sat(n: int, year_len: int=916):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=916):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_916",
    "sat": "def sat(n: int, year_len: int=917):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=917):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_917",
    "sat": "def sat(n: int, year_len: int=918):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=918):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_918",
    "sat": "def sat(n: int, year_len: int=919):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=919):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_919",
    "sat": "def sat(n: int, year_len: int=920):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=920):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_920",
    "sat": "def sat(n: int, year_len: int=921):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=921):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_921",
    "sat": "def sat(n: int, year_len: int=922):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=922):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_922",
    "sat": "def sat(n: int, year_len: int=923):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=923):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_923",
    "sat": "def sat(n: int, year_len: int=924):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=924):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_924",
    "sat": "def sat(n: int, year_len: int=925):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=925):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_925",
    "sat": "def sat(n: int, year_len: int=926):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=926):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_926",
    "sat": "def sat(n: int, year_len: int=927):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=927):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_927",
    "sat": "def sat(n: int, year_len: int=928):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=928):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_928",
    "sat": "def sat(n: int, year_len: int=929):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=929):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_929",
    "sat": "def sat(n: int, year_len: int=930):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=930):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_930",
    "sat": "def sat(n: int, year_len: int=931):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=931):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_931",
    "sat": "def sat(n: int, year_len: int=932):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=932):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_932",
    "sat": "def sat(n: int, year_len: int=933):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=933):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_933",
    "sat": "def sat(n: int, year_len: int=934):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=934):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_934",
    "sat": "def sat(n: int, year_len: int=935):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=935):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_935",
    "sat": "def sat(n: int, year_len: int=936):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=936):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_936",
    "sat": "def sat(n: int, year_len: int=937):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=937):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_937",
    "sat": "def sat(n: int, year_len: int=938):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=938):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_938",
    "sat": "def sat(n: int, year_len: int=939):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=939):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_939",
    "sat": "def sat(n: int, year_len: int=940):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=940):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_940",
    "sat": "def sat(n: int, year_len: int=941):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=941):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_941",
    "sat": "def sat(n: int, year_len: int=942):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=942):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_942",
    "sat": "def sat(n: int, year_len: int=943):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=943):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_943",
    "sat": "def sat(n: int, year_len: int=944):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=944):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_944",
    "sat": "def sat(n: int, year_len: int=945):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=945):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_945",
    "sat": "def sat(n: int, year_len: int=946):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=946):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_946",
    "sat": "def sat(n: int, year_len: int=947):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=947):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_947",
    "sat": "def sat(n: int, year_len: int=948):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=948):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_948",
    "sat": "def sat(n: int, year_len: int=949):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=949):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_949",
    "sat": "def sat(n: int, year_len: int=950):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=950):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_950",
    "sat": "def sat(n: int, year_len: int=951):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=951):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_951",
    "sat": "def sat(n: int, year_len: int=952):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=952):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_952",
    "sat": "def sat(n: int, year_len: int=953):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=953):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_953",
    "sat": "def sat(n: int, year_len: int=954):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=954):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_954",
    "sat": "def sat(n: int, year_len: int=955):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=955):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_955",
    "sat": "def sat(n: int, year_len: int=956):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=956):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_956",
    "sat": "def sat(n: int, year_len: int=957):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=957):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_957",
    "sat": "def sat(n: int, year_len: int=958):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=958):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_958",
    "sat": "def sat(n: int, year_len: int=959):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=959):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_959",
    "sat": "def sat(n: int, year_len: int=960):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=960):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_960",
    "sat": "def sat(n: int, year_len: int=961):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=961):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_961",
    "sat": "def sat(n: int, year_len: int=962):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=962):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_962",
    "sat": "def sat(n: int, year_len: int=963):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=963):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_963",
    "sat": "def sat(n: int, year_len: int=964):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=964):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_964",
    "sat": "def sat(n: int, year_len: int=965):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=965):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_965",
    "sat": "def sat(n: int, year_len: int=966):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=966):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_966",
    "sat": "def sat(n: int, year_len: int=967):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=967):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_967",
    "sat": "def sat(n: int, year_len: int=968):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=968):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_968",
    "sat": "def sat(n: int, year_len: int=969):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=969):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_969",
    "sat": "def sat(n: int, year_len: int=970):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=970):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_970",
    "sat": "def sat(n: int, year_len: int=971):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=971):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_971",
    "sat": "def sat(n: int, year_len: int=972):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=972):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_972",
    "sat": "def sat(n: int, year_len: int=973):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=973):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_973",
    "sat": "def sat(n: int, year_len: int=974):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=974):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_974",
    "sat": "def sat(n: int, year_len: int=975):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=975):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_975",
    "sat": "def sat(n: int, year_len: int=976):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=976):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_976",
    "sat": "def sat(n: int, year_len: int=977):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=977):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_977",
    "sat": "def sat(n: int, year_len: int=978):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=978):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_978",
    "sat": "def sat(n: int, year_len: int=979):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=979):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_979",
    "sat": "def sat(n: int, year_len: int=980):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=980):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_980",
    "sat": "def sat(n: int, year_len: int=981):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=981):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_981",
    "sat": "def sat(n: int, year_len: int=982):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=982):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_982",
    "sat": "def sat(n: int, year_len: int=983):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=983):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_983",
    "sat": "def sat(n: int, year_len: int=984):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=984):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_984",
    "sat": "def sat(n: int, year_len: int=985):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=985):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_985",
    "sat": "def sat(n: int, year_len: int=986):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=986):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_986",
    "sat": "def sat(n: int, year_len: int=987):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=987):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_987",
    "sat": "def sat(n: int, year_len: int=988):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=988):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_988",
    "sat": "def sat(n: int, year_len: int=989):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=989):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_989",
    "sat": "def sat(n: int, year_len: int=990):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=990):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_990",
    "sat": "def sat(n: int, year_len: int=991):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=991):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_991",
    "sat": "def sat(n: int, year_len: int=992):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=992):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_992",
    "sat": "def sat(n: int, year_len: int=993):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=993):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_993",
    "sat": "def sat(n: int, year_len: int=994):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=994):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_994",
    "sat": "def sat(n: int, year_len: int=995):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=995):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_995",
    "sat": "def sat(n: int, year_len: int=996):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=996):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_996",
    "sat": "def sat(n: int, year_len: int=997):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=997):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_997",
    "sat": "def sat(n: int, year_len: int=998):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=998):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_998",
    "sat": "def sat(n: int, year_len: int=999):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=999):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_999",
    "sat": "def sat(n: int, year_len: int=1000):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=1000):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BallotProblem_0",
    "sat": "def sat(counts: List[int], target_prob: float=0.5):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_1",
    "sat": "def sat(counts: List[int], target_prob: float=0.6666666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6666666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_2",
    "sat": "def sat(counts: List[int], target_prob: float=0.3333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_3",
    "sat": "def sat(counts: List[int], target_prob: float=0.5363636363636364):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5363636363636364):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_4",
    "sat": "def sat(counts: List[int], target_prob: float=0.5238095238095238):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5238095238095238):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_5",
    "sat": "def sat(counts: List[int], target_prob: float=0.08695652173913043):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08695652173913043):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_6",
    "sat": "def sat(counts: List[int], target_prob: float=0.26857142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26857142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_7",
    "sat": "def sat(counts: List[int], target_prob: float=0.42528735632183906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42528735632183906):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_8",
    "sat": "def sat(counts: List[int], target_prob: float=0.1111111111111111):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1111111111111111):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_9",
    "sat": "def sat(counts: List[int], target_prob: float=0.1067193675889328):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1067193675889328):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_10",
    "sat": "def sat(counts: List[int], target_prob: float=0.9437751004016064):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9437751004016064):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_11",
    "sat": "def sat(counts: List[int], target_prob: float=0.2804232804232804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2804232804232804):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_12",
    "sat": "def sat(counts: List[int], target_prob: float=0.3953488372093023):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3953488372093023):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_13",
    "sat": "def sat(counts: List[int], target_prob: float=0.09090909090909091):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09090909090909091):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_14",
    "sat": "def sat(counts: List[int], target_prob: float=0.6706507304116865):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6706507304116865):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_15",
    "sat": "def sat(counts: List[int], target_prob: float=0.9428571428571428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9428571428571428):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_16",
    "sat": "def sat(counts: List[int], target_prob: float=0.5853658536585366):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5853658536585366):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_17",
    "sat": "def sat(counts: List[int], target_prob: float=0.021897810218978103):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.021897810218978103):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_18",
    "sat": "def sat(counts: List[int], target_prob: float=0.047872340425531915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.047872340425531915):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_19",
    "sat": "def sat(counts: List[int], target_prob: float=0.8472222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8472222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_20",
    "sat": "def sat(counts: List[int], target_prob: float=0.31645569620253167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31645569620253167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_21",
    "sat": "def sat(counts: List[int], target_prob: float=0.22167487684729065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22167487684729065):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_22",
    "sat": "def sat(counts: List[int], target_prob: float=0.167420814479638):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.167420814479638):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_23",
    "sat": "def sat(counts: List[int], target_prob: float=0.46875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_24",
    "sat": "def sat(counts: List[int], target_prob: float=0.4494283201407212):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4494283201407212):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_25",
    "sat": "def sat(counts: List[int], target_prob: float=0.16167664670658682):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16167664670658682):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_26",
    "sat": "def sat(counts: List[int], target_prob: float=0.19851576994434136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19851576994434136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_27",
    "sat": "def sat(counts: List[int], target_prob: float=0.47058823529411764):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47058823529411764):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_28",
    "sat": "def sat(counts: List[int], target_prob: float=0.1566265060240964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1566265060240964):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_29",
    "sat": "def sat(counts: List[int], target_prob: float=0.6215277777777778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6215277777777778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_30",
    "sat": "def sat(counts: List[int], target_prob: float=0.0702054794520548):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0702054794520548):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_31",
    "sat": "def sat(counts: List[int], target_prob: float=0.125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_32",
    "sat": "def sat(counts: List[int], target_prob: float=0.03488372093023256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03488372093023256):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_33",
    "sat": "def sat(counts: List[int], target_prob: float=0.07317073170731707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07317073170731707):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_34",
    "sat": "def sat(counts: List[int], target_prob: float=0.013513513513513514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.013513513513513514):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_35",
    "sat": "def sat(counts: List[int], target_prob: float=0.0):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_36",
    "sat": "def sat(counts: List[int], target_prob: float=0.2132701421800948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2132701421800948):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_37",
    "sat": "def sat(counts: List[int], target_prob: float=0.34309623430962344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34309623430962344):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_38",
    "sat": "def sat(counts: List[int], target_prob: float=0.4294117647058823):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4294117647058823):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_39",
    "sat": "def sat(counts: List[int], target_prob: float=0.4461538461538462):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4461538461538462):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_40",
    "sat": "def sat(counts: List[int], target_prob: float=0.2903225806451613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2903225806451613):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_41",
    "sat": "def sat(counts: List[int], target_prob: float=0.0387243735763098):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0387243735763098):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_42",
    "sat": "def sat(counts: List[int], target_prob: float=0.710455764075067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.710455764075067):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_43",
    "sat": "def sat(counts: List[int], target_prob: float=0.23809523809523808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23809523809523808):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_44",
    "sat": "def sat(counts: List[int], target_prob: float=0.004969630038652678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.004969630038652678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_45",
    "sat": "def sat(counts: List[int], target_prob: float=0.7419354838709677):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7419354838709677):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_46",
    "sat": "def sat(counts: List[int], target_prob: float=0.12359550561797752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12359550561797752):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_47",
    "sat": "def sat(counts: List[int], target_prob: float=0.5255813953488372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5255813953488372):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_48",
    "sat": "def sat(counts: List[int], target_prob: float=0.4728682170542636):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4728682170542636):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_49",
    "sat": "def sat(counts: List[int], target_prob: float=0.28):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_50",
    "sat": "def sat(counts: List[int], target_prob: float=0.8260869565217391):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8260869565217391):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_51",
    "sat": "def sat(counts: List[int], target_prob: float=0.323943661971831):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.323943661971831):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_52",
    "sat": "def sat(counts: List[int], target_prob: float=0.5466666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5466666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_53",
    "sat": "def sat(counts: List[int], target_prob: float=0.07692307692307693):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07692307692307693):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_54",
    "sat": "def sat(counts: List[int], target_prob: float=0.054365733113673806):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.054365733113673806):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_55",
    "sat": "def sat(counts: List[int], target_prob: float=0.45806451612903226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45806451612903226):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_56",
    "sat": "def sat(counts: List[int], target_prob: float=0.06569343065693431):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06569343065693431):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_57",
    "sat": "def sat(counts: List[int], target_prob: float=0.06748466257668712):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06748466257668712):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_58",
    "sat": "def sat(counts: List[int], target_prob: float=0.10119047619047619):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10119047619047619):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_59",
    "sat": "def sat(counts: List[int], target_prob: float=0.2):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_60",
    "sat": "def sat(counts: List[int], target_prob: float=0.013157894736842105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.013157894736842105):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_61",
    "sat": "def sat(counts: List[int], target_prob: float=0.22580645161290322):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22580645161290322):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_62",
    "sat": "def sat(counts: List[int], target_prob: float=0.3103448275862069):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3103448275862069):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_63",
    "sat": "def sat(counts: List[int], target_prob: float=0.8597194388777555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8597194388777555):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_64",
    "sat": "def sat(counts: List[int], target_prob: float=0.6818181818181818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6818181818181818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_65",
    "sat": "def sat(counts: List[int], target_prob: float=0.37142857142857144):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37142857142857144):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_66",
    "sat": "def sat(counts: List[int], target_prob: float=0.12871287128712872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12871287128712872):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_67",
    "sat": "def sat(counts: List[int], target_prob: float=0.8509316770186336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8509316770186336):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_68",
    "sat": "def sat(counts: List[int], target_prob: float=0.44313725490196076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44313725490196076):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_69",
    "sat": "def sat(counts: List[int], target_prob: float=0.40161290322580645):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40161290322580645):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_70",
    "sat": "def sat(counts: List[int], target_prob: float=0.21739130434782608):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21739130434782608):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_71",
    "sat": "def sat(counts: List[int], target_prob: float=0.479020979020979):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.479020979020979):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_72",
    "sat": "def sat(counts: List[int], target_prob: float=0.6153846153846154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6153846153846154):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_73",
    "sat": "def sat(counts: List[int], target_prob: float=0.889763779527559):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.889763779527559):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_74",
    "sat": "def sat(counts: List[int], target_prob: float=0.03125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_75",
    "sat": "def sat(counts: List[int], target_prob: float=0.2222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_76",
    "sat": "def sat(counts: List[int], target_prob: float=0.564625850340136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.564625850340136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_77",
    "sat": "def sat(counts: List[int], target_prob: float=0.48358862144420134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48358862144420134):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_78",
    "sat": "def sat(counts: List[int], target_prob: float=0.43209876543209874):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43209876543209874):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_79",
    "sat": "def sat(counts: List[int], target_prob: float=0.7758620689655172):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7758620689655172):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_80",
    "sat": "def sat(counts: List[int], target_prob: float=0.6170212765957447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6170212765957447):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_81",
    "sat": "def sat(counts: List[int], target_prob: float=0.7037686240140227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7037686240140227):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_82",
    "sat": "def sat(counts: List[int], target_prob: float=0.102880658436214):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.102880658436214):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_83",
    "sat": "def sat(counts: List[int], target_prob: float=0.5010141987829615):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5010141987829615):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_84",
    "sat": "def sat(counts: List[int], target_prob: float=0.4426229508196721):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4426229508196721):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_85",
    "sat": "def sat(counts: List[int], target_prob: float=0.9295774647887324):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9295774647887324):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_86",
    "sat": "def sat(counts: List[int], target_prob: float=0.39947780678851175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39947780678851175):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_87",
    "sat": "def sat(counts: List[int], target_prob: float=0.4962292609351433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4962292609351433):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_88",
    "sat": "def sat(counts: List[int], target_prob: float=0.4790697674418605):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4790697674418605):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_89",
    "sat": "def sat(counts: List[int], target_prob: float=0.6470588235294118):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6470588235294118):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_90",
    "sat": "def sat(counts: List[int], target_prob: float=0.18052738336713997):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18052738336713997):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_91",
    "sat": "def sat(counts: List[int], target_prob: float=0.802547770700637):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.802547770700637):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_92",
    "sat": "def sat(counts: List[int], target_prob: float=0.32413793103448274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32413793103448274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_93",
    "sat": "def sat(counts: List[int], target_prob: float=0.5523465703971119):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5523465703971119):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_94",
    "sat": "def sat(counts: List[int], target_prob: float=0.10638297872340426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10638297872340426):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_95",
    "sat": "def sat(counts: List[int], target_prob: float=0.44144144144144143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44144144144144143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_96",
    "sat": "def sat(counts: List[int], target_prob: float=0.7869249394673123):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7869249394673123):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_97",
    "sat": "def sat(counts: List[int], target_prob: float=0.6):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_98",
    "sat": "def sat(counts: List[int], target_prob: float=0.028037383177570093):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.028037383177570093):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_99",
    "sat": "def sat(counts: List[int], target_prob: float=0.5403726708074534):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5403726708074534):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_100",
    "sat": "def sat(counts: List[int], target_prob: float=0.46078431372549017):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46078431372549017):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_101",
    "sat": "def sat(counts: List[int], target_prob: float=0.22033898305084745):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22033898305084745):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_102",
    "sat": "def sat(counts: List[int], target_prob: float=0.665903890160183):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.665903890160183):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_103",
    "sat": "def sat(counts: List[int], target_prob: float=0.012048192771084338):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012048192771084338):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_104",
    "sat": "def sat(counts: List[int], target_prob: float=0.13458262350936967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13458262350936967):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_105",
    "sat": "def sat(counts: List[int], target_prob: float=0.7611940298507462):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7611940298507462):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_106",
    "sat": "def sat(counts: List[int], target_prob: float=0.6703296703296703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6703296703296703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_107",
    "sat": "def sat(counts: List[int], target_prob: float=0.9004149377593361):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9004149377593361):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_108",
    "sat": "def sat(counts: List[int], target_prob: float=0.8382352941176471):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8382352941176471):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_109",
    "sat": "def sat(counts: List[int], target_prob: float=0.4114441416893733):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4114441416893733):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_110",
    "sat": "def sat(counts: List[int], target_prob: float=0.06765523632993513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06765523632993513):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_111",
    "sat": "def sat(counts: List[int], target_prob: float=0.9563318777292577):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9563318777292577):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_112",
    "sat": "def sat(counts: List[int], target_prob: float=0.14285714285714285):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14285714285714285):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_113",
    "sat": "def sat(counts: List[int], target_prob: float=0.42574257425742573):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42574257425742573):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_114",
    "sat": "def sat(counts: List[int], target_prob: float=0.15862068965517243):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15862068965517243):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_115",
    "sat": "def sat(counts: List[int], target_prob: float=0.25):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_116",
    "sat": "def sat(counts: List[int], target_prob: float=0.24355300859598855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24355300859598855):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_117",
    "sat": "def sat(counts: List[int], target_prob: float=0.9748427672955975):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9748427672955975):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_118",
    "sat": "def sat(counts: List[int], target_prob: float=0.782608695652174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.782608695652174):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_119",
    "sat": "def sat(counts: List[int], target_prob: float=0.09333333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09333333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_120",
    "sat": "def sat(counts: List[int], target_prob: float=0.04918032786885246):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04918032786885246):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_121",
    "sat": "def sat(counts: List[int], target_prob: float=0.1568627450980392):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1568627450980392):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_122",
    "sat": "def sat(counts: List[int], target_prob: float=0.4827586206896552):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4827586206896552):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_123",
    "sat": "def sat(counts: List[int], target_prob: float=0.24727838258164853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24727838258164853):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_124",
    "sat": "def sat(counts: List[int], target_prob: float=0.5662650602409639):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5662650602409639):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_125",
    "sat": "def sat(counts: List[int], target_prob: float=0.7735849056603774):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7735849056603774):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_126",
    "sat": "def sat(counts: List[int], target_prob: float=0.8941798941798942):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8941798941798942):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_127",
    "sat": "def sat(counts: List[int], target_prob: float=0.5543175487465181):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5543175487465181):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_128",
    "sat": "def sat(counts: List[int], target_prob: float=0.4192377495462795):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4192377495462795):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_129",
    "sat": "def sat(counts: List[int], target_prob: float=0.02824858757062147):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02824858757062147):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_130",
    "sat": "def sat(counts: List[int], target_prob: float=0.09316770186335403):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09316770186335403):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_131",
    "sat": "def sat(counts: List[int], target_prob: float=0.1927512355848435):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1927512355848435):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_132",
    "sat": "def sat(counts: List[int], target_prob: float=0.8955613577023499):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8955613577023499):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_133",
    "sat": "def sat(counts: List[int], target_prob: float=0.958041958041958):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.958041958041958):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_134",
    "sat": "def sat(counts: List[int], target_prob: float=0.19402985074626866):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19402985074626866):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_135",
    "sat": "def sat(counts: List[int], target_prob: float=0.1282051282051282):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1282051282051282):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_136",
    "sat": "def sat(counts: List[int], target_prob: float=0.8571428571428571):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8571428571428571):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_137",
    "sat": "def sat(counts: List[int], target_prob: float=0.24123711340206186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24123711340206186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_138",
    "sat": "def sat(counts: List[int], target_prob: float=0.5267175572519084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5267175572519084):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_139",
    "sat": "def sat(counts: List[int], target_prob: float=0.18043844856661045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18043844856661045):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_140",
    "sat": "def sat(counts: List[int], target_prob: float=0.29411764705882354):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29411764705882354):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_141",
    "sat": "def sat(counts: List[int], target_prob: float=0.24752475247524752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24752475247524752):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_142",
    "sat": "def sat(counts: List[int], target_prob: float=0.7741046831955923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7741046831955923):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_143",
    "sat": "def sat(counts: List[int], target_prob: float=0.16666666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16666666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_144",
    "sat": "def sat(counts: List[int], target_prob: float=0.4585152838427948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4585152838427948):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_145",
    "sat": "def sat(counts: List[int], target_prob: float=0.49074074074074076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49074074074074076):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_146",
    "sat": "def sat(counts: List[int], target_prob: float=0.7479674796747967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7479674796747967):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_147",
    "sat": "def sat(counts: List[int], target_prob: float=0.8461538461538461):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8461538461538461):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_148",
    "sat": "def sat(counts: List[int], target_prob: float=0.6811594202898551):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6811594202898551):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_149",
    "sat": "def sat(counts: List[int], target_prob: float=0.4117647058823529):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4117647058823529):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_150",
    "sat": "def sat(counts: List[int], target_prob: float=0.449438202247191):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.449438202247191):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_151",
    "sat": "def sat(counts: List[int], target_prob: float=0.9):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_152",
    "sat": "def sat(counts: List[int], target_prob: float=0.08411214953271028):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08411214953271028):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_153",
    "sat": "def sat(counts: List[int], target_prob: float=0.7142857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_154",
    "sat": "def sat(counts: List[int], target_prob: float=0.8709677419354839):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8709677419354839):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_155",
    "sat": "def sat(counts: List[int], target_prob: float=0.5042735042735043):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5042735042735043):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_156",
    "sat": "def sat(counts: List[int], target_prob: float=0.4434782608695652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4434782608695652):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_157",
    "sat": "def sat(counts: List[int], target_prob: float=0.7931034482758621):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7931034482758621):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_158",
    "sat": "def sat(counts: List[int], target_prob: float=0.13149847094801223):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13149847094801223):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_159",
    "sat": "def sat(counts: List[int], target_prob: float=0.3654618473895582):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3654618473895582):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_160",
    "sat": "def sat(counts: List[int], target_prob: float=0.4423076923076923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4423076923076923):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_161",
    "sat": "def sat(counts: List[int], target_prob: float=0.5569620253164557):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5569620253164557):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_162",
    "sat": "def sat(counts: List[int], target_prob: float=0.7866666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7866666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_163",
    "sat": "def sat(counts: List[int], target_prob: float=0.23076923076923078):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23076923076923078):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_164",
    "sat": "def sat(counts: List[int], target_prob: float=0.4838709677419355):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4838709677419355):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_165",
    "sat": "def sat(counts: List[int], target_prob: float=0.2391304347826087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2391304347826087):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_166",
    "sat": "def sat(counts: List[int], target_prob: float=0.6657115568290354):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6657115568290354):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_167",
    "sat": "def sat(counts: List[int], target_prob: float=0.6363636363636364):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6363636363636364):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_168",
    "sat": "def sat(counts: List[int], target_prob: float=0.44711538461538464):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44711538461538464):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_169",
    "sat": "def sat(counts: List[int], target_prob: float=0.5205811138014528):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5205811138014528):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_170",
    "sat": "def sat(counts: List[int], target_prob: float=0.5959595959595959):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5959595959595959):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_171",
    "sat": "def sat(counts: List[int], target_prob: float=0.05539358600583091):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05539358600583091):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_172",
    "sat": "def sat(counts: List[int], target_prob: float=0.2653061224489796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2653061224489796):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_173",
    "sat": "def sat(counts: List[int], target_prob: float=0.5845697329376854):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5845697329376854):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_174",
    "sat": "def sat(counts: List[int], target_prob: float=0.3076923076923077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3076923076923077):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_175",
    "sat": "def sat(counts: List[int], target_prob: float=0.7263157894736842):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7263157894736842):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_176",
    "sat": "def sat(counts: List[int], target_prob: float=0.16853932584269662):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16853932584269662):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_177",
    "sat": "def sat(counts: List[int], target_prob: float=0.15625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_178",
    "sat": "def sat(counts: List[int], target_prob: float=0.5913978494623656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5913978494623656):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_179",
    "sat": "def sat(counts: List[int], target_prob: float=0.47368421052631576):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47368421052631576):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_180",
    "sat": "def sat(counts: List[int], target_prob: float=0.5789473684210527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5789473684210527):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_181",
    "sat": "def sat(counts: List[int], target_prob: float=0.32867132867132864):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32867132867132864):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_182",
    "sat": "def sat(counts: List[int], target_prob: float=0.012903225806451613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012903225806451613):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_183",
    "sat": "def sat(counts: List[int], target_prob: float=0.11755485893416928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11755485893416928):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_184",
    "sat": "def sat(counts: List[int], target_prob: float=0.23529411764705882):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23529411764705882):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_185",
    "sat": "def sat(counts: List[int], target_prob: float=0.0975609756097561):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0975609756097561):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_186",
    "sat": "def sat(counts: List[int], target_prob: float=0.5239786856127886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5239786856127886):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_187",
    "sat": "def sat(counts: List[int], target_prob: float=0.35294117647058826):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35294117647058826):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_188",
    "sat": "def sat(counts: List[int], target_prob: float=0.7761194029850746):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7761194029850746):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_189",
    "sat": "def sat(counts: List[int], target_prob: float=0.3002680965147453):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3002680965147453):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_190",
    "sat": "def sat(counts: List[int], target_prob: float=0.7112970711297071):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7112970711297071):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_191",
    "sat": "def sat(counts: List[int], target_prob: float=0.872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.872):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_192",
    "sat": "def sat(counts: List[int], target_prob: float=0.22330097087378642):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22330097087378642):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_193",
    "sat": "def sat(counts: List[int], target_prob: float=0.25874125874125875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25874125874125875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_194",
    "sat": "def sat(counts: List[int], target_prob: float=0.24324324324324326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24324324324324326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_195",
    "sat": "def sat(counts: List[int], target_prob: float=0.09615384615384616):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09615384615384616):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_196",
    "sat": "def sat(counts: List[int], target_prob: float=0.3142857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_197",
    "sat": "def sat(counts: List[int], target_prob: float=0.4037735849056604):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4037735849056604):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_198",
    "sat": "def sat(counts: List[int], target_prob: float=0.40606060606060607):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40606060606060607):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_199",
    "sat": "def sat(counts: List[int], target_prob: float=0.08534322820037106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08534322820037106):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_200",
    "sat": "def sat(counts: List[int], target_prob: float=0.0462046204620462):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0462046204620462):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_201",
    "sat": "def sat(counts: List[int], target_prob: float=0.4132231404958678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4132231404958678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_202",
    "sat": "def sat(counts: List[int], target_prob: float=0.3235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_203",
    "sat": "def sat(counts: List[int], target_prob: float=0.21019108280254778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21019108280254778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_204",
    "sat": "def sat(counts: List[int], target_prob: float=0.26380368098159507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26380368098159507):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_205",
    "sat": "def sat(counts: List[int], target_prob: float=0.24691358024691357):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24691358024691357):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_206",
    "sat": "def sat(counts: List[int], target_prob: float=0.12685337726523888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12685337726523888):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_207",
    "sat": "def sat(counts: List[int], target_prob: float=0.30864197530864196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30864197530864196):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_208",
    "sat": "def sat(counts: List[int], target_prob: float=0.8959537572254336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8959537572254336):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_209",
    "sat": "def sat(counts: List[int], target_prob: float=0.11594202898550725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11594202898550725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_210",
    "sat": "def sat(counts: List[int], target_prob: float=0.2727272727272727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2727272727272727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_211",
    "sat": "def sat(counts: List[int], target_prob: float=0.3294685990338164):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3294685990338164):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_212",
    "sat": "def sat(counts: List[int], target_prob: float=0.058823529411764705):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.058823529411764705):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_213",
    "sat": "def sat(counts: List[int], target_prob: float=0.7204884667571235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7204884667571235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_214",
    "sat": "def sat(counts: List[int], target_prob: float=0.2231404958677686):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2231404958677686):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_215",
    "sat": "def sat(counts: List[int], target_prob: float=0.22857142857142856):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22857142857142856):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_216",
    "sat": "def sat(counts: List[int], target_prob: float=0.20408163265306123):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20408163265306123):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_217",
    "sat": "def sat(counts: List[int], target_prob: float=0.95):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.95):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_218",
    "sat": "def sat(counts: List[int], target_prob: float=0.2702702702702703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2702702702702703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_219",
    "sat": "def sat(counts: List[int], target_prob: float=0.3825242718446602):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3825242718446602):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_220",
    "sat": "def sat(counts: List[int], target_prob: float=0.9396984924623115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9396984924623115):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_221",
    "sat": "def sat(counts: List[int], target_prob: float=0.5275590551181102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5275590551181102):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_222",
    "sat": "def sat(counts: List[int], target_prob: float=0.20430107526881722):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20430107526881722):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_223",
    "sat": "def sat(counts: List[int], target_prob: float=0.35311572700296734):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35311572700296734):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_224",
    "sat": "def sat(counts: List[int], target_prob: float=0.4796926454445664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4796926454445664):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_225",
    "sat": "def sat(counts: List[int], target_prob: float=0.8874773139745916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8874773139745916):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_226",
    "sat": "def sat(counts: List[int], target_prob: float=0.15873015873015872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15873015873015872):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_227",
    "sat": "def sat(counts: List[int], target_prob: float=0.9850746268656716):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9850746268656716):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_228",
    "sat": "def sat(counts: List[int], target_prob: float=0.2066869300911854):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2066869300911854):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_229",
    "sat": "def sat(counts: List[int], target_prob: float=0.5348837209302325):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5348837209302325):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_230",
    "sat": "def sat(counts: List[int], target_prob: float=0.2846715328467153):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2846715328467153):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_231",
    "sat": "def sat(counts: List[int], target_prob: float=0.1165644171779141):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1165644171779141):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_232",
    "sat": "def sat(counts: List[int], target_prob: float=0.6756756756756757):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6756756756756757):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_233",
    "sat": "def sat(counts: List[int], target_prob: float=0.625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_234",
    "sat": "def sat(counts: List[int], target_prob: float=0.6507936507936508):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6507936507936508):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_235",
    "sat": "def sat(counts: List[int], target_prob: float=0.48073959938366717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48073959938366717):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_236",
    "sat": "def sat(counts: List[int], target_prob: float=0.13131313131313133):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13131313131313133):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_237",
    "sat": "def sat(counts: List[int], target_prob: float=0.15270935960591134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15270935960591134):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_238",
    "sat": "def sat(counts: List[int], target_prob: float=0.11070780399274047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11070780399274047):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_239",
    "sat": "def sat(counts: List[int], target_prob: float=0.35626535626535627):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35626535626535627):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_240",
    "sat": "def sat(counts: List[int], target_prob: float=0.8303886925795053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8303886925795053):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_241",
    "sat": "def sat(counts: List[int], target_prob: float=0.12222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_242",
    "sat": "def sat(counts: List[int], target_prob: float=0.678391959798995):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.678391959798995):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_243",
    "sat": "def sat(counts: List[int], target_prob: float=0.9289940828402367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9289940828402367):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_244",
    "sat": "def sat(counts: List[int], target_prob: float=0.8981481481481481):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8981481481481481):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_245",
    "sat": "def sat(counts: List[int], target_prob: float=0.3392857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3392857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_246",
    "sat": "def sat(counts: List[int], target_prob: float=0.36231884057971014):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36231884057971014):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_247",
    "sat": "def sat(counts: List[int], target_prob: float=0.2638888888888889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2638888888888889):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_248",
    "sat": "def sat(counts: List[int], target_prob: float=0.5748031496062992):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5748031496062992):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_249",
    "sat": "def sat(counts: List[int], target_prob: float=0.79):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.79):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_250",
    "sat": "def sat(counts: List[int], target_prob: float=0.34760147601476016):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34760147601476016):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_251",
    "sat": "def sat(counts: List[int], target_prob: float=0.2680652680652681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2680652680652681):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_252",
    "sat": "def sat(counts: List[int], target_prob: float=0.04736371760500447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04736371760500447):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_253",
    "sat": "def sat(counts: List[int], target_prob: float=0.21686746987951808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21686746987951808):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_254",
    "sat": "def sat(counts: List[int], target_prob: float=0.8009478672985783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8009478672985783):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_255",
    "sat": "def sat(counts: List[int], target_prob: float=0.06091370558375635):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06091370558375635):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_256",
    "sat": "def sat(counts: List[int], target_prob: float=0.5714285714285714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5714285714285714):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_257",
    "sat": "def sat(counts: List[int], target_prob: float=0.23636363636363636):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23636363636363636):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_258",
    "sat": "def sat(counts: List[int], target_prob: float=0.13559322033898305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13559322033898305):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_259",
    "sat": "def sat(counts: List[int], target_prob: float=0.21070234113712374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21070234113712374):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_260",
    "sat": "def sat(counts: List[int], target_prob: float=0.5581395348837209):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5581395348837209):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_261",
    "sat": "def sat(counts: List[int], target_prob: float=0.26785714285714285):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26785714285714285):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_262",
    "sat": "def sat(counts: List[int], target_prob: float=0.06787330316742081):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06787330316742081):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_263",
    "sat": "def sat(counts: List[int], target_prob: float=0.1295843520782396):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1295843520782396):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_264",
    "sat": "def sat(counts: List[int], target_prob: float=0.4972677595628415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4972677595628415):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_265",
    "sat": "def sat(counts: List[int], target_prob: float=0.3180952380952381):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3180952380952381):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_266",
    "sat": "def sat(counts: List[int], target_prob: float=0.5555555555555556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5555555555555556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_267",
    "sat": "def sat(counts: List[int], target_prob: float=0.09219858156028368):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09219858156028368):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_268",
    "sat": "def sat(counts: List[int], target_prob: float=0.20218579234972678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20218579234972678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_269",
    "sat": "def sat(counts: List[int], target_prob: float=0.2826086956521739):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2826086956521739):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_270",
    "sat": "def sat(counts: List[int], target_prob: float=0.822429906542056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.822429906542056):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_271",
    "sat": "def sat(counts: List[int], target_prob: float=0.6078431372549019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6078431372549019):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_272",
    "sat": "def sat(counts: List[int], target_prob: float=0.17796610169491525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17796610169491525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_273",
    "sat": "def sat(counts: List[int], target_prob: float=0.9958847736625515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9958847736625515):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_274",
    "sat": "def sat(counts: List[int], target_prob: float=0.9166666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9166666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_275",
    "sat": "def sat(counts: List[int], target_prob: float=0.47717842323651455):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47717842323651455):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_276",
    "sat": "def sat(counts: List[int], target_prob: float=0.2413793103448276):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2413793103448276):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_277",
    "sat": "def sat(counts: List[int], target_prob: float=0.5755102040816327):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5755102040816327):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_278",
    "sat": "def sat(counts: List[int], target_prob: float=0.40696517412935324):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40696517412935324):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_279",
    "sat": "def sat(counts: List[int], target_prob: float=0.6888888888888889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6888888888888889):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_280",
    "sat": "def sat(counts: List[int], target_prob: float=0.013953488372093023):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.013953488372093023):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_281",
    "sat": "def sat(counts: List[int], target_prob: float=0.2778649921507064):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2778649921507064):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_282",
    "sat": "def sat(counts: List[int], target_prob: float=0.7941176470588235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7941176470588235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_283",
    "sat": "def sat(counts: List[int], target_prob: float=0.9495798319327731):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9495798319327731):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_284",
    "sat": "def sat(counts: List[int], target_prob: float=0.528169014084507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.528169014084507):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_285",
    "sat": "def sat(counts: List[int], target_prob: float=0.3):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_286",
    "sat": "def sat(counts: List[int], target_prob: float=0.41379310344827586):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41379310344827586):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_287",
    "sat": "def sat(counts: List[int], target_prob: float=0.4245810055865922):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4245810055865922):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_288",
    "sat": "def sat(counts: List[int], target_prob: float=0.18624641833810887):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18624641833810887):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_289",
    "sat": "def sat(counts: List[int], target_prob: float=0.08571428571428572):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08571428571428572):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_290",
    "sat": "def sat(counts: List[int], target_prob: float=0.8898305084745762):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8898305084745762):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_291",
    "sat": "def sat(counts: List[int], target_prob: float=0.17884130982367757):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17884130982367757):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_292",
    "sat": "def sat(counts: List[int], target_prob: float=0.4651685393258427):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4651685393258427):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_293",
    "sat": "def sat(counts: List[int], target_prob: float=0.03954802259887006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03954802259887006):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_294",
    "sat": "def sat(counts: List[int], target_prob: float=0.049079754601226995):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.049079754601226995):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_295",
    "sat": "def sat(counts: List[int], target_prob: float=0.9958932238193019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9958932238193019):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_296",
    "sat": "def sat(counts: List[int], target_prob: float=0.5399239543726235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5399239543726235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_297",
    "sat": "def sat(counts: List[int], target_prob: float=0.5529411764705883):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5529411764705883):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_298",
    "sat": "def sat(counts: List[int], target_prob: float=0.35766423357664234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35766423357664234):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_299",
    "sat": "def sat(counts: List[int], target_prob: float=0.75):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.75):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_300",
    "sat": "def sat(counts: List[int], target_prob: float=0.43302180685358255):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43302180685358255):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_301",
    "sat": "def sat(counts: List[int], target_prob: float=0.46526867627785057):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46526867627785057):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_302",
    "sat": "def sat(counts: List[int], target_prob: float=0.43973941368078173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43973941368078173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_303",
    "sat": "def sat(counts: List[int], target_prob: float=0.11469534050179211):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11469534050179211):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_304",
    "sat": "def sat(counts: List[int], target_prob: float=0.10344827586206896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10344827586206896):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_305",
    "sat": "def sat(counts: List[int], target_prob: float=0.7560975609756098):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7560975609756098):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_306",
    "sat": "def sat(counts: List[int], target_prob: float=0.39492753623188404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39492753623188404):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_307",
    "sat": "def sat(counts: List[int], target_prob: float=0.07473309608540925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07473309608540925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_308",
    "sat": "def sat(counts: List[int], target_prob: float=0.25411334552102377):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25411334552102377):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_309",
    "sat": "def sat(counts: List[int], target_prob: float=0.04100946372239748):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04100946372239748):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_310",
    "sat": "def sat(counts: List[int], target_prob: float=0.3706896551724138):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3706896551724138):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_311",
    "sat": "def sat(counts: List[int], target_prob: float=0.5992141453831041):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5992141453831041):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_312",
    "sat": "def sat(counts: List[int], target_prob: float=0.1639871382636656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1639871382636656):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_313",
    "sat": "def sat(counts: List[int], target_prob: float=0.9259259259259259):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9259259259259259):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_314",
    "sat": "def sat(counts: List[int], target_prob: float=0.4492753623188406):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4492753623188406):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_315",
    "sat": "def sat(counts: List[int], target_prob: float=0.22250639386189258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22250639386189258):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_316",
    "sat": "def sat(counts: List[int], target_prob: float=0.8840579710144928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8840579710144928):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_317",
    "sat": "def sat(counts: List[int], target_prob: float=0.996031746031746):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.996031746031746):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_318",
    "sat": "def sat(counts: List[int], target_prob: float=0.9322033898305084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9322033898305084):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_319",
    "sat": "def sat(counts: List[int], target_prob: float=0.17647058823529413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17647058823529413):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_320",
    "sat": "def sat(counts: List[int], target_prob: float=0.20105820105820105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20105820105820105):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_321",
    "sat": "def sat(counts: List[int], target_prob: float=0.0603290676416819):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0603290676416819):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_322",
    "sat": "def sat(counts: List[int], target_prob: float=0.1702127659574468):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1702127659574468):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_323",
    "sat": "def sat(counts: List[int], target_prob: float=0.19642857142857142):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19642857142857142):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_324",
    "sat": "def sat(counts: List[int], target_prob: float=0.48214285714285715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48214285714285715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_325",
    "sat": "def sat(counts: List[int], target_prob: float=0.70917225950783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.70917225950783):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_326",
    "sat": "def sat(counts: List[int], target_prob: float=0.3273809523809524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3273809523809524):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_327",
    "sat": "def sat(counts: List[int], target_prob: float=0.15428571428571428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15428571428571428):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_328",
    "sat": "def sat(counts: List[int], target_prob: float=0.5579631635969664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5579631635969664):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_329",
    "sat": "def sat(counts: List[int], target_prob: float=0.302491103202847):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.302491103202847):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_330",
    "sat": "def sat(counts: List[int], target_prob: float=0.0556792873051225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0556792873051225):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_331",
    "sat": "def sat(counts: List[int], target_prob: float=0.3902439024390244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3902439024390244):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_332",
    "sat": "def sat(counts: List[int], target_prob: float=0.5647058823529412):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5647058823529412):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_333",
    "sat": "def sat(counts: List[int], target_prob: float=0.5412844036697247):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5412844036697247):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_334",
    "sat": "def sat(counts: List[int], target_prob: float=0.7398373983739838):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7398373983739838):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_335",
    "sat": "def sat(counts: List[int], target_prob: float=0.02564102564102564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02564102564102564):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_336",
    "sat": "def sat(counts: List[int], target_prob: float=0.5418181818181819):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5418181818181819):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_337",
    "sat": "def sat(counts: List[int], target_prob: float=0.30612244897959184):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30612244897959184):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_338",
    "sat": "def sat(counts: List[int], target_prob: float=0.03209876543209877):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03209876543209877):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_339",
    "sat": "def sat(counts: List[int], target_prob: float=0.6468468468468469):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6468468468468469):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_340",
    "sat": "def sat(counts: List[int], target_prob: float=0.09302325581395349):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09302325581395349):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_341",
    "sat": "def sat(counts: List[int], target_prob: float=0.6103896103896104):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6103896103896104):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_342",
    "sat": "def sat(counts: List[int], target_prob: float=0.4482758620689655):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4482758620689655):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_343",
    "sat": "def sat(counts: List[int], target_prob: float=0.15422885572139303):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15422885572139303):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_344",
    "sat": "def sat(counts: List[int], target_prob: float=0.38202247191011235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38202247191011235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_345",
    "sat": "def sat(counts: List[int], target_prob: float=0.6459627329192547):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6459627329192547):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_346",
    "sat": "def sat(counts: List[int], target_prob: float=0.2775974025974026):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2775974025974026):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_347",
    "sat": "def sat(counts: List[int], target_prob: float=0.034055727554179564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.034055727554179564):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_348",
    "sat": "def sat(counts: List[int], target_prob: float=0.5862068965517241):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5862068965517241):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_349",
    "sat": "def sat(counts: List[int], target_prob: float=0.4063926940639269):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4063926940639269):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_350",
    "sat": "def sat(counts: List[int], target_prob: float=0.7914110429447853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7914110429447853):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_351",
    "sat": "def sat(counts: List[int], target_prob: float=0.5052264808362369):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5052264808362369):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_352",
    "sat": "def sat(counts: List[int], target_prob: float=0.43884892086330934):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43884892086330934):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_353",
    "sat": "def sat(counts: List[int], target_prob: float=0.8857142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8857142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_354",
    "sat": "def sat(counts: List[int], target_prob: float=0.3473684210526316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3473684210526316):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_355",
    "sat": "def sat(counts: List[int], target_prob: float=0.2843915343915344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2843915343915344):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_356",
    "sat": "def sat(counts: List[int], target_prob: float=0.08607198748043818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08607198748043818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_357",
    "sat": "def sat(counts: List[int], target_prob: float=0.5121951219512195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5121951219512195):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_358",
    "sat": "def sat(counts: List[int], target_prob: float=0.028112449799196786):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.028112449799196786):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_359",
    "sat": "def sat(counts: List[int], target_prob: float=0.2027729636048527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2027729636048527):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_360",
    "sat": "def sat(counts: List[int], target_prob: float=0.12386706948640483):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12386706948640483):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_361",
    "sat": "def sat(counts: List[int], target_prob: float=0.22408963585434175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22408963585434175):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_362",
    "sat": "def sat(counts: List[int], target_prob: float=0.18518518518518517):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18518518518518517):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_363",
    "sat": "def sat(counts: List[int], target_prob: float=0.031007751937984496):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.031007751937984496):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_364",
    "sat": "def sat(counts: List[int], target_prob: float=0.000724112961622013):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.000724112961622013):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_365",
    "sat": "def sat(counts: List[int], target_prob: float=0.34545454545454546):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34545454545454546):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_366",
    "sat": "def sat(counts: List[int], target_prob: float=0.8947368421052632):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8947368421052632):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_367",
    "sat": "def sat(counts: List[int], target_prob: float=0.19298245614035087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19298245614035087):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_368",
    "sat": "def sat(counts: List[int], target_prob: float=0.1772357723577236):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1772357723577236):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_369",
    "sat": "def sat(counts: List[int], target_prob: float=0.36):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_370",
    "sat": "def sat(counts: List[int], target_prob: float=0.15151515151515152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15151515151515152):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_371",
    "sat": "def sat(counts: List[int], target_prob: float=0.13513513513513514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13513513513513514):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_372",
    "sat": "def sat(counts: List[int], target_prob: float=0.31343283582089554):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31343283582089554):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_373",
    "sat": "def sat(counts: List[int], target_prob: float=0.3486238532110092):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3486238532110092):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_374",
    "sat": "def sat(counts: List[int], target_prob: float=0.22137404580152673):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22137404580152673):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_375",
    "sat": "def sat(counts: List[int], target_prob: float=0.16634050880626222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16634050880626222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_376",
    "sat": "def sat(counts: List[int], target_prob: float=0.3617021276595745):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3617021276595745):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_377",
    "sat": "def sat(counts: List[int], target_prob: float=0.3890020366598778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3890020366598778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_378",
    "sat": "def sat(counts: List[int], target_prob: float=0.12643678160919541):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12643678160919541):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_379",
    "sat": "def sat(counts: List[int], target_prob: float=0.5507246376811594):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5507246376811594):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_380",
    "sat": "def sat(counts: List[int], target_prob: float=0.5915492957746479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5915492957746479):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_381",
    "sat": "def sat(counts: List[int], target_prob: float=0.7346938775510204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7346938775510204):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_382",
    "sat": "def sat(counts: List[int], target_prob: float=0.963882618510158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.963882618510158):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_383",
    "sat": "def sat(counts: List[int], target_prob: float=0.2857142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2857142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_384",
    "sat": "def sat(counts: List[int], target_prob: float=0.08614232209737828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08614232209737828):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_385",
    "sat": "def sat(counts: List[int], target_prob: float=0.04398826979472141):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04398826979472141):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_386",
    "sat": "def sat(counts: List[int], target_prob: float=0.5012224938875306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5012224938875306):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_387",
    "sat": "def sat(counts: List[int], target_prob: float=0.011320754716981131):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.011320754716981131):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_388",
    "sat": "def sat(counts: List[int], target_prob: float=0.1834862385321101):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1834862385321101):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_389",
    "sat": "def sat(counts: List[int], target_prob: float=0.024918743228602384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.024918743228602384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_390",
    "sat": "def sat(counts: List[int], target_prob: float=0.8278145695364238):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8278145695364238):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_391",
    "sat": "def sat(counts: List[int], target_prob: float=0.1669724770642202):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1669724770642202):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_392",
    "sat": "def sat(counts: List[int], target_prob: float=0.30303030303030304):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30303030303030304):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_393",
    "sat": "def sat(counts: List[int], target_prob: float=0.16923076923076924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16923076923076924):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_394",
    "sat": "def sat(counts: List[int], target_prob: float=0.02040816326530612):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02040816326530612):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_395",
    "sat": "def sat(counts: List[int], target_prob: float=0.9130434782608695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9130434782608695):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_396",
    "sat": "def sat(counts: List[int], target_prob: float=0.9627329192546584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9627329192546584):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_397",
    "sat": "def sat(counts: List[int], target_prob: float=0.4594594594594595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4594594594594595):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_398",
    "sat": "def sat(counts: List[int], target_prob: float=0.8314606741573034):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8314606741573034):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_399",
    "sat": "def sat(counts: List[int], target_prob: float=0.15853658536585366):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15853658536585366):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_400",
    "sat": "def sat(counts: List[int], target_prob: float=0.32622222222222225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32622222222222225):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_401",
    "sat": "def sat(counts: List[int], target_prob: float=0.7180616740088106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7180616740088106):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_402",
    "sat": "def sat(counts: List[int], target_prob: float=0.012):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_403",
    "sat": "def sat(counts: List[int], target_prob: float=0.8051470588235294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8051470588235294):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_404",
    "sat": "def sat(counts: List[int], target_prob: float=0.5764192139737991):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5764192139737991):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_405",
    "sat": "def sat(counts: List[int], target_prob: float=0.6601307189542484):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6601307189542484):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_406",
    "sat": "def sat(counts: List[int], target_prob: float=0.2896551724137931):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2896551724137931):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_407",
    "sat": "def sat(counts: List[int], target_prob: float=0.34579439252336447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34579439252336447):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_408",
    "sat": "def sat(counts: List[int], target_prob: float=0.48031496062992124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48031496062992124):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_409",
    "sat": "def sat(counts: List[int], target_prob: float=0.0967741935483871):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0967741935483871):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_410",
    "sat": "def sat(counts: List[int], target_prob: float=0.07017543859649122):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07017543859649122):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_411",
    "sat": "def sat(counts: List[int], target_prob: float=0.12962962962962962):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12962962962962962):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_412",
    "sat": "def sat(counts: List[int], target_prob: float=0.17073170731707318):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17073170731707318):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_413",
    "sat": "def sat(counts: List[int], target_prob: float=0.0847457627118644):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0847457627118644):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_414",
    "sat": "def sat(counts: List[int], target_prob: float=0.42857142857142855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42857142857142855):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_415",
    "sat": "def sat(counts: List[int], target_prob: float=0.5217391304347826):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5217391304347826):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_416",
    "sat": "def sat(counts: List[int], target_prob: float=0.06769825918762089):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06769825918762089):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_417",
    "sat": "def sat(counts: List[int], target_prob: float=0.903448275862069):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.903448275862069):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_418",
    "sat": "def sat(counts: List[int], target_prob: float=0.3682373472949389):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3682373472949389):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_419",
    "sat": "def sat(counts: List[int], target_prob: float=0.027247956403269755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.027247956403269755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_420",
    "sat": "def sat(counts: List[int], target_prob: float=0.3559322033898305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3559322033898305):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_421",
    "sat": "def sat(counts: List[int], target_prob: float=0.7752808988764045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7752808988764045):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_422",
    "sat": "def sat(counts: List[int], target_prob: float=0.8021760633036598):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8021760633036598):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_423",
    "sat": "def sat(counts: List[int], target_prob: float=0.14074074074074075):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14074074074074075):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_424",
    "sat": "def sat(counts: List[int], target_prob: float=0.3065236818588025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3065236818588025):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_425",
    "sat": "def sat(counts: List[int], target_prob: float=0.04874446085672083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04874446085672083):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_426",
    "sat": "def sat(counts: List[int], target_prob: float=0.2608695652173913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2608695652173913):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_427",
    "sat": "def sat(counts: List[int], target_prob: float=0.38461538461538464):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38461538461538464):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_428",
    "sat": "def sat(counts: List[int], target_prob: float=0.7513513513513513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7513513513513513):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_429",
    "sat": "def sat(counts: List[int], target_prob: float=0.12062256809338522):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12062256809338522):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_430",
    "sat": "def sat(counts: List[int], target_prob: float=0.15289982425307558):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15289982425307558):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_431",
    "sat": "def sat(counts: List[int], target_prob: float=0.696969696969697):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.696969696969697):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_432",
    "sat": "def sat(counts: List[int], target_prob: float=0.5087719298245614):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5087719298245614):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_433",
    "sat": "def sat(counts: List[int], target_prob: float=0.45454545454545453):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45454545454545453):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_434",
    "sat": "def sat(counts: List[int], target_prob: float=0.11357340720221606):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11357340720221606):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_435",
    "sat": "def sat(counts: List[int], target_prob: float=0.22511848341232227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22511848341232227):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_436",
    "sat": "def sat(counts: List[int], target_prob: float=0.03557312252964427):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03557312252964427):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_437",
    "sat": "def sat(counts: List[int], target_prob: float=0.7792207792207793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7792207792207793):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_438",
    "sat": "def sat(counts: List[int], target_prob: float=0.42028985507246375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42028985507246375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_439",
    "sat": "def sat(counts: List[int], target_prob: float=0.20300751879699247):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20300751879699247):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_440",
    "sat": "def sat(counts: List[int], target_prob: float=0.5384615384615384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5384615384615384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_441",
    "sat": "def sat(counts: List[int], target_prob: float=0.5454545454545454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5454545454545454):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_442",
    "sat": "def sat(counts: List[int], target_prob: float=0.03896103896103896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03896103896103896):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_443",
    "sat": "def sat(counts: List[int], target_prob: float=0.20930232558139536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20930232558139536):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_444",
    "sat": "def sat(counts: List[int], target_prob: float=0.5185185185185185):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5185185185185185):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_445",
    "sat": "def sat(counts: List[int], target_prob: float=0.04159343878148799):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04159343878148799):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_446",
    "sat": "def sat(counts: List[int], target_prob: float=0.3851428571428571):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3851428571428571):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_447",
    "sat": "def sat(counts: List[int], target_prob: float=0.34249471458773784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34249471458773784):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_448",
    "sat": "def sat(counts: List[int], target_prob: float=0.2876712328767123):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2876712328767123):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_449",
    "sat": "def sat(counts: List[int], target_prob: float=0.9104477611940298):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9104477611940298):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_450",
    "sat": "def sat(counts: List[int], target_prob: float=0.015105740181268883):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.015105740181268883):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_451",
    "sat": "def sat(counts: List[int], target_prob: float=0.471976401179941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.471976401179941):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_452",
    "sat": "def sat(counts: List[int], target_prob: float=0.023529411764705882):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.023529411764705882):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_453",
    "sat": "def sat(counts: List[int], target_prob: float=0.44559585492227977):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44559585492227977):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_454",
    "sat": "def sat(counts: List[int], target_prob: float=0.06666666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06666666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_455",
    "sat": "def sat(counts: List[int], target_prob: float=0.6161616161616161):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6161616161616161):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_456",
    "sat": "def sat(counts: List[int], target_prob: float=0.41904761904761906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41904761904761906):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_457",
    "sat": "def sat(counts: List[int], target_prob: float=0.7049180327868853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7049180327868853):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_458",
    "sat": "def sat(counts: List[int], target_prob: float=0.18095238095238095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18095238095238095):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_459",
    "sat": "def sat(counts: List[int], target_prob: float=0.038461538461538464):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.038461538461538464):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_460",
    "sat": "def sat(counts: List[int], target_prob: float=0.0313588850174216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0313588850174216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_461",
    "sat": "def sat(counts: List[int], target_prob: float=0.8181818181818182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8181818181818182):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_462",
    "sat": "def sat(counts: List[int], target_prob: float=0.6224899598393574):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6224899598393574):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_463",
    "sat": "def sat(counts: List[int], target_prob: float=0.6293706293706294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6293706293706294):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_464",
    "sat": "def sat(counts: List[int], target_prob: float=0.21568627450980393):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21568627450980393):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_465",
    "sat": "def sat(counts: List[int], target_prob: float=0.14366998577524892):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14366998577524892):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_466",
    "sat": "def sat(counts: List[int], target_prob: float=0.8620037807183365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8620037807183365):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_467",
    "sat": "def sat(counts: List[int], target_prob: float=0.03296703296703297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03296703296703297):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_468",
    "sat": "def sat(counts: List[int], target_prob: float=0.5675675675675675):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5675675675675675):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_469",
    "sat": "def sat(counts: List[int], target_prob: float=0.6883116883116883):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6883116883116883):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_470",
    "sat": "def sat(counts: List[int], target_prob: float=0.05747126436781609):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05747126436781609):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_471",
    "sat": "def sat(counts: List[int], target_prob: float=0.14563106796116504):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14563106796116504):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_472",
    "sat": "def sat(counts: List[int], target_prob: float=0.296875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.296875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_473",
    "sat": "def sat(counts: List[int], target_prob: float=0.10077519379844961):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10077519379844961):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_474",
    "sat": "def sat(counts: List[int], target_prob: float=0.09748427672955975):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09748427672955975):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_475",
    "sat": "def sat(counts: List[int], target_prob: float=0.2378138847858198):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2378138847858198):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_476",
    "sat": "def sat(counts: List[int], target_prob: float=0.05555555555555555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05555555555555555):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_477",
    "sat": "def sat(counts: List[int], target_prob: float=0.1794871794871795):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1794871794871795):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_478",
    "sat": "def sat(counts: List[int], target_prob: float=0.2692307692307692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2692307692307692):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_479",
    "sat": "def sat(counts: List[int], target_prob: float=0.27494908350305497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27494908350305497):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_480",
    "sat": "def sat(counts: List[int], target_prob: float=0.23512747875354106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23512747875354106):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_481",
    "sat": "def sat(counts: List[int], target_prob: float=0.7727272727272727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7727272727272727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_482",
    "sat": "def sat(counts: List[int], target_prob: float=0.32131147540983607):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32131147540983607):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_483",
    "sat": "def sat(counts: List[int], target_prob: float=0.044):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.044):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_484",
    "sat": "def sat(counts: List[int], target_prob: float=0.21296296296296297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21296296296296297):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_485",
    "sat": "def sat(counts: List[int], target_prob: float=0.015873015873015872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.015873015873015872):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_486",
    "sat": "def sat(counts: List[int], target_prob: float=0.44680851063829785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44680851063829785):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_487",
    "sat": "def sat(counts: List[int], target_prob: float=0.31640625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31640625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_488",
    "sat": "def sat(counts: List[int], target_prob: float=0.14675767918088736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14675767918088736):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_489",
    "sat": "def sat(counts: List[int], target_prob: float=0.026737967914438502):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.026737967914438502):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_490",
    "sat": "def sat(counts: List[int], target_prob: float=0.515527950310559):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.515527950310559):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_491",
    "sat": "def sat(counts: List[int], target_prob: float=0.1326530612244898):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1326530612244898):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_492",
    "sat": "def sat(counts: List[int], target_prob: float=0.12195121951219512):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12195121951219512):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_493",
    "sat": "def sat(counts: List[int], target_prob: float=0.6144578313253012):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6144578313253012):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_494",
    "sat": "def sat(counts: List[int], target_prob: float=0.15789473684210525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15789473684210525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_495",
    "sat": "def sat(counts: List[int], target_prob: float=0.42731277533039647):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42731277533039647):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_496",
    "sat": "def sat(counts: List[int], target_prob: float=0.12087912087912088):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12087912087912088):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_497",
    "sat": "def sat(counts: List[int], target_prob: float=0.5333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_498",
    "sat": "def sat(counts: List[int], target_prob: float=0.04807692307692308):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04807692307692308):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_499",
    "sat": "def sat(counts: List[int], target_prob: float=0.32075471698113206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32075471698113206):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_500",
    "sat": "def sat(counts: List[int], target_prob: float=0.7777777777777778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7777777777777778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_501",
    "sat": "def sat(counts: List[int], target_prob: float=0.37110481586402266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37110481586402266):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_502",
    "sat": "def sat(counts: List[int], target_prob: float=0.3793103448275862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3793103448275862):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_503",
    "sat": "def sat(counts: List[int], target_prob: float=0.4961832061068702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4961832061068702):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_504",
    "sat": "def sat(counts: List[int], target_prob: float=0.5433070866141733):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5433070866141733):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_505",
    "sat": "def sat(counts: List[int], target_prob: float=0.6416938110749185):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6416938110749185):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_506",
    "sat": "def sat(counts: List[int], target_prob: float=0.0755287009063444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0755287009063444):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_507",
    "sat": "def sat(counts: List[int], target_prob: float=0.5428571428571428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5428571428571428):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_508",
    "sat": "def sat(counts: List[int], target_prob: float=0.3448275862068966):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3448275862068966):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_509",
    "sat": "def sat(counts: List[int], target_prob: float=0.30685920577617326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30685920577617326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_510",
    "sat": "def sat(counts: List[int], target_prob: float=0.2972972972972973):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2972972972972973):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_511",
    "sat": "def sat(counts: List[int], target_prob: float=0.03286384976525822):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03286384976525822):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_512",
    "sat": "def sat(counts: List[int], target_prob: float=0.34375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_513",
    "sat": "def sat(counts: List[int], target_prob: float=0.2967032967032967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2967032967032967):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_514",
    "sat": "def sat(counts: List[int], target_prob: float=0.15910629654705485):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15910629654705485):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_515",
    "sat": "def sat(counts: List[int], target_prob: float=0.0962962962962963):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0962962962962963):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_516",
    "sat": "def sat(counts: List[int], target_prob: float=0.04):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_517",
    "sat": "def sat(counts: List[int], target_prob: float=0.3654485049833887):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3654485049833887):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_518",
    "sat": "def sat(counts: List[int], target_prob: float=0.4):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_519",
    "sat": "def sat(counts: List[int], target_prob: float=0.12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_520",
    "sat": "def sat(counts: List[int], target_prob: float=0.06220095693779904):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06220095693779904):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_521",
    "sat": "def sat(counts: List[int], target_prob: float=0.39080459770114945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39080459770114945):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_522",
    "sat": "def sat(counts: List[int], target_prob: float=0.002932551319648094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.002932551319648094):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_523",
    "sat": "def sat(counts: List[int], target_prob: float=0.16293929712460065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16293929712460065):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_524",
    "sat": "def sat(counts: List[int], target_prob: float=0.92):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.92):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_525",
    "sat": "def sat(counts: List[int], target_prob: float=0.06532663316582915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06532663316582915):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_526",
    "sat": "def sat(counts: List[int], target_prob: float=0.5039370078740157):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5039370078740157):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_527",
    "sat": "def sat(counts: List[int], target_prob: float=0.10256410256410256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10256410256410256):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_528",
    "sat": "def sat(counts: List[int], target_prob: float=0.0593607305936073):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0593607305936073):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_529",
    "sat": "def sat(counts: List[int], target_prob: float=0.2521957340025094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2521957340025094):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_530",
    "sat": "def sat(counts: List[int], target_prob: float=0.019867549668874173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.019867549668874173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_531",
    "sat": "def sat(counts: List[int], target_prob: float=0.7009345794392523):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7009345794392523):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_532",
    "sat": "def sat(counts: List[int], target_prob: float=0.12468193384223919):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12468193384223919):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_533",
    "sat": "def sat(counts: List[int], target_prob: float=0.1951219512195122):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1951219512195122):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_534",
    "sat": "def sat(counts: List[int], target_prob: float=0.5128205128205128):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5128205128205128):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_535",
    "sat": "def sat(counts: List[int], target_prob: float=0.11806543385490754):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11806543385490754):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_536",
    "sat": "def sat(counts: List[int], target_prob: float=0.5098039215686274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5098039215686274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_537",
    "sat": "def sat(counts: List[int], target_prob: float=0.49056603773584906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49056603773584906):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_538",
    "sat": "def sat(counts: List[int], target_prob: float=0.9622641509433962):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9622641509433962):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_539",
    "sat": "def sat(counts: List[int], target_prob: float=0.5013698630136987):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5013698630136987):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_540",
    "sat": "def sat(counts: List[int], target_prob: float=0.0625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_541",
    "sat": "def sat(counts: List[int], target_prob: float=0.4074074074074074):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4074074074074074):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_542",
    "sat": "def sat(counts: List[int], target_prob: float=0.6463414634146342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6463414634146342):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_543",
    "sat": "def sat(counts: List[int], target_prob: float=0.034482758620689655):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.034482758620689655):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_544",
    "sat": "def sat(counts: List[int], target_prob: float=0.9700854700854701):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9700854700854701):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_545",
    "sat": "def sat(counts: List[int], target_prob: float=0.22641509433962265):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22641509433962265):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_546",
    "sat": "def sat(counts: List[int], target_prob: float=0.08955223880597014):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08955223880597014):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_547",
    "sat": "def sat(counts: List[int], target_prob: float=0.7642857142857142):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7642857142857142):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_548",
    "sat": "def sat(counts: List[int], target_prob: float=0.2630844382414515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2630844382414515):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_549",
    "sat": "def sat(counts: List[int], target_prob: float=0.03292181069958848):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03292181069958848):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_550",
    "sat": "def sat(counts: List[int], target_prob: float=0.15087719298245614):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15087719298245614):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_551",
    "sat": "def sat(counts: List[int], target_prob: float=0.8899082568807339):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8899082568807339):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_552",
    "sat": "def sat(counts: List[int], target_prob: float=0.36666666666666664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36666666666666664):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_553",
    "sat": "def sat(counts: List[int], target_prob: float=0.6923076923076923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6923076923076923):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_554",
    "sat": "def sat(counts: List[int], target_prob: float=0.7647058823529411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7647058823529411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_555",
    "sat": "def sat(counts: List[int], target_prob: float=0.3196794300979519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3196794300979519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_556",
    "sat": "def sat(counts: List[int], target_prob: float=0.12032085561497326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12032085561497326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_557",
    "sat": "def sat(counts: List[int], target_prob: float=0.30708661417322836):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30708661417322836):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_558",
    "sat": "def sat(counts: List[int], target_prob: float=0.0851063829787234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0851063829787234):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_559",
    "sat": "def sat(counts: List[int], target_prob: float=0.7421383647798742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7421383647798742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_560",
    "sat": "def sat(counts: List[int], target_prob: float=0.025906735751295335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.025906735751295335):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_561",
    "sat": "def sat(counts: List[int], target_prob: float=0.4444444444444444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4444444444444444):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_562",
    "sat": "def sat(counts: List[int], target_prob: float=0.15471698113207547):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15471698113207547):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_563",
    "sat": "def sat(counts: List[int], target_prob: float=0.9795918367346939):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9795918367346939):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_564",
    "sat": "def sat(counts: List[int], target_prob: float=0.6911764705882353):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6911764705882353):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_565",
    "sat": "def sat(counts: List[int], target_prob: float=0.36363636363636365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36363636363636365):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_566",
    "sat": "def sat(counts: List[int], target_prob: float=0.10465116279069768):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10465116279069768):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_567",
    "sat": "def sat(counts: List[int], target_prob: float=0.5773584905660377):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5773584905660377):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_568",
    "sat": "def sat(counts: List[int], target_prob: float=0.3323170731707317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3323170731707317):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_569",
    "sat": "def sat(counts: List[int], target_prob: float=0.34513274336283184):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34513274336283184):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_570",
    "sat": "def sat(counts: List[int], target_prob: float=0.11538461538461539):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11538461538461539):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_571",
    "sat": "def sat(counts: List[int], target_prob: float=0.5583333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5583333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_572",
    "sat": "def sat(counts: List[int], target_prob: float=0.6617210682492581):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6617210682492581):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_573",
    "sat": "def sat(counts: List[int], target_prob: float=0.5795454545454546):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5795454545454546):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_574",
    "sat": "def sat(counts: List[int], target_prob: float=0.2981366459627329):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2981366459627329):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_575",
    "sat": "def sat(counts: List[int], target_prob: float=0.3867595818815331):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3867595818815331):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_576",
    "sat": "def sat(counts: List[int], target_prob: float=0.856353591160221):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.856353591160221):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_577",
    "sat": "def sat(counts: List[int], target_prob: float=0.2724306688417618):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2724306688417618):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_578",
    "sat": "def sat(counts: List[int], target_prob: float=0.08235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_579",
    "sat": "def sat(counts: List[int], target_prob: float=0.5230769230769231):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5230769230769231):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_580",
    "sat": "def sat(counts: List[int], target_prob: float=0.09623430962343096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09623430962343096):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_581",
    "sat": "def sat(counts: List[int], target_prob: float=0.07339449541284404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07339449541284404):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_582",
    "sat": "def sat(counts: List[int], target_prob: float=0.13043478260869565):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13043478260869565):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_583",
    "sat": "def sat(counts: List[int], target_prob: float=0.8388888888888889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8388888888888889):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_584",
    "sat": "def sat(counts: List[int], target_prob: float=0.6990595611285266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6990595611285266):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_585",
    "sat": "def sat(counts: List[int], target_prob: float=0.4396135265700483):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4396135265700483):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_586",
    "sat": "def sat(counts: List[int], target_prob: float=0.18592964824120603):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18592964824120603):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_587",
    "sat": "def sat(counts: List[int], target_prob: float=0.248):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.248):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_588",
    "sat": "def sat(counts: List[int], target_prob: float=0.5298804780876494):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5298804780876494):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_589",
    "sat": "def sat(counts: List[int], target_prob: float=0.12037037037037036):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12037037037037036):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_590",
    "sat": "def sat(counts: List[int], target_prob: float=0.35):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_591",
    "sat": "def sat(counts: List[int], target_prob: float=0.630057803468208):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.630057803468208):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_592",
    "sat": "def sat(counts: List[int], target_prob: float=0.6770186335403726):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6770186335403726):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_593",
    "sat": "def sat(counts: List[int], target_prob: float=0.9525925925925925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9525925925925925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_594",
    "sat": "def sat(counts: List[int], target_prob: float=0.7543859649122807):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7543859649122807):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_595",
    "sat": "def sat(counts: List[int], target_prob: float=0.15348837209302327):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15348837209302327):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_596",
    "sat": "def sat(counts: List[int], target_prob: float=0.29540481400437635):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29540481400437635):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_597",
    "sat": "def sat(counts: List[int], target_prob: float=0.2602739726027397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2602739726027397):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_598",
    "sat": "def sat(counts: List[int], target_prob: float=0.24789915966386555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24789915966386555):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_599",
    "sat": "def sat(counts: List[int], target_prob: float=0.7633136094674556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7633136094674556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_600",
    "sat": "def sat(counts: List[int], target_prob: float=0.24836601307189543):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24836601307189543):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_601",
    "sat": "def sat(counts: List[int], target_prob: float=0.5172413793103449):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5172413793103449):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_602",
    "sat": "def sat(counts: List[int], target_prob: float=0.4454713493530499):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4454713493530499):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_603",
    "sat": "def sat(counts: List[int], target_prob: float=0.12903225806451613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12903225806451613):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_604",
    "sat": "def sat(counts: List[int], target_prob: float=0.511520737327189):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.511520737327189):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_605",
    "sat": "def sat(counts: List[int], target_prob: float=0.08270676691729323):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08270676691729323):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_606",
    "sat": "def sat(counts: List[int], target_prob: float=0.24719101123595505):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24719101123595505):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_607",
    "sat": "def sat(counts: List[int], target_prob: float=0.08333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_608",
    "sat": "def sat(counts: List[int], target_prob: float=0.32057416267942584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32057416267942584):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_609",
    "sat": "def sat(counts: List[int], target_prob: float=0.8076923076923077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8076923076923077):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_610",
    "sat": "def sat(counts: List[int], target_prob: float=0.10667427267541357):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10667427267541357):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_611",
    "sat": "def sat(counts: List[int], target_prob: float=0.035842293906810034):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.035842293906810034):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_612",
    "sat": "def sat(counts: List[int], target_prob: float=0.05105105105105105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05105105105105105):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_613",
    "sat": "def sat(counts: List[int], target_prob: float=0.39097744360902253):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39097744360902253):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_614",
    "sat": "def sat(counts: List[int], target_prob: float=0.30952380952380953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30952380952380953):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_615",
    "sat": "def sat(counts: List[int], target_prob: float=0.0860655737704918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0860655737704918):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_616",
    "sat": "def sat(counts: List[int], target_prob: float=0.2736318407960199):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2736318407960199):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_617",
    "sat": "def sat(counts: List[int], target_prob: float=0.7317073170731707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7317073170731707):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_618",
    "sat": "def sat(counts: List[int], target_prob: float=0.11370262390670553):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11370262390670553):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_619",
    "sat": "def sat(counts: List[int], target_prob: float=0.6555555555555556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6555555555555556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_620",
    "sat": "def sat(counts: List[int], target_prob: float=0.20418848167539266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20418848167539266):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_621",
    "sat": "def sat(counts: List[int], target_prob: float=0.5608308605341247):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5608308605341247):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_622",
    "sat": "def sat(counts: List[int], target_prob: float=0.2631578947368421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2631578947368421):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_623",
    "sat": "def sat(counts: List[int], target_prob: float=0.07389162561576355):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07389162561576355):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_624",
    "sat": "def sat(counts: List[int], target_prob: float=0.5178571428571429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5178571428571429):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_625",
    "sat": "def sat(counts: List[int], target_prob: float=0.2618296529968454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2618296529968454):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_626",
    "sat": "def sat(counts: List[int], target_prob: float=0.10738255033557047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10738255033557047):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_627",
    "sat": "def sat(counts: List[int], target_prob: float=0.21395348837209302):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21395348837209302):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_628",
    "sat": "def sat(counts: List[int], target_prob: float=0.03854166666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03854166666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_629",
    "sat": "def sat(counts: List[int], target_prob: float=0.8490566037735849):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8490566037735849):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_630",
    "sat": "def sat(counts: List[int], target_prob: float=0.7906976744186046):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7906976744186046):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_631",
    "sat": "def sat(counts: List[int], target_prob: float=0.39308176100628933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39308176100628933):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_632",
    "sat": "def sat(counts: List[int], target_prob: float=0.6129032258064516):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6129032258064516):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_633",
    "sat": "def sat(counts: List[int], target_prob: float=0.39750445632798576):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39750445632798576):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_634",
    "sat": "def sat(counts: List[int], target_prob: float=0.19047619047619047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19047619047619047):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_635",
    "sat": "def sat(counts: List[int], target_prob: float=0.2096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2096):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_636",
    "sat": "def sat(counts: List[int], target_prob: float=0.9099099099099099):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9099099099099099):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_637",
    "sat": "def sat(counts: List[int], target_prob: float=0.1157167530224525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1157167530224525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_638",
    "sat": "def sat(counts: List[int], target_prob: float=0.11036789297658862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11036789297658862):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_639",
    "sat": "def sat(counts: List[int], target_prob: float=0.7654075546719682):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7654075546719682):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_640",
    "sat": "def sat(counts: List[int], target_prob: float=0.2676056338028169):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2676056338028169):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_641",
    "sat": "def sat(counts: List[int], target_prob: float=0.021176470588235293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.021176470588235293):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_642",
    "sat": "def sat(counts: List[int], target_prob: float=0.25139664804469275):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25139664804469275):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_643",
    "sat": "def sat(counts: List[int], target_prob: float=0.09876543209876543):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09876543209876543):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_644",
    "sat": "def sat(counts: List[int], target_prob: float=0.39712918660287083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39712918660287083):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_645",
    "sat": "def sat(counts: List[int], target_prob: float=0.43820224719101125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43820224719101125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_646",
    "sat": "def sat(counts: List[int], target_prob: float=0.922077922077922):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.922077922077922):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_647",
    "sat": "def sat(counts: List[int], target_prob: float=0.9279279279279279):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9279279279279279):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_648",
    "sat": "def sat(counts: List[int], target_prob: float=0.056818181818181816):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.056818181818181816):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_649",
    "sat": "def sat(counts: List[int], target_prob: float=0.09426987060998152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09426987060998152):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_650",
    "sat": "def sat(counts: List[int], target_prob: float=0.20652173913043478):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20652173913043478):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_651",
    "sat": "def sat(counts: List[int], target_prob: float=0.4358974358974359):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4358974358974359):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_652",
    "sat": "def sat(counts: List[int], target_prob: float=0.11711711711711711):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11711711711711711):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_653",
    "sat": "def sat(counts: List[int], target_prob: float=0.18840579710144928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18840579710144928):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_654",
    "sat": "def sat(counts: List[int], target_prob: float=0.2920962199312715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2920962199312715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_655",
    "sat": "def sat(counts: List[int], target_prob: float=0.7802197802197802):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7802197802197802):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_656",
    "sat": "def sat(counts: List[int], target_prob: float=0.9203980099502488):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9203980099502488):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_657",
    "sat": "def sat(counts: List[int], target_prob: float=0.52):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.52):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_658",
    "sat": "def sat(counts: List[int], target_prob: float=0.1934826883910387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1934826883910387):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_659",
    "sat": "def sat(counts: List[int], target_prob: float=0.11864406779661017):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11864406779661017):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_660",
    "sat": "def sat(counts: List[int], target_prob: float=0.07518796992481203):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07518796992481203):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_661",
    "sat": "def sat(counts: List[int], target_prob: float=0.10930232558139535):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10930232558139535):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_662",
    "sat": "def sat(counts: List[int], target_prob: float=0.009174311926605505):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.009174311926605505):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_663",
    "sat": "def sat(counts: List[int], target_prob: float=0.5833333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5833333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_664",
    "sat": "def sat(counts: List[int], target_prob: float=0.17333333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17333333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_665",
    "sat": "def sat(counts: List[int], target_prob: float=0.4858757062146893):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4858757062146893):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_666",
    "sat": "def sat(counts: List[int], target_prob: float=0.513189448441247):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.513189448441247):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_667",
    "sat": "def sat(counts: List[int], target_prob: float=0.18571428571428572):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18571428571428572):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_668",
    "sat": "def sat(counts: List[int], target_prob: float=0.41037735849056606):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41037735849056606):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_669",
    "sat": "def sat(counts: List[int], target_prob: float=0.088):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.088):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_670",
    "sat": "def sat(counts: List[int], target_prob: float=0.5206286836935167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5206286836935167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_671",
    "sat": "def sat(counts: List[int], target_prob: float=0.4031413612565445):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4031413612565445):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_672",
    "sat": "def sat(counts: List[int], target_prob: float=0.41935483870967744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41935483870967744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_673",
    "sat": "def sat(counts: List[int], target_prob: float=0.022339027595269383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.022339027595269383):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_674",
    "sat": "def sat(counts: List[int], target_prob: float=0.37163814180929094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37163814180929094):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_675",
    "sat": "def sat(counts: List[int], target_prob: float=0.853904282115869):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.853904282115869):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_676",
    "sat": "def sat(counts: List[int], target_prob: float=0.22320819112627988):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22320819112627988):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_677",
    "sat": "def sat(counts: List[int], target_prob: float=0.8032786885245902):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8032786885245902):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_678",
    "sat": "def sat(counts: List[int], target_prob: float=0.22935779816513763):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22935779816513763):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_679",
    "sat": "def sat(counts: List[int], target_prob: float=0.010273972602739725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.010273972602739725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_680",
    "sat": "def sat(counts: List[int], target_prob: float=0.1388888888888889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1388888888888889):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_681",
    "sat": "def sat(counts: List[int], target_prob: float=0.2564102564102564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2564102564102564):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_682",
    "sat": "def sat(counts: List[int], target_prob: float=0.13454545454545455):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13454545454545455):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_683",
    "sat": "def sat(counts: List[int], target_prob: float=0.6875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_684",
    "sat": "def sat(counts: List[int], target_prob: float=0.3893805309734513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3893805309734513):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_685",
    "sat": "def sat(counts: List[int], target_prob: float=0.4366616989567809):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4366616989567809):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_686",
    "sat": "def sat(counts: List[int], target_prob: float=0.012345679012345678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012345679012345678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_687",
    "sat": "def sat(counts: List[int], target_prob: float=0.35735735735735735):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35735735735735735):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_688",
    "sat": "def sat(counts: List[int], target_prob: float=0.109375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.109375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_689",
    "sat": "def sat(counts: List[int], target_prob: float=0.033634126333059886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.033634126333059886):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_690",
    "sat": "def sat(counts: List[int], target_prob: float=0.01276595744680851):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01276595744680851):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_691",
    "sat": "def sat(counts: List[int], target_prob: float=0.24597701149425288):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24597701149425288):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_692",
    "sat": "def sat(counts: List[int], target_prob: float=0.04046242774566474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04046242774566474):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_693",
    "sat": "def sat(counts: List[int], target_prob: float=0.020484171322160148):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.020484171322160148):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_694",
    "sat": "def sat(counts: List[int], target_prob: float=0.8496583143507973):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8496583143507973):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_695",
    "sat": "def sat(counts: List[int], target_prob: float=0.27514231499051234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27514231499051234):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_696",
    "sat": "def sat(counts: List[int], target_prob: float=0.06422018348623854):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06422018348623854):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_697",
    "sat": "def sat(counts: List[int], target_prob: float=0.6859504132231405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6859504132231405):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_698",
    "sat": "def sat(counts: List[int], target_prob: float=0.5407407407407407):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5407407407407407):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_699",
    "sat": "def sat(counts: List[int], target_prob: float=0.725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_700",
    "sat": "def sat(counts: List[int], target_prob: float=0.47540983606557374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47540983606557374):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_701",
    "sat": "def sat(counts: List[int], target_prob: float=0.175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.175):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_702",
    "sat": "def sat(counts: List[int], target_prob: float=0.3176470588235294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3176470588235294):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_703",
    "sat": "def sat(counts: List[int], target_prob: float=0.375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_704",
    "sat": "def sat(counts: List[int], target_prob: float=0.028368794326241134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.028368794326241134):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_705",
    "sat": "def sat(counts: List[int], target_prob: float=0.15384615384615385):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15384615384615385):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_706",
    "sat": "def sat(counts: List[int], target_prob: float=0.05514705882352941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05514705882352941):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_707",
    "sat": "def sat(counts: List[int], target_prob: float=0.8098859315589354):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8098859315589354):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_708",
    "sat": "def sat(counts: List[int], target_prob: float=0.21804511278195488):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21804511278195488):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_709",
    "sat": "def sat(counts: List[int], target_prob: float=0.41368078175895767):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41368078175895767):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_710",
    "sat": "def sat(counts: List[int], target_prob: float=0.2912621359223301):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2912621359223301):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_711",
    "sat": "def sat(counts: List[int], target_prob: float=0.16535433070866143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16535433070866143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_712",
    "sat": "def sat(counts: List[int], target_prob: float=0.002457002457002457):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.002457002457002457):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_713",
    "sat": "def sat(counts: List[int], target_prob: float=0.40762463343108507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40762463343108507):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_714",
    "sat": "def sat(counts: List[int], target_prob: float=0.07342657342657342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07342657342657342):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_715",
    "sat": "def sat(counts: List[int], target_prob: float=0.9365079365079365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9365079365079365):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_716",
    "sat": "def sat(counts: List[int], target_prob: float=0.1950207468879668):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1950207468879668):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_717",
    "sat": "def sat(counts: List[int], target_prob: float=0.0024449877750611247):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0024449877750611247):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_718",
    "sat": "def sat(counts: List[int], target_prob: float=0.17424242424242425):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17424242424242425):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_719",
    "sat": "def sat(counts: List[int], target_prob: float=0.8165938864628821):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8165938864628821):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_720",
    "sat": "def sat(counts: List[int], target_prob: float=0.45964912280701753):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45964912280701753):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_721",
    "sat": "def sat(counts: List[int], target_prob: float=0.15217391304347827):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15217391304347827):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_722",
    "sat": "def sat(counts: List[int], target_prob: float=0.5016611295681063):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5016611295681063):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_723",
    "sat": "def sat(counts: List[int], target_prob: float=0.423728813559322):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.423728813559322):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_724",
    "sat": "def sat(counts: List[int], target_prob: float=0.42168674698795183):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42168674698795183):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_725",
    "sat": "def sat(counts: List[int], target_prob: float=0.46511627906976744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46511627906976744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_726",
    "sat": "def sat(counts: List[int], target_prob: float=0.350253807106599):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.350253807106599):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_727",
    "sat": "def sat(counts: List[int], target_prob: float=0.021505376344086023):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.021505376344086023):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_728",
    "sat": "def sat(counts: List[int], target_prob: float=0.22077922077922077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22077922077922077):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_729",
    "sat": "def sat(counts: List[int], target_prob: float=0.5106382978723404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5106382978723404):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_730",
    "sat": "def sat(counts: List[int], target_prob: float=0.09650924024640657):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09650924024640657):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_731",
    "sat": "def sat(counts: List[int], target_prob: float=0.08536585365853659):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08536585365853659):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_732",
    "sat": "def sat(counts: List[int], target_prob: float=0.6274509803921569):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6274509803921569):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_733",
    "sat": "def sat(counts: List[int], target_prob: float=0.7872340425531915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7872340425531915):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_734",
    "sat": "def sat(counts: List[int], target_prob: float=0.14119922630560927):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14119922630560927):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_735",
    "sat": "def sat(counts: List[int], target_prob: float=0.8723404255319149):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8723404255319149):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_736",
    "sat": "def sat(counts: List[int], target_prob: float=0.2235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_737",
    "sat": "def sat(counts: List[int], target_prob: float=0.1694915254237288):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1694915254237288):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_738",
    "sat": "def sat(counts: List[int], target_prob: float=0.0036363636363636364):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0036363636363636364):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_739",
    "sat": "def sat(counts: List[int], target_prob: float=0.6235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_740",
    "sat": "def sat(counts: List[int], target_prob: float=0.676595744680851):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.676595744680851):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_741",
    "sat": "def sat(counts: List[int], target_prob: float=0.22044728434504793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22044728434504793):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_742",
    "sat": "def sat(counts: List[int], target_prob: float=0.24615384615384617):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24615384615384617):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_743",
    "sat": "def sat(counts: List[int], target_prob: float=0.4454828660436137):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4454828660436137):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_744",
    "sat": "def sat(counts: List[int], target_prob: float=0.6822429906542056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6822429906542056):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_745",
    "sat": "def sat(counts: List[int], target_prob: float=0.37089201877934275):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37089201877934275):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_746",
    "sat": "def sat(counts: List[int], target_prob: float=0.047619047619047616):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.047619047619047616):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_747",
    "sat": "def sat(counts: List[int], target_prob: float=0.7241379310344828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7241379310344828):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_748",
    "sat": "def sat(counts: List[int], target_prob: float=0.5909090909090909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5909090909090909):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_749",
    "sat": "def sat(counts: List[int], target_prob: float=0.027611044417767107):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.027611044417767107):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_750",
    "sat": "def sat(counts: List[int], target_prob: float=0.4134419551934827):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4134419551934827):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_751",
    "sat": "def sat(counts: List[int], target_prob: float=0.6228571428571429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6228571428571429):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_752",
    "sat": "def sat(counts: List[int], target_prob: float=0.03151862464183381):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03151862464183381):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_753",
    "sat": "def sat(counts: List[int], target_prob: float=0.8024691358024691):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8024691358024691):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_754",
    "sat": "def sat(counts: List[int], target_prob: float=0.47465437788018433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47465437788018433):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_755",
    "sat": "def sat(counts: List[int], target_prob: float=0.021621621621621623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.021621621621621623):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_756",
    "sat": "def sat(counts: List[int], target_prob: float=0.5510204081632653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5510204081632653):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_757",
    "sat": "def sat(counts: List[int], target_prob: float=0.13084745762711864):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13084745762711864):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_758",
    "sat": "def sat(counts: List[int], target_prob: float=0.053763440860215055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.053763440860215055):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_759",
    "sat": "def sat(counts: List[int], target_prob: float=0.39819004524886875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39819004524886875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_760",
    "sat": "def sat(counts: List[int], target_prob: float=0.7395833333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7395833333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_761",
    "sat": "def sat(counts: List[int], target_prob: float=0.03910614525139665):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03910614525139665):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_762",
    "sat": "def sat(counts: List[int], target_prob: float=0.0196078431372549):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0196078431372549):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_763",
    "sat": "def sat(counts: List[int], target_prob: float=0.3205944798301486):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3205944798301486):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_764",
    "sat": "def sat(counts: List[int], target_prob: float=0.3800738007380074):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3800738007380074):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_765",
    "sat": "def sat(counts: List[int], target_prob: float=0.22666666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22666666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_766",
    "sat": "def sat(counts: List[int], target_prob: float=0.4794520547945205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4794520547945205):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_767",
    "sat": "def sat(counts: List[int], target_prob: float=0.8695652173913043):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8695652173913043):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_768",
    "sat": "def sat(counts: List[int], target_prob: float=0.4088669950738916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4088669950738916):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_769",
    "sat": "def sat(counts: List[int], target_prob: float=0.06629834254143646):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06629834254143646):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_770",
    "sat": "def sat(counts: List[int], target_prob: float=0.5135135135135135):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5135135135135135):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_771",
    "sat": "def sat(counts: List[int], target_prob: float=0.6749116607773852):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6749116607773852):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_772",
    "sat": "def sat(counts: List[int], target_prob: float=0.06077348066298342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06077348066298342):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_773",
    "sat": "def sat(counts: List[int], target_prob: float=0.6111111111111112):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6111111111111112):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_774",
    "sat": "def sat(counts: List[int], target_prob: float=0.6973684210526315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6973684210526315):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_775",
    "sat": "def sat(counts: List[int], target_prob: float=0.27741935483870966):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27741935483870966):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_776",
    "sat": "def sat(counts: List[int], target_prob: float=0.043478260869565216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.043478260869565216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_777",
    "sat": "def sat(counts: List[int], target_prob: float=0.2794759825327511):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2794759825327511):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_778",
    "sat": "def sat(counts: List[int], target_prob: float=0.19736842105263158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19736842105263158):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_779",
    "sat": "def sat(counts: List[int], target_prob: float=0.9158576051779935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9158576051779935):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_780",
    "sat": "def sat(counts: List[int], target_prob: float=0.13074204946996468):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13074204946996468):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_781",
    "sat": "def sat(counts: List[int], target_prob: float=0.4795539033457249):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4795539033457249):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_782",
    "sat": "def sat(counts: List[int], target_prob: float=0.5707317073170731):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5707317073170731):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_783",
    "sat": "def sat(counts: List[int], target_prob: float=0.030303030303030304):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.030303030303030304):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_784",
    "sat": "def sat(counts: List[int], target_prob: float=0.6296296296296297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6296296296296297):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_785",
    "sat": "def sat(counts: List[int], target_prob: float=0.04072398190045249):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04072398190045249):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_786",
    "sat": "def sat(counts: List[int], target_prob: float=0.030162412993039442):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.030162412993039442):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_787",
    "sat": "def sat(counts: List[int], target_prob: float=0.2463768115942029):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2463768115942029):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_788",
    "sat": "def sat(counts: List[int], target_prob: float=0.36531365313653136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36531365313653136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_789",
    "sat": "def sat(counts: List[int], target_prob: float=0.3901098901098901):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3901098901098901):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_790",
    "sat": "def sat(counts: List[int], target_prob: float=0.38341158059467917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38341158059467917):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_791",
    "sat": "def sat(counts: List[int], target_prob: float=0.8113207547169812):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8113207547169812):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_792",
    "sat": "def sat(counts: List[int], target_prob: float=0.7313432835820896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7313432835820896):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_793",
    "sat": "def sat(counts: List[int], target_prob: float=0.8):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_794",
    "sat": "def sat(counts: List[int], target_prob: float=0.8495145631067961):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8495145631067961):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_795",
    "sat": "def sat(counts: List[int], target_prob: float=0.7083333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7083333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_796",
    "sat": "def sat(counts: List[int], target_prob: float=0.39568345323741005):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39568345323741005):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_797",
    "sat": "def sat(counts: List[int], target_prob: float=0.24561403508771928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24561403508771928):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_798",
    "sat": "def sat(counts: List[int], target_prob: float=0.725258493353028):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.725258493353028):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_799",
    "sat": "def sat(counts: List[int], target_prob: float=0.2863070539419087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2863070539419087):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_800",
    "sat": "def sat(counts: List[int], target_prob: float=0.48299319727891155):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48299319727891155):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_801",
    "sat": "def sat(counts: List[int], target_prob: float=0.7368421052631579):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7368421052631579):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_802",
    "sat": "def sat(counts: List[int], target_prob: float=0.7666666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7666666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_803",
    "sat": "def sat(counts: List[int], target_prob: float=0.08163265306122448):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08163265306122448):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_804",
    "sat": "def sat(counts: List[int], target_prob: float=0.05194805194805195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05194805194805195):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_805",
    "sat": "def sat(counts: List[int], target_prob: float=0.38095238095238093):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38095238095238093):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_806",
    "sat": "def sat(counts: List[int], target_prob: float=0.2786885245901639):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2786885245901639):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_807",
    "sat": "def sat(counts: List[int], target_prob: float=0.07853403141361257):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07853403141361257):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_808",
    "sat": "def sat(counts: List[int], target_prob: float=0.558974358974359):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.558974358974359):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_809",
    "sat": "def sat(counts: List[int], target_prob: float=0.042735042735042736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.042735042735042736):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_810",
    "sat": "def sat(counts: List[int], target_prob: float=0.027237354085603113):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.027237354085603113):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_811",
    "sat": "def sat(counts: List[int], target_prob: float=0.49206349206349204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49206349206349204):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_812",
    "sat": "def sat(counts: List[int], target_prob: float=0.04500381388253242):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04500381388253242):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_813",
    "sat": "def sat(counts: List[int], target_prob: float=0.6974789915966386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6974789915966386):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_814",
    "sat": "def sat(counts: List[int], target_prob: float=0.6938775510204082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6938775510204082):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_815",
    "sat": "def sat(counts: List[int], target_prob: float=0.5154639175257731):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5154639175257731):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_816",
    "sat": "def sat(counts: List[int], target_prob: float=0.8343949044585988):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8343949044585988):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_817",
    "sat": "def sat(counts: List[int], target_prob: float=0.30957372466806427):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30957372466806427):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_818",
    "sat": "def sat(counts: List[int], target_prob: float=0.9797979797979798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9797979797979798):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_819",
    "sat": "def sat(counts: List[int], target_prob: float=0.0079155672823219):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0079155672823219):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_820",
    "sat": "def sat(counts: List[int], target_prob: float=0.46055979643765904):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46055979643765904):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_821",
    "sat": "def sat(counts: List[int], target_prob: float=0.14186851211072665):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14186851211072665):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_822",
    "sat": "def sat(counts: List[int], target_prob: float=0.23333333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23333333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_823",
    "sat": "def sat(counts: List[int], target_prob: float=0.7981651376146789):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7981651376146789):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_824",
    "sat": "def sat(counts: List[int], target_prob: float=0.9283387622149837):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9283387622149837):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_825",
    "sat": "def sat(counts: List[int], target_prob: float=0.5760869565217391):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5760869565217391):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_826",
    "sat": "def sat(counts: List[int], target_prob: float=0.8048780487804879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8048780487804879):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_827",
    "sat": "def sat(counts: List[int], target_prob: float=0.23626373626373626):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23626373626373626):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_828",
    "sat": "def sat(counts: List[int], target_prob: float=0.3783783783783784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3783783783783784):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_829",
    "sat": "def sat(counts: List[int], target_prob: float=0.20987654320987653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20987654320987653):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_830",
    "sat": "def sat(counts: List[int], target_prob: float=0.5609756097560976):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5609756097560976):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_831",
    "sat": "def sat(counts: List[int], target_prob: float=0.05519480519480519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05519480519480519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_832",
    "sat": "def sat(counts: List[int], target_prob: float=0.14345991561181434):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14345991561181434):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_833",
    "sat": "def sat(counts: List[int], target_prob: float=0.8909090909090909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8909090909090909):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_834",
    "sat": "def sat(counts: List[int], target_prob: float=0.5319148936170213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5319148936170213):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_835",
    "sat": "def sat(counts: List[int], target_prob: float=0.7437325905292479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7437325905292479):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_836",
    "sat": "def sat(counts: List[int], target_prob: float=0.6343115124153499):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6343115124153499):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_837",
    "sat": "def sat(counts: List[int], target_prob: float=0.978021978021978):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.978021978021978):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_838",
    "sat": "def sat(counts: List[int], target_prob: float=0.1791044776119403):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1791044776119403):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_839",
    "sat": "def sat(counts: List[int], target_prob: float=0.3197278911564626):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3197278911564626):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_840",
    "sat": "def sat(counts: List[int], target_prob: float=0.631578947368421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.631578947368421):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_841",
    "sat": "def sat(counts: List[int], target_prob: float=0.1673469387755102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1673469387755102):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_842",
    "sat": "def sat(counts: List[int], target_prob: float=0.062111801242236024):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.062111801242236024):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_843",
    "sat": "def sat(counts: List[int], target_prob: float=0.3114754098360656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3114754098360656):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_844",
    "sat": "def sat(counts: List[int], target_prob: float=0.08393285371702638):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08393285371702638):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_845",
    "sat": "def sat(counts: List[int], target_prob: float=0.11450381679389313):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11450381679389313):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_846",
    "sat": "def sat(counts: List[int], target_prob: float=0.07428571428571429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07428571428571429):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_847",
    "sat": "def sat(counts: List[int], target_prob: float=0.06818181818181818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06818181818181818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_848",
    "sat": "def sat(counts: List[int], target_prob: float=0.859375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.859375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_849",
    "sat": "def sat(counts: List[int], target_prob: float=0.7894736842105263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7894736842105263):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_850",
    "sat": "def sat(counts: List[int], target_prob: float=0.4782608695652174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4782608695652174):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_851",
    "sat": "def sat(counts: List[int], target_prob: float=0.4489795918367347):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4489795918367347):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_852",
    "sat": "def sat(counts: List[int], target_prob: float=0.29449838187702265):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29449838187702265):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_853",
    "sat": "def sat(counts: List[int], target_prob: float=0.14893617021276595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14893617021276595):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_854",
    "sat": "def sat(counts: List[int], target_prob: float=0.12987012987012986):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12987012987012986):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_855",
    "sat": "def sat(counts: List[int], target_prob: float=0.44025157232704404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44025157232704404):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_856",
    "sat": "def sat(counts: List[int], target_prob: float=0.9754098360655737):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9754098360655737):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_857",
    "sat": "def sat(counts: List[int], target_prob: float=0.7341772151898734):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7341772151898734):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_858",
    "sat": "def sat(counts: List[int], target_prob: float=0.3670886075949367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3670886075949367):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_859",
    "sat": "def sat(counts: List[int], target_prob: float=0.7455968688845401):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7455968688845401):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_860",
    "sat": "def sat(counts: List[int], target_prob: float=0.48747591522157996):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48747591522157996):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_861",
    "sat": "def sat(counts: List[int], target_prob: float=0.6074766355140186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6074766355140186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_862",
    "sat": "def sat(counts: List[int], target_prob: float=0.23404255319148937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23404255319148937):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_863",
    "sat": "def sat(counts: List[int], target_prob: float=0.10704960835509138):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10704960835509138):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_864",
    "sat": "def sat(counts: List[int], target_prob: float=0.12844036697247707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12844036697247707):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_865",
    "sat": "def sat(counts: List[int], target_prob: float=0.78125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.78125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_866",
    "sat": "def sat(counts: List[int], target_prob: float=0.018404907975460124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.018404907975460124):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_867",
    "sat": "def sat(counts: List[int], target_prob: float=0.4603174603174603):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4603174603174603):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_868",
    "sat": "def sat(counts: List[int], target_prob: float=0.7738095238095238):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7738095238095238):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_869",
    "sat": "def sat(counts: List[int], target_prob: float=0.23937360178970918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23937360178970918):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_870",
    "sat": "def sat(counts: List[int], target_prob: float=0.23735408560311283):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23735408560311283):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_871",
    "sat": "def sat(counts: List[int], target_prob: float=0.39299610894941633):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39299610894941633):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_872",
    "sat": "def sat(counts: List[int], target_prob: float=0.5066666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5066666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_873",
    "sat": "def sat(counts: List[int], target_prob: float=0.6453900709219859):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6453900709219859):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_874",
    "sat": "def sat(counts: List[int], target_prob: float=0.27586206896551724):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27586206896551724):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_875",
    "sat": "def sat(counts: List[int], target_prob: float=0.36597938144329895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36597938144329895):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_876",
    "sat": "def sat(counts: List[int], target_prob: float=0.19205298013245034):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19205298013245034):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_877",
    "sat": "def sat(counts: List[int], target_prob: float=0.5703703703703704):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5703703703703704):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_878",
    "sat": "def sat(counts: List[int], target_prob: float=0.627906976744186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.627906976744186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_879",
    "sat": "def sat(counts: List[int], target_prob: float=0.48148148148148145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48148148148148145):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_880",
    "sat": "def sat(counts: List[int], target_prob: float=0.2422907488986784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2422907488986784):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_881",
    "sat": "def sat(counts: List[int], target_prob: float=0.6747404844290658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6747404844290658):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_882",
    "sat": "def sat(counts: List[int], target_prob: float=0.6244897959183674):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6244897959183674):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_883",
    "sat": "def sat(counts: List[int], target_prob: float=0.2009400705052879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2009400705052879):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_884",
    "sat": "def sat(counts: List[int], target_prob: float=0.3805970149253731):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3805970149253731):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_885",
    "sat": "def sat(counts: List[int], target_prob: float=0.34814814814814815):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34814814814814815):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_886",
    "sat": "def sat(counts: List[int], target_prob: float=0.5834266517357223):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5834266517357223):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_887",
    "sat": "def sat(counts: List[int], target_prob: float=0.17010816125860373):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17010816125860373):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_888",
    "sat": "def sat(counts: List[int], target_prob: float=0.0473186119873817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0473186119873817):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_889",
    "sat": "def sat(counts: List[int], target_prob: float=0.5945945945945946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5945945945945946):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_890",
    "sat": "def sat(counts: List[int], target_prob: float=0.5324675324675324):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5324675324675324):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_891",
    "sat": "def sat(counts: List[int], target_prob: float=0.8805970149253731):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8805970149253731):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_892",
    "sat": "def sat(counts: List[int], target_prob: float=0.44352617079889806):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44352617079889806):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_893",
    "sat": "def sat(counts: List[int], target_prob: float=0.2874880611270296):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2874880611270296):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_894",
    "sat": "def sat(counts: List[int], target_prob: float=0.797752808988764):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.797752808988764):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_895",
    "sat": "def sat(counts: List[int], target_prob: float=0.9060402684563759):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9060402684563759):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_896",
    "sat": "def sat(counts: List[int], target_prob: float=0.457286432160804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.457286432160804):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_897",
    "sat": "def sat(counts: List[int], target_prob: float=0.10101010101010101):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10101010101010101):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_898",
    "sat": "def sat(counts: List[int], target_prob: float=0.16363636363636364):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16363636363636364):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_899",
    "sat": "def sat(counts: List[int], target_prob: float=0.03398926654740608):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03398926654740608):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_900",
    "sat": "def sat(counts: List[int], target_prob: float=0.2072072072072072):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2072072072072072):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_901",
    "sat": "def sat(counts: List[int], target_prob: float=0.18452380952380953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18452380952380953):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_902",
    "sat": "def sat(counts: List[int], target_prob: float=0.8441558441558441):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8441558441558441):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_903",
    "sat": "def sat(counts: List[int], target_prob: float=0.0375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_904",
    "sat": "def sat(counts: List[int], target_prob: float=0.049019607843137254):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.049019607843137254):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_905",
    "sat": "def sat(counts: List[int], target_prob: float=0.5102040816326531):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5102040816326531):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_906",
    "sat": "def sat(counts: List[int], target_prob: float=0.8155339805825242):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8155339805825242):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_907",
    "sat": "def sat(counts: List[int], target_prob: float=0.5706806282722513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5706806282722513):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_908",
    "sat": "def sat(counts: List[int], target_prob: float=0.6424581005586593):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6424581005586593):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_909",
    "sat": "def sat(counts: List[int], target_prob: float=0.9121951219512195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9121951219512195):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_910",
    "sat": "def sat(counts: List[int], target_prob: float=0.12038523274478331):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12038523274478331):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_911",
    "sat": "def sat(counts: List[int], target_prob: float=0.707641196013289):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.707641196013289):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_912",
    "sat": "def sat(counts: List[int], target_prob: float=0.25925925925925924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25925925925925924):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_913",
    "sat": "def sat(counts: List[int], target_prob: float=0.189873417721519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.189873417721519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_914",
    "sat": "def sat(counts: List[int], target_prob: float=0.10434782608695652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10434782608695652):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_915",
    "sat": "def sat(counts: List[int], target_prob: float=0.9088145896656535):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9088145896656535):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_916",
    "sat": "def sat(counts: List[int], target_prob: float=0.34782608695652173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34782608695652173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_917",
    "sat": "def sat(counts: List[int], target_prob: float=0.02912621359223301):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02912621359223301):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_918",
    "sat": "def sat(counts: List[int], target_prob: float=0.012658227848101266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012658227848101266):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_919",
    "sat": "def sat(counts: List[int], target_prob: float=0.09508196721311475):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09508196721311475):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_920",
    "sat": "def sat(counts: List[int], target_prob: float=0.04424778761061947):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04424778761061947):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_921",
    "sat": "def sat(counts: List[int], target_prob: float=0.5709969788519638):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5709969788519638):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_922",
    "sat": "def sat(counts: List[int], target_prob: float=0.8984771573604061):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8984771573604061):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_923",
    "sat": "def sat(counts: List[int], target_prob: float=0.532033426183844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.532033426183844):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_924",
    "sat": "def sat(counts: List[int], target_prob: float=0.6454545454545455):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6454545454545455):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_925",
    "sat": "def sat(counts: List[int], target_prob: float=0.6379310344827587):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6379310344827587):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_926",
    "sat": "def sat(counts: List[int], target_prob: float=0.8412698412698413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8412698412698413):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_927",
    "sat": "def sat(counts: List[int], target_prob: float=0.4214876033057851):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4214876033057851):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_928",
    "sat": "def sat(counts: List[int], target_prob: float=0.07567964731814843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07567964731814843):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_929",
    "sat": "def sat(counts: List[int], target_prob: float=0.2695214105793451):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2695214105793451):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_930",
    "sat": "def sat(counts: List[int], target_prob: float=0.7402597402597403):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7402597402597403):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_931",
    "sat": "def sat(counts: List[int], target_prob: float=0.33064516129032256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.33064516129032256):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_932",
    "sat": "def sat(counts: List[int], target_prob: float=0.2079207920792079):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2079207920792079):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_933",
    "sat": "def sat(counts: List[int], target_prob: float=0.1557632398753894):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1557632398753894):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_934",
    "sat": "def sat(counts: List[int], target_prob: float=0.39879759519038077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39879759519038077):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_935",
    "sat": "def sat(counts: List[int], target_prob: float=0.3245469522240527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3245469522240527):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_936",
    "sat": "def sat(counts: List[int], target_prob: float=0.04899135446685879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04899135446685879):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_937",
    "sat": "def sat(counts: List[int], target_prob: float=0.06944444444444445):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06944444444444445):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_938",
    "sat": "def sat(counts: List[int], target_prob: float=0.6018957345971564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6018957345971564):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_939",
    "sat": "def sat(counts: List[int], target_prob: float=0.16279069767441862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16279069767441862):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_940",
    "sat": "def sat(counts: List[int], target_prob: float=0.5126050420168067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5126050420168067):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_941",
    "sat": "def sat(counts: List[int], target_prob: float=0.8736842105263158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8736842105263158):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_942",
    "sat": "def sat(counts: List[int], target_prob: float=0.4759825327510917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4759825327510917):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_943",
    "sat": "def sat(counts: List[int], target_prob: float=0.037037037037037035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.037037037037037035):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_944",
    "sat": "def sat(counts: List[int], target_prob: float=0.22831858407079647):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22831858407079647):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_945",
    "sat": "def sat(counts: List[int], target_prob: float=0.19210053859964094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19210053859964094):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_946",
    "sat": "def sat(counts: List[int], target_prob: float=0.48717948717948717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48717948717948717):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_947",
    "sat": "def sat(counts: List[int], target_prob: float=0.8782608695652174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8782608695652174):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_948",
    "sat": "def sat(counts: List[int], target_prob: float=0.19658119658119658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19658119658119658):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_949",
    "sat": "def sat(counts: List[int], target_prob: float=0.2975609756097561):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2975609756097561):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_950",
    "sat": "def sat(counts: List[int], target_prob: float=0.5517241379310345):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5517241379310345):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_951",
    "sat": "def sat(counts: List[int], target_prob: float=0.3263157894736842):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3263157894736842):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_952",
    "sat": "def sat(counts: List[int], target_prob: float=0.9236111111111112):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9236111111111112):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_953",
    "sat": "def sat(counts: List[int], target_prob: float=0.4168714168714169):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4168714168714169):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_954",
    "sat": "def sat(counts: List[int], target_prob: float=0.658008658008658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.658008658008658):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_955",
    "sat": "def sat(counts: List[int], target_prob: float=0.21212121212121213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21212121212121213):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_956",
    "sat": "def sat(counts: List[int], target_prob: float=0.19230769230769232):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19230769230769232):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_957",
    "sat": "def sat(counts: List[int], target_prob: float=0.6644295302013423):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6644295302013423):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_958",
    "sat": "def sat(counts: List[int], target_prob: float=0.8601398601398601):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8601398601398601):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_959",
    "sat": "def sat(counts: List[int], target_prob: float=0.09515260323159784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09515260323159784):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_960",
    "sat": "def sat(counts: List[int], target_prob: float=0.6025641025641025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6025641025641025):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_961",
    "sat": "def sat(counts: List[int], target_prob: float=0.3790322580645161):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3790322580645161):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_962",
    "sat": "def sat(counts: List[int], target_prob: float=0.31086142322097376):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31086142322097376):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_963",
    "sat": "def sat(counts: List[int], target_prob: float=0.07971014492753623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07971014492753623):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_964",
    "sat": "def sat(counts: List[int], target_prob: float=0.3231197771587744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3231197771587744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_965",
    "sat": "def sat(counts: List[int], target_prob: float=0.33047210300429186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.33047210300429186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_966",
    "sat": "def sat(counts: List[int], target_prob: float=0.15):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_967",
    "sat": "def sat(counts: List[int], target_prob: float=0.19148936170212766):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19148936170212766):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_968",
    "sat": "def sat(counts: List[int], target_prob: float=0.4840764331210191):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4840764331210191):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_969",
    "sat": "def sat(counts: List[int], target_prob: float=0.8738170347003155):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8738170347003155):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_970",
    "sat": "def sat(counts: List[int], target_prob: float=0.4048059149722736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4048059149722736):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_971",
    "sat": "def sat(counts: List[int], target_prob: float=0.6410256410256411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6410256410256411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_972",
    "sat": "def sat(counts: List[int], target_prob: float=0.5294117647058824):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5294117647058824):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_973",
    "sat": "def sat(counts: List[int], target_prob: float=0.28859060402684567):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28859060402684567):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_974",
    "sat": "def sat(counts: List[int], target_prob: float=0.2368839427662957):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2368839427662957):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_975",
    "sat": "def sat(counts: List[int], target_prob: float=0.12883435582822086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12883435582822086):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_976",
    "sat": "def sat(counts: List[int], target_prob: float=0.14644351464435146):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14644351464435146):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_977",
    "sat": "def sat(counts: List[int], target_prob: float=0.18875502008032127):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18875502008032127):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_978",
    "sat": "def sat(counts: List[int], target_prob: float=0.06222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_979",
    "sat": "def sat(counts: List[int], target_prob: float=0.8192090395480226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8192090395480226):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_980",
    "sat": "def sat(counts: List[int], target_prob: float=0.328719723183391):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.328719723183391):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_981",
    "sat": "def sat(counts: List[int], target_prob: float=0.19242902208201892):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19242902208201892):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_982",
    "sat": "def sat(counts: List[int], target_prob: float=0.02304147465437788):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02304147465437788):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_983",
    "sat": "def sat(counts: List[int], target_prob: float=0.5687022900763359):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5687022900763359):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_984",
    "sat": "def sat(counts: List[int], target_prob: float=0.5526315789473685):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5526315789473685):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_985",
    "sat": "def sat(counts: List[int], target_prob: float=0.10629067245119306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10629067245119306):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_986",
    "sat": "def sat(counts: List[int], target_prob: float=0.010752688172043012):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.010752688172043012):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_987",
    "sat": "def sat(counts: List[int], target_prob: float=0.37168141592920356):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37168141592920356):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_988",
    "sat": "def sat(counts: List[int], target_prob: float=0.0728476821192053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0728476821192053):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_989",
    "sat": "def sat(counts: List[int], target_prob: float=0.15584415584415584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15584415584415584):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_990",
    "sat": "def sat(counts: List[int], target_prob: float=0.3895131086142322):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3895131086142322):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_991",
    "sat": "def sat(counts: List[int], target_prob: float=0.30337078651685395):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30337078651685395):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_992",
    "sat": "def sat(counts: List[int], target_prob: float=0.11515151515151516):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11515151515151516):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_993",
    "sat": "def sat(counts: List[int], target_prob: float=0.10112359550561797):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10112359550561797):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_994",
    "sat": "def sat(counts: List[int], target_prob: float=0.012084592145015106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012084592145015106):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_995",
    "sat": "def sat(counts: List[int], target_prob: float=0.8159509202453987):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8159509202453987):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_996",
    "sat": "def sat(counts: List[int], target_prob: float=0.020172910662824207):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.020172910662824207):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_997",
    "sat": "def sat(counts: List[int], target_prob: float=0.8620689655172413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8620689655172413):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_998",
    "sat": "def sat(counts: List[int], target_prob: float=0.8532110091743119):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8532110091743119):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_999",
    "sat": "def sat(counts: List[int], target_prob: float=0.5951972555746141):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5951972555746141):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BinomialProbabilities_0",
    "sat": "def sat(counts: List[int], p: float=0.5, target_prob: float=0.0625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5, target_prob=0.0625):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_1",
    "sat": "def sat(counts: List[int], p: float=0.3452343004309807, target_prob: float=0.31726898872962117):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3452343004309807, target_prob=0.31726898872962117):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_2",
    "sat": "def sat(counts: List[int], p: float=0.3121284489098024, target_prob: float=0.2884173260774914):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3121284489098024, target_prob=0.2884173260774914):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_3",
    "sat": "def sat(counts: List[int], p: float=0.9135496051310837, target_prob: float=0.0068183615324295755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9135496051310837, target_prob=0.0068183615324295755):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_4",
    "sat": "def sat(counts: List[int], p: float=0.8568197575262302, target_prob: float=0.14318024247376981):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8568197575262302, target_prob=0.14318024247376981):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_5",
    "sat": "def sat(counts: List[int], p: float=0.23631395351201356, target_prob: float=0.0033768590668579656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23631395351201356, target_prob=0.0033768590668579656):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_6",
    "sat": "def sat(counts: List[int], p: float=0.43413475319404515, target_prob: float=0.43413475319404515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43413475319404515, target_prob=0.43413475319404515):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_7",
    "sat": "def sat(counts: List[int], p: float=0.5758445352859833, target_prob: float=0.004009151775510598):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5758445352859833, target_prob=0.004009151775510598):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_8",
    "sat": "def sat(counts: List[int], p: float=0.49841508704492177, target_prob: float=0.5015849129550782):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49841508704492177, target_prob=0.5015849129550782):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_9",
    "sat": "def sat(counts: List[int], p: float=0.3474571101762658, target_prob: float=0.32834462649513385):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3474571101762658, target_prob=0.32834462649513385):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_10",
    "sat": "def sat(counts: List[int], p: float=0.1050845162150209, target_prob: float=0.8949154837849791):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1050845162150209, target_prob=0.8949154837849791):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_11",
    "sat": "def sat(counts: List[int], p: float=0.1589662222912761, target_prob: float=0.7073378152470072):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1589662222912761, target_prob=0.7073378152470072):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_12",
    "sat": "def sat(counts: List[int], p: float=0.44159119147790404, target_prob: float=0.08611151013431051):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44159119147790404, target_prob=0.08611151013431051):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_13",
    "sat": "def sat(counts: List[int], p: float=0.03461910253022016, target_prob: float=0.010782704729772557):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03461910253022016, target_prob=0.010782704729772557):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_14",
    "sat": "def sat(counts: List[int], p: float=0.3454086440727381, target_prob: float=0.3346394993251647):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3454086440727381, target_prob=0.3346394993251647):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_15",
    "sat": "def sat(counts: List[int], p: float=0.17079341245232582, target_prob: float=0.0007230520689255174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17079341245232582, target_prob=0.0007230520689255174):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_16",
    "sat": "def sat(counts: List[int], p: float=0.6919656375587177, target_prob: float=0.25966186246253714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6919656375587177, target_prob=0.25966186246253714):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_17",
    "sat": "def sat(counts: List[int], p: float=0.6353407433850333, target_prob: float=0.6353407433850333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6353407433850333, target_prob=0.6353407433850333):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_18",
    "sat": "def sat(counts: List[int], p: float=0.2334018922785963, target_prob: float=0.35785089791873365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2334018922785963, target_prob=0.35785089791873365):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_19",
    "sat": "def sat(counts: List[int], p: float=0.7998692480422049, target_prob: float=0.02648894595337267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7998692480422049, target_prob=0.02648894595337267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_20",
    "sat": "def sat(counts: List[int], p: float=0.4957533981527156, target_prob: float=0.04622615322885958):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4957533981527156, target_prob=0.04622615322885958):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_21",
    "sat": "def sat(counts: List[int], p: float=0.5555307452797709, target_prob: float=0.03902715556502076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5555307452797709, target_prob=0.03902715556502076):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_22",
    "sat": "def sat(counts: List[int], p: float=0.9206701705178687, target_prob: float=0.10731378354408072):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9206701705178687, target_prob=0.10731378354408072):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_23",
    "sat": "def sat(counts: List[int], p: float=0.41128984675118185, target_prob: float=0.2043452637664479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41128984675118185, target_prob=0.2043452637664479):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_24",
    "sat": "def sat(counts: List[int], p: float=0.8008451064813836, target_prob: float=0.3677732852582821):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8008451064813836, target_prob=0.3677732852582821):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_25",
    "sat": "def sat(counts: List[int], p: float=0.7725387862296671, target_prob: float=0.2101469544603423):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7725387862296671, target_prob=0.2101469544603423):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_26",
    "sat": "def sat(counts: List[int], p: float=0.6256083826785956, target_prob: float=0.00014452236051121266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6256083826785956, target_prob=0.00014452236051121266):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_27",
    "sat": "def sat(counts: List[int], p: float=0.3112448190231223, target_prob: float=0.18327509884983906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3112448190231223, target_prob=0.18327509884983906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_28",
    "sat": "def sat(counts: List[int], p: float=0.13693353676344766, target_prob: float=0.5548517562668871):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13693353676344766, target_prob=0.5548517562668871):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_29",
    "sat": "def sat(counts: List[int], p: float=0.47956084062026416, target_prob: float=0.11028873067181347):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47956084062026416, target_prob=0.11028873067181347):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_30",
    "sat": "def sat(counts: List[int], p: float=0.18624812792070156, target_prob: float=0.39875227144080383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18624812792070156, target_prob=0.39875227144080383):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_31",
    "sat": "def sat(counts: List[int], p: float=0.6857065601360459, target_prob: float=0.24022998298885423):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6857065601360459, target_prob=0.24022998298885423):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_32",
    "sat": "def sat(counts: List[int], p: float=0.7041762051428041, target_prob: float=0.25101175917030055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7041762051428041, target_prob=0.25101175917030055):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_33",
    "sat": "def sat(counts: List[int], p: float=0.5248317668561273, target_prob: float=0.18025937420434315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5248317668561273, target_prob=0.18025937420434315):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_34",
    "sat": "def sat(counts: List[int], p: float=0.046212986723797145, target_prob: float=0.16039035307103097):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.046212986723797145, target_prob=0.16039035307103097):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_35",
    "sat": "def sat(counts: List[int], p: float=0.9826900674137863, target_prob: float=0.06570600571311755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9826900674137863, target_prob=0.06570600571311755):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_36",
    "sat": "def sat(counts: List[int], p: float=0.5130793672143239, target_prob: float=0.23709170263240323):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5130793672143239, target_prob=0.23709170263240323):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_37",
    "sat": "def sat(counts: List[int], p: float=0.49017964864713237, target_prob: float=0.0067996558644915555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49017964864713237, target_prob=0.0067996558644915555):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_38",
    "sat": "def sat(counts: List[int], p: float=0.38340528712360833, target_prob: float=0.2601670887063939):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38340528712360833, target_prob=0.2601670887063939):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_39",
    "sat": "def sat(counts: List[int], p: float=0.17412795173697426, target_prob: float=0.17412795173697426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17412795173697426, target_prob=0.17412795173697426):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_40",
    "sat": "def sat(counts: List[int], p: float=0.12225284653310398, target_prob: float=0.05331042142385485):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12225284653310398, target_prob=0.05331042142385485):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_41",
    "sat": "def sat(counts: List[int], p: float=0.9863712837937977, target_prob: float=0.9863712837937977):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9863712837937977, target_prob=0.9863712837937977):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_42",
    "sat": "def sat(counts: List[int], p: float=0.3175890145973108, target_prob: float=0.21345755616888937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3175890145973108, target_prob=0.21345755616888937):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_43",
    "sat": "def sat(counts: List[int], p: float=0.6797213762600564, target_prob: float=0.0006773249391797908):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6797213762600564, target_prob=0.0006773249391797908):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_44",
    "sat": "def sat(counts: List[int], p: float=0.46070366136467245, target_prob: float=0.048899447635094066):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46070366136467245, target_prob=0.048899447635094066):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_45",
    "sat": "def sat(counts: List[int], p: float=0.8616419959682837, target_prob: float=0.13835800403171628):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8616419959682837, target_prob=0.13835800403171628):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_46",
    "sat": "def sat(counts: List[int], p: float=0.497190006187307, target_prob: float=0.502809993812693):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.497190006187307, target_prob=0.502809993812693):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_47",
    "sat": "def sat(counts: List[int], p: float=0.5966795390292787, target_prob: float=0.022250336126440638):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5966795390292787, target_prob=0.022250336126440638):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_48",
    "sat": "def sat(counts: List[int], p: float=0.0017028969855321652, target_prob: float=0.01511852327049543):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0017028969855321652, target_prob=0.01511852327049543):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_49",
    "sat": "def sat(counts: List[int], p: float=0.42736367465024605, target_prob: float=0.24699210953435913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42736367465024605, target_prob=0.24699210953435913):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_50",
    "sat": "def sat(counts: List[int], p: float=0.9149552717100866, target_prob: float=5.231058680147436e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9149552717100866, target_prob=5.231058680147436e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_51",
    "sat": "def sat(counts: List[int], p: float=0.045832604059266924, target_prob: float=0.18995154387140578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.045832604059266924, target_prob=0.18995154387140578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_52",
    "sat": "def sat(counts: List[int], p: float=0.8550459901888153, target_prob: float=0.056979238891807595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8550459901888153, target_prob=0.056979238891807595):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_53",
    "sat": "def sat(counts: List[int], p: float=0.06903834939954945, target_prob: float=0.00029533603483783595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06903834939954945, target_prob=0.00029533603483783595):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_54",
    "sat": "def sat(counts: List[int], p: float=0.5664546078116807, target_prob: float=0.006640601954013782):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5664546078116807, target_prob=0.006640601954013782):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_55",
    "sat": "def sat(counts: List[int], p: float=0.7561732090573372, target_prob: float=0.5717979220960714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7561732090573372, target_prob=0.5717979220960714):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_56",
    "sat": "def sat(counts: List[int], p: float=0.03528620677548133, target_prob: float=0.0012451163886020248):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03528620677548133, target_prob=0.0012451163886020248):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_57",
    "sat": "def sat(counts: List[int], p: float=0.17808200896286175, target_prob: float=0.004133126299245905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17808200896286175, target_prob=0.004133126299245905):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_58",
    "sat": "def sat(counts: List[int], p: float=0.26429055390936584, target_prob: float=0.25844640454061424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26429055390936584, target_prob=0.25844640454061424):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_59",
    "sat": "def sat(counts: List[int], p: float=0.5067924046030077, target_prob: float=0.06564036515409402):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5067924046030077, target_prob=0.06564036515409402):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_60",
    "sat": "def sat(counts: List[int], p: float=0.6345212190891756, target_prob: float=0.46380808322952405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6345212190891756, target_prob=0.46380808322952405):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_61",
    "sat": "def sat(counts: List[int], p: float=0.40967661152869705, target_prob: float=0.20847613434935436):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40967661152869705, target_prob=0.20847613434935436):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_62",
    "sat": "def sat(counts: List[int], p: float=0.9255793883725091, target_prob: float=0.46146285423921):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9255793883725091, target_prob=0.46146285423921):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_63",
    "sat": "def sat(counts: List[int], p: float=0.9619710218290136, target_prob: float=0.18796450912103924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9619710218290136, target_prob=0.18796450912103924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_64",
    "sat": "def sat(counts: List[int], p: float=0.5272802899872631, target_prob: float=0.0772976249406893):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5272802899872631, target_prob=0.0772976249406893):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_65",
    "sat": "def sat(counts: List[int], p: float=0.8999066245737788, target_prob: float=0.5311102622633002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8999066245737788, target_prob=0.5311102622633002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_66",
    "sat": "def sat(counts: List[int], p: float=0.8747516690097348, target_prob: float=0.09240395214879102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8747516690097348, target_prob=0.09240395214879102):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_67",
    "sat": "def sat(counts: List[int], p: float=0.16690898437640755, target_prob: float=0.3485473868859317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16690898437640755, target_prob=0.3485473868859317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_68",
    "sat": "def sat(counts: List[int], p: float=0.7439769578907186, target_prob: float=0.7439769578907186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7439769578907186, target_prob=0.7439769578907186):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_69",
    "sat": "def sat(counts: List[int], p: float=0.423539669174256, target_prob: float=0.007029506547366783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.423539669174256, target_prob=0.007029506547366783):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_70",
    "sat": "def sat(counts: List[int], p: float=0.5042389970772566, target_prob: float=0.0018090528536029067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5042389970772566, target_prob=0.0018090528536029067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_71",
    "sat": "def sat(counts: List[int], p: float=0.894389243980324, target_prob: float=0.0011779434853951781):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.894389243980324, target_prob=0.0011779434853951781):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_72",
    "sat": "def sat(counts: List[int], p: float=0.8098880059520288, target_prob: float=1.70638151100826e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8098880059520288, target_prob=1.70638151100826e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_73",
    "sat": "def sat(counts: List[int], p: float=0.9922879561084333, target_prob: float=1.4926179168763638e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9922879561084333, target_prob=1.4926179168763638e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_74",
    "sat": "def sat(counts: List[int], p: float=0.3895801786937221, target_prob: float=0.6104198213062779):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3895801786937221, target_prob=0.6104198213062779):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_75",
    "sat": "def sat(counts: List[int], p: float=0.21456256204221302, target_prob: float=0.39709863783448174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21456256204221302, target_prob=0.39709863783448174):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_76",
    "sat": "def sat(counts: List[int], p: float=0.03110675646888228, target_prob: float=2.8182732869271378e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03110675646888228, target_prob=2.8182732869271378e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_77",
    "sat": "def sat(counts: List[int], p: float=0.8692937784809545, target_prob: float=0.43151850887474996):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8692937784809545, target_prob=0.43151850887474996):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_78",
    "sat": "def sat(counts: List[int], p: float=0.7842090343129554, target_prob: float=0.2965918452209758):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7842090343129554, target_prob=0.2965918452209758):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_79",
    "sat": "def sat(counts: List[int], p: float=0.2712231783086213, target_prob: float=0.5311156558345875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2712231783086213, target_prob=0.5311156558345875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_80",
    "sat": "def sat(counts: List[int], p: float=0.1295550677450763, target_prob: float=0.0032017799771703777):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1295550677450763, target_prob=0.0032017799771703777):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_81",
    "sat": "def sat(counts: List[int], p: float=0.5133412056536433, target_prob: float=0.15106172044438695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5133412056536433, target_prob=0.15106172044438695):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_82",
    "sat": "def sat(counts: List[int], p: float=0.7129777946438842, target_prob: float=0.0019479485648659254):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7129777946438842, target_prob=0.0019479485648659254):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_83",
    "sat": "def sat(counts: List[int], p: float=0.9798699841960997, target_prob: float=0.03944959653527001):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9798699841960997, target_prob=0.03944959653527001):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_84",
    "sat": "def sat(counts: List[int], p: float=0.2576962451617333, target_prob: float=0.7423037548382667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2576962451617333, target_prob=0.7423037548382667):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_85",
    "sat": "def sat(counts: List[int], p: float=0.9889848590076753, target_prob: float=0.002410724765305584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9889848590076753, target_prob=0.002410724765305584):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_86",
    "sat": "def sat(counts: List[int], p: float=0.9636426324157201, target_prob: float=0.011828587262486116):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9636426324157201, target_prob=0.011828587262486116):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_87",
    "sat": "def sat(counts: List[int], p: float=0.6056916955316077, target_prob: float=0.003185528675735002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6056916955316077, target_prob=0.003185528675735002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_88",
    "sat": "def sat(counts: List[int], p: float=0.4261580465290642, target_prob: float=0.04509740708810176):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4261580465290642, target_prob=0.04509740708810176):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_89",
    "sat": "def sat(counts: List[int], p: float=0.4296281304451972, target_prob: float=0.057283623987358645):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4296281304451972, target_prob=0.057283623987358645):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_90",
    "sat": "def sat(counts: List[int], p: float=0.7213036929306849, target_prob: float=0.2561062560848798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7213036929306849, target_prob=0.2561062560848798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_91",
    "sat": "def sat(counts: List[int], p: float=0.12725064819375953, target_prob: float=0.016728547457716302):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12725064819375953, target_prob=0.016728547457716302):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_92",
    "sat": "def sat(counts: List[int], p: float=0.12038501914704813, target_prob: float=3.0439301128069685e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12038501914704813, target_prob=3.0439301128069685e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_93",
    "sat": "def sat(counts: List[int], p: float=0.5854630349048443, target_prob: float=0.20067738773452837):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5854630349048443, target_prob=0.20067738773452837):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_94",
    "sat": "def sat(counts: List[int], p: float=0.3778190506426181, target_prob: float=0.23186008552007867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3778190506426181, target_prob=0.23186008552007867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_95",
    "sat": "def sat(counts: List[int], p: float=0.9106460866819182, target_prob: float=0.08935391331808185):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9106460866819182, target_prob=0.08935391331808185):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_96",
    "sat": "def sat(counts: List[int], p: float=0.3105757624089258, target_prob: float=0.3105757624089258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3105757624089258, target_prob=0.3105757624089258):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_97",
    "sat": "def sat(counts: List[int], p: float=0.876819251010541, target_prob: float=0.0018690827155924425):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.876819251010541, target_prob=0.0018690827155924425):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_98",
    "sat": "def sat(counts: List[int], p: float=0.31943996405771125, target_prob: float=0.058712908766092184):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31943996405771125, target_prob=0.058712908766092184):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_99",
    "sat": "def sat(counts: List[int], p: float=0.3329916830906502, target_prob: float=0.08806178715759691):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3329916830906502, target_prob=0.08806178715759691):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_100",
    "sat": "def sat(counts: List[int], p: float=0.49694509538081943, target_prob: float=0.03221639473858876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49694509538081943, target_prob=0.03221639473858876):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_101",
    "sat": "def sat(counts: List[int], p: float=0.09530767169106891, target_prob: float=2.1047442743709223e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09530767169106891, target_prob=2.1047442743709223e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_102",
    "sat": "def sat(counts: List[int], p: float=0.2904019147495077, target_prob: float=0.2904019147495077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2904019147495077, target_prob=0.2904019147495077):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_103",
    "sat": "def sat(counts: List[int], p: float=0.5664506959761811, target_prob: float=0.1738632151516593):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5664506959761811, target_prob=0.1738632151516593):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_104",
    "sat": "def sat(counts: List[int], p: float=0.16604605222469637, target_prob: float=0.23355369815888422):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16604605222469637, target_prob=0.23355369815888422):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_105",
    "sat": "def sat(counts: List[int], p: float=0.9713116332880269, target_prob: float=0.1276762707529878):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9713116332880269, target_prob=0.1276762707529878):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_106",
    "sat": "def sat(counts: List[int], p: float=0.8943349189372035, target_prob: float=0.6397359428110798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8943349189372035, target_prob=0.6397359428110798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_107",
    "sat": "def sat(counts: List[int], p: float=0.16579280136644892, target_prob: float=0.01275259465378684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16579280136644892, target_prob=0.01275259465378684):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_108",
    "sat": "def sat(counts: List[int], p: float=0.5070169179471117, target_prob: float=0.050946292505791926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5070169179471117, target_prob=0.050946292505791926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_109",
    "sat": "def sat(counts: List[int], p: float=0.03250168683895738, target_prob: float=1.245223223562237e-12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03250168683895738, target_prob=1.245223223562237e-12):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_110",
    "sat": "def sat(counts: List[int], p: float=0.9322922390271596, target_prob: float=0.03714780108911997):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9322922390271596, target_prob=0.03714780108911997):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_111",
    "sat": "def sat(counts: List[int], p: float=0.8625839675331117, target_prob: float=4.899897850530794e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8625839675331117, target_prob=4.899897850530794e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_112",
    "sat": "def sat(counts: List[int], p: float=0.7646253699430958, target_prob: float=0.23537463005690418):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7646253699430958, target_prob=0.23537463005690418):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_113",
    "sat": "def sat(counts: List[int], p: float=0.9442715734116737, target_prob: float=0.14907055480792514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9442715734116737, target_prob=0.14907055480792514):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_114",
    "sat": "def sat(counts: List[int], p: float=0.7388360035719769, target_prob: float=0.001214972725141679):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7388360035719769, target_prob=0.001214972725141679):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_115",
    "sat": "def sat(counts: List[int], p: float=0.5676322967126489, target_prob: float=0.3222064242712767):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5676322967126489, target_prob=0.3222064242712767):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_116",
    "sat": "def sat(counts: List[int], p: float=0.3394133332494915, target_prob: float=0.30162591704453084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3394133332494915, target_prob=0.30162591704453084):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_117",
    "sat": "def sat(counts: List[int], p: float=0.25408926092489414, target_prob: float=0.3790558168150704):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25408926092489414, target_prob=0.3790558168150704):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_118",
    "sat": "def sat(counts: List[int], p: float=0.8237409026123279, target_prob: float=0.6785490746365727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8237409026123279, target_prob=0.6785490746365727):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_119",
    "sat": "def sat(counts: List[int], p: float=0.12341790863567426, target_prob: float=0.00019995218965049815):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12341790863567426, target_prob=0.00019995218965049815):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_120",
    "sat": "def sat(counts: List[int], p: float=0.9344354151855724, target_prob: float=0.022521040985064016):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9344354151855724, target_prob=0.022521040985064016):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_121",
    "sat": "def sat(counts: List[int], p: float=0.1963040023897965, target_prob: float=0.24116639420611147):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1963040023897965, target_prob=0.24116639420611147):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_122",
    "sat": "def sat(counts: List[int], p: float=0.18177191398530235, target_prob: float=0.033041028713880156):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18177191398530235, target_prob=0.033041028713880156):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_123",
    "sat": "def sat(counts: List[int], p: float=0.725048241798196, target_prob: float=0.0006890526365984505):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.725048241798196, target_prob=0.0006890526365984505):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_124",
    "sat": "def sat(counts: List[int], p: float=0.6570184336081845, target_prob: float=0.11763635488458338):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6570184336081845, target_prob=0.11763635488458338):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_125",
    "sat": "def sat(counts: List[int], p: float=0.6902044591201211, target_prob: float=0.011791377049662363):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6902044591201211, target_prob=0.011791377049662363):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_126",
    "sat": "def sat(counts: List[int], p: float=0.278818747906906, target_prob: float=0.721181252093094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.278818747906906, target_prob=0.721181252093094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_127",
    "sat": "def sat(counts: List[int], p: float=0.43423943462724024, target_prob: float=0.1810914803724823):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43423943462724024, target_prob=0.1810914803724823):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_128",
    "sat": "def sat(counts: List[int], p: float=0.6596776583398053, target_prob: float=0.2728609102579047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6596776583398053, target_prob=0.2728609102579047):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_129",
    "sat": "def sat(counts: List[int], p: float=0.5330147504729524, target_prob: float=0.5330147504729524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5330147504729524, target_prob=0.5330147504729524):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_130",
    "sat": "def sat(counts: List[int], p: float=0.9903768348344962, target_prob: float=4.2466086207911766e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9903768348344962, target_prob=4.2466086207911766e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_131",
    "sat": "def sat(counts: List[int], p: float=0.2592535307044409, target_prob: float=0.22127879100382258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2592535307044409, target_prob=0.22127879100382258):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_132",
    "sat": "def sat(counts: List[int], p: float=0.48498490218631907, target_prob: float=0.1705996226155712):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48498490218631907, target_prob=0.1705996226155712):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_133",
    "sat": "def sat(counts: List[int], p: float=0.28188489354943713, target_prob: float=0.25287658643585):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.28188489354943713, target_prob=0.25287658643585):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_134",
    "sat": "def sat(counts: List[int], p: float=0.6000435831561721, target_prob: float=0.345574891087586):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6000435831561721, target_prob=0.345574891087586):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_135",
    "sat": "def sat(counts: List[int], p: float=0.6695133796398609, target_prob: float=0.02702920946429686):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6695133796398609, target_prob=0.02702920946429686):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_136",
    "sat": "def sat(counts: List[int], p: float=0.6229582752622009, target_prob: float=0.23890376559174298):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6229582752622009, target_prob=0.23890376559174298):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_137",
    "sat": "def sat(counts: List[int], p: float=0.2582814984263425, target_prob: float=0.5501463355766717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2582814984263425, target_prob=0.5501463355766717):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_138",
    "sat": "def sat(counts: List[int], p: float=0.43283688963506906, target_prob: float=0.43283688963506906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43283688963506906, target_prob=0.43283688963506906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_139",
    "sat": "def sat(counts: List[int], p: float=0.626749858269967, target_prob: float=0.1583665617007586):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.626749858269967, target_prob=0.1583665617007586):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_140",
    "sat": "def sat(counts: List[int], p: float=0.6037813781465785, target_prob: float=0.6037813781465785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6037813781465785, target_prob=0.6037813781465785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_141",
    "sat": "def sat(counts: List[int], p: float=0.3943902495264203, target_prob: float=0.039558790812094964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3943902495264203, target_prob=0.039558790812094964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_142",
    "sat": "def sat(counts: List[int], p: float=0.3923872603530765, target_prob: float=0.050322386164199345):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3923872603530765, target_prob=0.050322386164199345):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_143",
    "sat": "def sat(counts: List[int], p: float=0.6258993500061358, target_prob: float=0.3431550758080272):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6258993500061358, target_prob=0.3431550758080272):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_144",
    "sat": "def sat(counts: List[int], p: float=0.6146315651852656, target_prob: float=0.06388232315660872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6146315651852656, target_prob=0.06388232315660872):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_145",
    "sat": "def sat(counts: List[int], p: float=0.40394996502701164, target_prob: float=0.2777054101443967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40394996502701164, target_prob=0.2777054101443967):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_146",
    "sat": "def sat(counts: List[int], p: float=0.49863807445173647, target_prob: float=0.01724556207188881):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49863807445173647, target_prob=0.01724556207188881):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_147",
    "sat": "def sat(counts: List[int], p: float=0.5859678778166385, target_prob: float=0.19429828133654253):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5859678778166385, target_prob=0.19429828133654253):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_148",
    "sat": "def sat(counts: List[int], p: float=0.7155833584757224, target_prob: float=0.32018974242077336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7155833584757224, target_prob=0.32018974242077336):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_149",
    "sat": "def sat(counts: List[int], p: float=0.8169779650059543, target_prob: float=0.01123376837331694):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8169779650059543, target_prob=0.01123376837331694):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_150",
    "sat": "def sat(counts: List[int], p: float=0.4174184513212288, target_prob: float=0.15455792560471177):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4174184513212288, target_prob=0.15455792560471177):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_151",
    "sat": "def sat(counts: List[int], p: float=0.3249276257235183, target_prob: float=0.09477746191098192):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3249276257235183, target_prob=0.09477746191098192):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_152",
    "sat": "def sat(counts: List[int], p: float=0.925716139719993, target_prob: float=6.375702086156051e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.925716139719993, target_prob=6.375702086156051e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_153",
    "sat": "def sat(counts: List[int], p: float=0.4210040637679494, target_prob: float=0.4875192841176436):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4210040637679494, target_prob=0.4875192841176436):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_154",
    "sat": "def sat(counts: List[int], p: float=0.7006791883228057, target_prob: float=0.1883277428893778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7006791883228057, target_prob=0.1883277428893778):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_155",
    "sat": "def sat(counts: List[int], p: float=0.14253000881757272, target_prob: float=2.427486414569078e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14253000881757272, target_prob=2.427486414569078e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_156",
    "sat": "def sat(counts: List[int], p: float=0.17430721808330307, target_prob: float=0.12428507246622394):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17430721808330307, target_prob=0.12428507246622394):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_157",
    "sat": "def sat(counts: List[int], p: float=0.46081524454490097, target_prob: float=0.2667815616323139):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46081524454490097, target_prob=0.2667815616323139):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_158",
    "sat": "def sat(counts: List[int], p: float=0.8353156352763512, target_prob: float=1.6987625784566295e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8353156352763512, target_prob=1.6987625784566295e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_159",
    "sat": "def sat(counts: List[int], p: float=0.4920427398099897, target_prob: float=0.25802057817974183):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4920427398099897, target_prob=0.25802057817974183):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_160",
    "sat": "def sat(counts: List[int], p: float=0.499548312042321, target_prob: float=0.499548312042321):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.499548312042321, target_prob=0.499548312042321):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_161",
    "sat": "def sat(counts: List[int], p: float=0.9975698875095869, target_prob: float=5.072551555510623e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9975698875095869, target_prob=5.072551555510623e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_162",
    "sat": "def sat(counts: List[int], p: float=0.5038571622463871, target_prob: float=0.25387203994698204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5038571622463871, target_prob=0.25387203994698204):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_163",
    "sat": "def sat(counts: List[int], p: float=0.4156215512421384, target_prob: float=0.3539449748563195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4156215512421384, target_prob=0.3539449748563195):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_164",
    "sat": "def sat(counts: List[int], p: float=0.5806535206546879, target_prob: float=0.4869900192120077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5806535206546879, target_prob=0.4869900192120077):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_165",
    "sat": "def sat(counts: List[int], p: float=0.4477525795367232, target_prob: float=0.33765818443295836):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4477525795367232, target_prob=0.33765818443295836):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_166",
    "sat": "def sat(counts: List[int], p: float=0.233847271538, target_prob: float=0.2498605185241198):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.233847271538, target_prob=0.2498605185241198):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_167",
    "sat": "def sat(counts: List[int], p: float=0.9958423465097064, target_prob: float=3.9417207235051e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9958423465097064, target_prob=3.9417207235051e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_168",
    "sat": "def sat(counts: List[int], p: float=0.48496334009056274, target_prob: float=0.3743220033066601):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48496334009056274, target_prob=0.3743220033066601):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_169",
    "sat": "def sat(counts: List[int], p: float=0.42889698491106676, target_prob: float=0.48988872249052584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42889698491106676, target_prob=0.48988872249052584):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_170",
    "sat": "def sat(counts: List[int], p: float=0.5408324072022056, target_prob: float=0.19642287405612605):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5408324072022056, target_prob=0.19642287405612605):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_171",
    "sat": "def sat(counts: List[int], p: float=0.2885562194401642, target_prob: float=0.18879242937005475):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2885562194401642, target_prob=0.18879242937005475):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_172",
    "sat": "def sat(counts: List[int], p: float=0.7309513070677115, target_prob: float=0.07238719916857286):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7309513070677115, target_prob=0.07238719916857286):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_173",
    "sat": "def sat(counts: List[int], p: float=0.8527264645300434, target_prob: float=0.02322702681169142):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8527264645300434, target_prob=0.02322702681169142):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_174",
    "sat": "def sat(counts: List[int], p: float=0.7068721101529093, target_prob: float=0.31039350563663476):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7068721101529093, target_prob=0.31039350563663476):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_175",
    "sat": "def sat(counts: List[int], p: float=0.43977188761472474, target_prob: float=0.3138555379067686):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43977188761472474, target_prob=0.3138555379067686):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_176",
    "sat": "def sat(counts: List[int], p: float=0.40332568136961156, target_prob: float=0.3560202425130383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40332568136961156, target_prob=0.3560202425130383):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_177",
    "sat": "def sat(counts: List[int], p: float=0.6847271133545471, target_prob: float=0.08582965878322937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6847271133545471, target_prob=0.08582965878322937):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_178",
    "sat": "def sat(counts: List[int], p: float=0.5160089630541753, target_prob: float=0.3866099832810791):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5160089630541753, target_prob=0.3866099832810791):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_179",
    "sat": "def sat(counts: List[int], p: float=0.052672404238451986, target_prob: float=0.947327595761548):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.052672404238451986, target_prob=0.947327595761548):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_180",
    "sat": "def sat(counts: List[int], p: float=0.6528627487787078, target_prob: float=0.10924096834323367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6528627487787078, target_prob=0.10924096834323367):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_181",
    "sat": "def sat(counts: List[int], p: float=0.9044551281070161, target_prob: float=0.7398796397755881):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9044551281070161, target_prob=0.7398796397755881):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_182",
    "sat": "def sat(counts: List[int], p: float=0.09764652164345233, target_prob: float=0.07005572716367499):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09764652164345233, target_prob=0.07005572716367499):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_183",
    "sat": "def sat(counts: List[int], p: float=0.9856375613267139, target_prob: float=0.9714814022980717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9856375613267139, target_prob=0.9714814022980717):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_184",
    "sat": "def sat(counts: List[int], p: float=0.7109365236096288, target_prob: float=0.031296943642022595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7109365236096288, target_prob=0.031296943642022595):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_185",
    "sat": "def sat(counts: List[int], p: float=0.9431263544669222, target_prob: float=0.7911876933125983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9431263544669222, target_prob=0.7911876933125983):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_186",
    "sat": "def sat(counts: List[int], p: float=0.5343278262292998, target_prob: float=0.2683183385311976):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5343278262292998, target_prob=0.2683183385311976):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_187",
    "sat": "def sat(counts: List[int], p: float=0.964690332943117, target_prob: float=0.03530966705688299):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.964690332943117, target_prob=0.03530966705688299):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_188",
    "sat": "def sat(counts: List[int], p: float=0.8584919052523127, target_prob: float=1.1362371531656077e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8584919052523127, target_prob=1.1362371531656077e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_189",
    "sat": "def sat(counts: List[int], p: float=0.9613839218507073, target_prob: float=0.1649398472255293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9613839218507073, target_prob=0.1649398472255293):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_190",
    "sat": "def sat(counts: List[int], p: float=0.26491614248898265, target_prob: float=0.15476579592738277):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26491614248898265, target_prob=0.15476579592738277):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_191",
    "sat": "def sat(counts: List[int], p: float=0.46268828233359516, target_prob: float=0.28896070916615707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46268828233359516, target_prob=0.28896070916615707):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_192",
    "sat": "def sat(counts: List[int], p: float=0.6991448997216029, target_prob: float=0.00042234633491220174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6991448997216029, target_prob=0.00042234633491220174):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_193",
    "sat": "def sat(counts: List[int], p: float=0.7842555298989683, target_prob: float=0.7842555298989683):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7842555298989683, target_prob=0.7842555298989683):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_194",
    "sat": "def sat(counts: List[int], p: float=0.852763322965594, target_prob: float=0.002003837717776225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.852763322965594, target_prob=0.002003837717776225):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_195",
    "sat": "def sat(counts: List[int], p: float=0.39254148886942597, target_prob: float=0.060486255010854625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39254148886942597, target_prob=0.060486255010854625):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_196",
    "sat": "def sat(counts: List[int], p: float=0.41998195319414555, target_prob: float=0.01280949628390893):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41998195319414555, target_prob=0.01280949628390893):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_197",
    "sat": "def sat(counts: List[int], p: float=0.9821191408775657, target_prob: float=1.0222415424944823e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9821191408775657, target_prob=1.0222415424944823e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_198",
    "sat": "def sat(counts: List[int], p: float=0.567567991818236, target_prob: float=0.002827644629141457):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.567567991818236, target_prob=0.002827644629141457):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_199",
    "sat": "def sat(counts: List[int], p: float=0.9978785957091671, target_prob: float=3.3132118192713005e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9978785957091671, target_prob=3.3132118192713005e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_200",
    "sat": "def sat(counts: List[int], p: float=0.6373847382262743, target_prob: float=0.46225086740499616):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6373847382262743, target_prob=0.46225086740499616):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_201",
    "sat": "def sat(counts: List[int], p: float=0.12790691835560308, target_prob: float=0.6632672040456135):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12790691835560308, target_prob=0.6632672040456135):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_202",
    "sat": "def sat(counts: List[int], p: float=0.9325360792450258, target_prob: float=4.2911393449026156e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9325360792450258, target_prob=4.2911393449026156e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_203",
    "sat": "def sat(counts: List[int], p: float=0.5249261842382746, target_prob: float=0.3554198508413796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5249261842382746, target_prob=0.3554198508413796):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_204",
    "sat": "def sat(counts: List[int], p: float=0.6287581557477265, target_prob: float=0.16056716890614992):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6287581557477265, target_prob=0.16056716890614992):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_205",
    "sat": "def sat(counts: List[int], p: float=0.7560224765874668, target_prob: float=0.04391816178051981):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7560224765874668, target_prob=0.04391816178051981):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_206",
    "sat": "def sat(counts: List[int], p: float=0.7078923584957478, target_prob: float=0.31852333372962094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7078923584957478, target_prob=0.31852333372962094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_207",
    "sat": "def sat(counts: List[int], p: float=0.4653356229252956, target_prob: float=0.04862158394052583):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4653356229252956, target_prob=0.04862158394052583):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_208",
    "sat": "def sat(counts: List[int], p: float=0.8226135908266109, target_prob: float=0.12775670316561577):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8226135908266109, target_prob=0.12775670316561577):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_209",
    "sat": "def sat(counts: List[int], p: float=0.7044689325305923, target_prob: float=0.007628033118069648):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7044689325305923, target_prob=0.007628033118069648):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_210",
    "sat": "def sat(counts: List[int], p: float=0.7346326166058041, target_prob: float=0.22391422564696867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7346326166058041, target_prob=0.22391422564696867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_211",
    "sat": "def sat(counts: List[int], p: float=0.18332898514637486, target_prob: float=3.796529737222709e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18332898514637486, target_prob=3.796529737222709e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_212",
    "sat": "def sat(counts: List[int], p: float=0.7275805460402744, target_prob: float=0.006549722789233199):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7275805460402744, target_prob=0.006549722789233199):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_213",
    "sat": "def sat(counts: List[int], p: float=0.4698482672917048, target_prob: float=0.005915873128575505):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4698482672917048, target_prob=0.005915873128575505):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_214",
    "sat": "def sat(counts: List[int], p: float=0.6696850872513166, target_prob: float=0.6696850872513166):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6696850872513166, target_prob=0.6696850872513166):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_215",
    "sat": "def sat(counts: List[int], p: float=0.8317977780555103, target_prob: float=0.3491310664966461):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8317977780555103, target_prob=0.3491310664966461):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_216",
    "sat": "def sat(counts: List[int], p: float=0.5340084435261669, target_prob: float=0.028532060896831322):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5340084435261669, target_prob=0.028532060896831322):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_217",
    "sat": "def sat(counts: List[int], p: float=0.5864318645965678, target_prob: float=0.05206310451731187):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5864318645965678, target_prob=0.05206310451731187):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_218",
    "sat": "def sat(counts: List[int], p: float=0.43926372348889986, target_prob: float=0.031085075078250344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43926372348889986, target_prob=0.031085075078250344):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_219",
    "sat": "def sat(counts: List[int], p: float=0.08762315463551773, target_prob: float=0.0076778172282798525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08762315463551773, target_prob=0.0076778172282798525):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_220",
    "sat": "def sat(counts: List[int], p: float=0.1384553999063346, target_prob: float=0.35416299687729935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1384553999063346, target_prob=0.35416299687729935):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_221",
    "sat": "def sat(counts: List[int], p: float=0.5540985335266888, target_prob: float=0.13974142088831853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5540985335266888, target_prob=0.13974142088831853):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_222",
    "sat": "def sat(counts: List[int], p: float=0.5739488002367129, target_prob: float=0.07733665393503042):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5739488002367129, target_prob=0.07733665393503042):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_223",
    "sat": "def sat(counts: List[int], p: float=0.07329821511736934, target_prob: float=0.30056931886902033):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07329821511736934, target_prob=0.30056931886902033):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_224",
    "sat": "def sat(counts: List[int], p: float=0.9787684843510039, target_prob: float=2.919948592571538e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9787684843510039, target_prob=2.919948592571538e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_225",
    "sat": "def sat(counts: List[int], p: float=0.8365436765680231, target_prob: float=0.1634563234319769):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8365436765680231, target_prob=0.1634563234319769):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_226",
    "sat": "def sat(counts: List[int], p: float=0.49229197342382836, target_prob: float=0.30753625639435556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49229197342382836, target_prob=0.30753625639435556):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_227",
    "sat": "def sat(counts: List[int], p: float=0.23589405265516028, target_prob: float=0.040120334584742456):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23589405265516028, target_prob=0.040120334584742456):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_228",
    "sat": "def sat(counts: List[int], p: float=0.2830958283663726, target_prob: float=0.0025832115037901357):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2830958283663726, target_prob=0.0025832115037901357):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_229",
    "sat": "def sat(counts: List[int], p: float=0.702356816421541, target_prob: float=0.4181034376954775):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.702356816421541, target_prob=0.4181034376954775):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_230",
    "sat": "def sat(counts: List[int], p: float=0.6332108143217733, target_prob: float=0.4009559353740432):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6332108143217733, target_prob=0.4009559353740432):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_231",
    "sat": "def sat(counts: List[int], p: float=0.7006266567629174, target_prob: float=0.1317081640175362):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7006266567629174, target_prob=0.1317081640175362):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_232",
    "sat": "def sat(counts: List[int], p: float=0.07058770196124031, target_prob: float=8.412203955347171e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07058770196124031, target_prob=8.412203955347171e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_233",
    "sat": "def sat(counts: List[int], p: float=0.6242846834616048, target_prob: float=0.00014918669749058297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6242846834616048, target_prob=0.00014918669749058297):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_234",
    "sat": "def sat(counts: List[int], p: float=0.3245850071555033, target_prob: float=0.03451460966184481):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3245850071555033, target_prob=0.03451460966184481):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_235",
    "sat": "def sat(counts: List[int], p: float=0.22672015371500942, target_prob: float=0.2138061281047067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22672015371500942, target_prob=0.2138061281047067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_236",
    "sat": "def sat(counts: List[int], p: float=0.6125916118479093, target_prob: float=0.3450254864948653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6125916118479093, target_prob=0.3450254864948653):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_237",
    "sat": "def sat(counts: List[int], p: float=0.6204085214475775, target_prob: float=0.23006866158078162):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6204085214475775, target_prob=0.23006866158078162):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_238",
    "sat": "def sat(counts: List[int], p: float=0.4224384118795025, target_prob: float=0.4224384118795025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4224384118795025, target_prob=0.4224384118795025):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_239",
    "sat": "def sat(counts: List[int], p: float=0.9974917711946415, target_prob: float=2.742861832129985e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9974917711946415, target_prob=2.742861832129985e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_240",
    "sat": "def sat(counts: List[int], p: float=0.9387689908709087, target_prob: float=0.16188631711268495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9387689908709087, target_prob=0.16188631711268495):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_241",
    "sat": "def sat(counts: List[int], p: float=0.764850607335601, target_prob: float=0.34222084831630756):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.764850607335601, target_prob=0.34222084831630756):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_242",
    "sat": "def sat(counts: List[int], p: float=0.36688120712502303, target_prob: float=0.00012042847777366788):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36688120712502303, target_prob=0.00012042847777366788):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_243",
    "sat": "def sat(counts: List[int], p: float=0.990192282096089, target_prob: float=8.729226475891587e-15):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.990192282096089, target_prob=8.729226475891587e-15):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_244",
    "sat": "def sat(counts: List[int], p: float=0.9526251345718045, target_prob: float=0.00010632709976685938):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9526251345718045, target_prob=0.00010632709976685938):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_245",
    "sat": "def sat(counts: List[int], p: float=0.046195787296413715, target_prob: float=0.035376936504124344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.046195787296413715, target_prob=0.035376936504124344):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_246",
    "sat": "def sat(counts: List[int], p: float=0.09604937541882674, target_prob: float=6.6846271630695514e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09604937541882674, target_prob=6.6846271630695514e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_247",
    "sat": "def sat(counts: List[int], p: float=0.45063174176713994, target_prob: float=0.21131289579726784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45063174176713994, target_prob=0.21131289579726784):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_248",
    "sat": "def sat(counts: List[int], p: float=0.5816415584452418, target_prob: float=0.06656978389142652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5816415584452418, target_prob=0.06656978389142652):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_249",
    "sat": "def sat(counts: List[int], p: float=0.4486643406397389, target_prob: float=0.055580713787165587):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4486643406397389, target_prob=0.055580713787165587):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_250",
    "sat": "def sat(counts: List[int], p: float=0.2076394001660289, target_prob: float=0.3257315735118768):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2076394001660289, target_prob=0.3257315735118768):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_251",
    "sat": "def sat(counts: List[int], p: float=0.10230489091081596, target_prob: float=0.33985102980112497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10230489091081596, target_prob=0.33985102980112497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_252",
    "sat": "def sat(counts: List[int], p: float=0.6132790671506169, target_prob: float=0.012272223947103388):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6132790671506169, target_prob=0.012272223947103388):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_253",
    "sat": "def sat(counts: List[int], p: float=0.14609212160219942, target_prob: float=0.2494984272159352):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14609212160219942, target_prob=0.2494984272159352):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_254",
    "sat": "def sat(counts: List[int], p: float=0.19678037079489963, target_prob: float=0.3161157129294429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19678037079489963, target_prob=0.3161157129294429):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_255",
    "sat": "def sat(counts: List[int], p: float=0.28066483919295426, target_prob: float=0.2071844835659843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.28066483919295426, target_prob=0.2071844835659843):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_256",
    "sat": "def sat(counts: List[int], p: float=0.6606927072180393, target_prob: float=0.000517788450060315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6606927072180393, target_prob=0.000517788450060315):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_257",
    "sat": "def sat(counts: List[int], p: float=0.07620999108818782, target_prob: float=0.02973867357183043):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07620999108818782, target_prob=0.02973867357183043):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_258",
    "sat": "def sat(counts: List[int], p: float=0.6142894508966127, target_prob: float=0.022133294749679212):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6142894508966127, target_prob=0.022133294749679212):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_259",
    "sat": "def sat(counts: List[int], p: float=0.8584341445011614, target_prob: float=4.83677773017496e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8584341445011614, target_prob=4.83677773017496e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_260",
    "sat": "def sat(counts: List[int], p: float=0.8929653582057788, target_prob: float=0.011456414544017239):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8929653582057788, target_prob=0.011456414544017239):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_261",
    "sat": "def sat(counts: List[int], p: float=0.8629717042350179, target_prob: float=0.0015212745011231434):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8629717042350179, target_prob=0.0015212745011231434):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_262",
    "sat": "def sat(counts: List[int], p: float=0.6074191233460075, target_prob: float=0.19477028251958006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6074191233460075, target_prob=0.19477028251958006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_263",
    "sat": "def sat(counts: List[int], p: float=0.006025963767772535, target_prob: float=0.006025963767772535):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.006025963767772535, target_prob=0.006025963767772535):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_264",
    "sat": "def sat(counts: List[int], p: float=0.9496801792660612, target_prob: float=0.9018924428908182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9496801792660612, target_prob=0.9018924428908182):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_265",
    "sat": "def sat(counts: List[int], p: float=0.04227884663224468, target_prob: float=0.005135782191921604):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04227884663224468, target_prob=0.005135782191921604):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_266",
    "sat": "def sat(counts: List[int], p: float=0.7742934975238274, target_prob: float=0.01522738114870208):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7742934975238274, target_prob=0.01522738114870208):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_267",
    "sat": "def sat(counts: List[int], p: float=0.6670895689047331, target_prob: float=0.29686052371529204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6670895689047331, target_prob=0.29686052371529204):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_268",
    "sat": "def sat(counts: List[int], p: float=0.5837506101497448, target_prob: float=0.08942151825544353):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5837506101497448, target_prob=0.08942151825544353):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_269",
    "sat": "def sat(counts: List[int], p: float=0.8756102817978334, target_prob: float=0.8756102817978334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8756102817978334, target_prob=0.8756102817978334):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_270",
    "sat": "def sat(counts: List[int], p: float=0.03162046536709939, target_prob: float=6.775684668781798e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03162046536709939, target_prob=6.775684668781798e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_271",
    "sat": "def sat(counts: List[int], p: float=0.31014260343796807, target_prob: float=0.01185892303846055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31014260343796807, target_prob=0.01185892303846055):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_272",
    "sat": "def sat(counts: List[int], p: float=0.9790333742743671, target_prob: float=9.45979384037886e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9790333742743671, target_prob=9.45979384037886e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_273",
    "sat": "def sat(counts: List[int], p: float=0.8729083798175982, target_prob: float=0.8729083798175982):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8729083798175982, target_prob=0.8729083798175982):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_274",
    "sat": "def sat(counts: List[int], p: float=0.174862963947229, target_prob: float=0.015758690343770414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.174862963947229, target_prob=0.015758690343770414):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_275",
    "sat": "def sat(counts: List[int], p: float=0.23976646378571131, target_prob: float=0.11157738786164317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23976646378571131, target_prob=0.11157738786164317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_276",
    "sat": "def sat(counts: List[int], p: float=0.3948818084941217, target_prob: float=0.18856330433560514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3948818084941217, target_prob=0.18856330433560514):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_277",
    "sat": "def sat(counts: List[int], p: float=0.8854146487455001, target_prob: float=0.3741225322575811):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8854146487455001, target_prob=0.3741225322575811):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_278",
    "sat": "def sat(counts: List[int], p: float=0.5275579534821789, target_prob: float=0.19352686533349273):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5275579534821789, target_prob=0.19352686533349273):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_279",
    "sat": "def sat(counts: List[int], p: float=0.8305593641415747, target_prob: float=0.16944063585842528):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8305593641415747, target_prob=0.16944063585842528):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_280",
    "sat": "def sat(counts: List[int], p: float=0.34650830149355505, target_prob: float=0.42705140001683833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34650830149355505, target_prob=0.42705140001683833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_281",
    "sat": "def sat(counts: List[int], p: float=0.9748976616983661, target_prob: float=4.4057758867946064e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9748976616983661, target_prob=4.4057758867946064e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_282",
    "sat": "def sat(counts: List[int], p: float=0.8851254557831478, target_prob: float=0.31863852694615047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8851254557831478, target_prob=0.31863852694615047):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_283",
    "sat": "def sat(counts: List[int], p: float=0.18454655493112404, target_prob: float=4.0258574764308176e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18454655493112404, target_prob=4.0258574764308176e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_284",
    "sat": "def sat(counts: List[int], p: float=0.9258178726602558, target_prob: float=0.0003850567676411805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9258178726602558, target_prob=0.0003850567676411805):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_285",
    "sat": "def sat(counts: List[int], p: float=0.12390152781963792, target_prob: float=0.00023567127242208103):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12390152781963792, target_prob=0.00023567127242208103):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_286",
    "sat": "def sat(counts: List[int], p: float=0.8912661746307107, target_prob: float=0.0006229254831903368):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8912661746307107, target_prob=0.0006229254831903368):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_287",
    "sat": "def sat(counts: List[int], p: float=0.3010377889208464, target_prob: float=0.17263271064673924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3010377889208464, target_prob=0.17263271064673924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_288",
    "sat": "def sat(counts: List[int], p: float=0.6116695061896771, target_prob: float=0.1329689207099528):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6116695061896771, target_prob=0.1329689207099528):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_289",
    "sat": "def sat(counts: List[int], p: float=0.7183724791344284, target_prob: float=0.0004989425621437237):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7183724791344284, target_prob=0.0004989425621437237):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_290",
    "sat": "def sat(counts: List[int], p: float=0.22079780172225139, target_prob: float=0.1775992302014979):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22079780172225139, target_prob=0.1775992302014979):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_291",
    "sat": "def sat(counts: List[int], p: float=0.23843188654471414, target_prob: float=0.2511047489125941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23843188654471414, target_prob=0.2511047489125941):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_292",
    "sat": "def sat(counts: List[int], p: float=0.08194170040985826, target_prob: float=0.20718902608297507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08194170040985826, target_prob=0.20718902608297507):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_293",
    "sat": "def sat(counts: List[int], p: float=0.4448018266000342, target_prob: float=0.14078550905975828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4448018266000342, target_prob=0.14078550905975828):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_294",
    "sat": "def sat(counts: List[int], p: float=0.44816859100648854, target_prob: float=0.13760200007738582):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44816859100648854, target_prob=0.13760200007738582):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_295",
    "sat": "def sat(counts: List[int], p: float=0.4254929475300323, target_prob: float=0.18226989757160061):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4254929475300323, target_prob=0.18226989757160061):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_296",
    "sat": "def sat(counts: List[int], p: float=0.7059359147844942, target_prob: float=0.29406408521550575):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7059359147844942, target_prob=0.29406408521550575):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_297",
    "sat": "def sat(counts: List[int], p: float=0.963683596829908, target_prob: float=0.690787814171624):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.963683596829908, target_prob=0.690787814171624):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_298",
    "sat": "def sat(counts: List[int], p: float=0.0421164879516428, target_prob: float=1.8012240024719175e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0421164879516428, target_prob=1.8012240024719175e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_299",
    "sat": "def sat(counts: List[int], p: float=0.46477695500533833, target_prob: float=0.20051146651376683):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46477695500533833, target_prob=0.20051146651376683):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_300",
    "sat": "def sat(counts: List[int], p: float=0.7280722168356951, target_prob: float=0.7280722168356951):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7280722168356951, target_prob=0.7280722168356951):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_301",
    "sat": "def sat(counts: List[int], p: float=0.03502654515508097, target_prob: float=0.931173768555339):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03502654515508097, target_prob=0.931173768555339):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_302",
    "sat": "def sat(counts: List[int], p: float=0.44637636441866557, target_prob: float=0.3018404478942155):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44637636441866557, target_prob=0.3018404478942155):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_303",
    "sat": "def sat(counts: List[int], p: float=0.2735219725935836, target_prob: float=0.005597174919544555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2735219725935836, target_prob=0.005597174919544555):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_304",
    "sat": "def sat(counts: List[int], p: float=0.4083299888872598, target_prob: float=0.12255138682296605):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4083299888872598, target_prob=0.12255138682296605):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_305",
    "sat": "def sat(counts: List[int], p: float=0.2923287177323879, target_prob: float=0.3005317959632437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2923287177323879, target_prob=0.3005317959632437):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_306",
    "sat": "def sat(counts: List[int], p: float=0.09318401989213576, target_prob: float=0.5042363533197335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09318401989213576, target_prob=0.5042363533197335):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_307",
    "sat": "def sat(counts: List[int], p: float=0.7476084032027623, target_prob: float=0.11941007785554827):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7476084032027623, target_prob=0.11941007785554827):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_308",
    "sat": "def sat(counts: List[int], p: float=0.6464285467651221, target_prob: float=0.010391635610910065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6464285467651221, target_prob=0.010391635610910065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_309",
    "sat": "def sat(counts: List[int], p: float=0.15834019859303616, target_prob: float=0.3355988414766372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15834019859303616, target_prob=0.3355988414766372):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_310",
    "sat": "def sat(counts: List[int], p: float=0.7260190891101498, target_prob: float=3.175136801554991e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7260190891101498, target_prob=3.175136801554991e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_311",
    "sat": "def sat(counts: List[int], p: float=0.892624164817145, target_prob: float=7.644563004812506e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.892624164817145, target_prob=7.644563004812506e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_312",
    "sat": "def sat(counts: List[int], p: float=0.3966187432091053, target_prob: float=0.6033812567908947):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3966187432091053, target_prob=0.6033812567908947):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_313",
    "sat": "def sat(counts: List[int], p: float=0.8731598588783982, target_prob: float=0.00017200005870278317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8731598588783982, target_prob=0.00017200005870278317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_314",
    "sat": "def sat(counts: List[int], p: float=0.8792272523885569, target_prob: float=0.16093959085592083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8792272523885569, target_prob=0.16093959085592083):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_315",
    "sat": "def sat(counts: List[int], p: float=0.8199930357305171, target_prob: float=0.03921825366256308):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8199930357305171, target_prob=0.03921825366256308):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_316",
    "sat": "def sat(counts: List[int], p: float=0.1557652258695722, target_prob: float=0.30566284974701546):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1557652258695722, target_prob=0.30566284974701546):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_317",
    "sat": "def sat(counts: List[int], p: float=0.6936988611362752, target_prob: float=0.19186191499156835):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6936988611362752, target_prob=0.19186191499156835):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_318",
    "sat": "def sat(counts: List[int], p: float=0.5883667656617554, target_prob: float=0.13479835247231728):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5883667656617554, target_prob=0.13479835247231728):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_319",
    "sat": "def sat(counts: List[int], p: float=0.71808177064799, target_prob: float=0.4361061562176397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.71808177064799, target_prob=0.4361061562176397):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_320",
    "sat": "def sat(counts: List[int], p: float=0.6990889479050625, target_prob: float=0.07619155637273797):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6990889479050625, target_prob=0.07619155637273797):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_321",
    "sat": "def sat(counts: List[int], p: float=0.9060503471399157, target_prob: float=0.9060503471399157):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9060503471399157, target_prob=0.9060503471399157):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_322",
    "sat": "def sat(counts: List[int], p: float=0.7846227024668654, target_prob: float=0.019870678294922083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7846227024668654, target_prob=0.019870678294922083):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_323",
    "sat": "def sat(counts: List[int], p: float=0.9247749653361822, target_prob: float=0.0752250346638178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9247749653361822, target_prob=0.0752250346638178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_324",
    "sat": "def sat(counts: List[int], p: float=0.6454992126259704, target_prob: float=0.2957551305857022):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6454992126259704, target_prob=0.2957551305857022):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_325",
    "sat": "def sat(counts: List[int], p: float=0.9325960526194653, target_prob: float=6.321167757406258e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9325960526194653, target_prob=6.321167757406258e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_326",
    "sat": "def sat(counts: List[int], p: float=0.2676117011032769, target_prob: float=0.04440316950122321):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2676117011032769, target_prob=0.04440316950122321):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_327",
    "sat": "def sat(counts: List[int], p: float=0.4535914699989624, target_prob: float=0.4535914699989624):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4535914699989624, target_prob=0.4535914699989624):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_328",
    "sat": "def sat(counts: List[int], p: float=0.5234082064267147, target_prob: float=0.3256977082453858):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5234082064267147, target_prob=0.3256977082453858):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_329",
    "sat": "def sat(counts: List[int], p: float=0.8816403425669681, target_prob: float=0.8816403425669681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8816403425669681, target_prob=0.8816403425669681):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_330",
    "sat": "def sat(counts: List[int], p: float=0.7150452443852685, target_prob: float=0.21787156572212948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7150452443852685, target_prob=0.21787156572212948):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_331",
    "sat": "def sat(counts: List[int], p: float=0.364103460915431, target_prob: float=4.094944976618264e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.364103460915431, target_prob=4.094944976618264e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_332",
    "sat": "def sat(counts: List[int], p: float=0.1096551981633449, target_prob: float=0.0013185228854776785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1096551981633449, target_prob=0.0013185228854776785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_333",
    "sat": "def sat(counts: List[int], p: float=0.814670354972863, target_prob: float=0.020743239710782096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.814670354972863, target_prob=0.020743239710782096):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_334",
    "sat": "def sat(counts: List[int], p: float=0.8877047437511836, target_prob: float=0.0013971780700651935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8877047437511836, target_prob=0.0013971780700651935):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_335",
    "sat": "def sat(counts: List[int], p: float=0.06702754365317665, target_prob: float=6.185938223340973e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06702754365317665, target_prob=6.185938223340973e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_336",
    "sat": "def sat(counts: List[int], p: float=0.49110577879970285, target_prob: float=0.004498007278014532):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49110577879970285, target_prob=0.004498007278014532):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_337",
    "sat": "def sat(counts: List[int], p: float=0.1263137892565559, target_prob: float=0.7633275948432379):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1263137892565559, target_prob=0.7633275948432379):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_338",
    "sat": "def sat(counts: List[int], p: float=0.8445508914428237, target_prob: float=8.341675280492707e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8445508914428237, target_prob=8.341675280492707e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_339",
    "sat": "def sat(counts: List[int], p: float=0.2580084388555576, target_prob: float=0.2163139808289997):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2580084388555576, target_prob=0.2163139808289997):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_340",
    "sat": "def sat(counts: List[int], p: float=0.40533151247053645, target_prob: float=0.23549460270435515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40533151247053645, target_prob=0.23549460270435515):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_341",
    "sat": "def sat(counts: List[int], p: float=0.3993926349178343, target_prob: float=0.47975631618244763):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3993926349178343, target_prob=0.47975631618244763):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_342",
    "sat": "def sat(counts: List[int], p: float=0.8636318305219746, target_prob: float=0.8636318305219746):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8636318305219746, target_prob=0.8636318305219746):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_343",
    "sat": "def sat(counts: List[int], p: float=0.7052519395071473, target_prob: float=0.12304549991180605):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7052519395071473, target_prob=0.12304549991180605):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_344",
    "sat": "def sat(counts: List[int], p: float=0.8550276707779605, target_prob: float=0.2442426638866941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8550276707779605, target_prob=0.2442426638866941):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_345",
    "sat": "def sat(counts: List[int], p: float=0.6490033929622929, target_prob: float=0.0034076688352822726):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6490033929622929, target_prob=0.0034076688352822726):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_346",
    "sat": "def sat(counts: List[int], p: float=0.9714762563316032, target_prob: float=0.9437661166160668):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9714762563316032, target_prob=0.9437661166160668):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_347",
    "sat": "def sat(counts: List[int], p: float=0.680138859391523, target_prob: float=0.26672296820070884):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.680138859391523, target_prob=0.26672296820070884):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_348",
    "sat": "def sat(counts: List[int], p: float=0.3768617963467463, target_prob: float=0.4696739656020996):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3768617963467463, target_prob=0.4696739656020996):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_349",
    "sat": "def sat(counts: List[int], p: float=0.11524103720264367, target_prob: float=0.03525011533917091):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11524103720264367, target_prob=0.03525011533917091):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_350",
    "sat": "def sat(counts: List[int], p: float=0.34875152030228895, target_prob: float=0.27621048943088944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34875152030228895, target_prob=0.27621048943088944):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_351",
    "sat": "def sat(counts: List[int], p: float=0.3188167368575213, target_prob: float=0.0032938632286186272):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3188167368575213, target_prob=0.0032938632286186272):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_352",
    "sat": "def sat(counts: List[int], p: float=0.3029220310821077, target_prob: float=0.09176175691490941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3029220310821077, target_prob=0.09176175691490941):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_353",
    "sat": "def sat(counts: List[int], p: float=0.22754110207537614, target_prob: float=0.0006099570932333087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22754110207537614, target_prob=0.0006099570932333087):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_354",
    "sat": "def sat(counts: List[int], p: float=0.4456617943004161, target_prob: float=0.3015578542251102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4456617943004161, target_prob=0.3015578542251102):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_355",
    "sat": "def sat(counts: List[int], p: float=0.05552198312671963, target_prob: float=0.10487858503279178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05552198312671963, target_prob=0.10487858503279178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_356",
    "sat": "def sat(counts: List[int], p: float=0.8247140374660302, target_prob: float=0.21400656392107759):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8247140374660302, target_prob=0.21400656392107759):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_357",
    "sat": "def sat(counts: List[int], p: float=0.3718340787982919, target_prob: float=0.1394485442114452):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3718340787982919, target_prob=0.1394485442114452):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_358",
    "sat": "def sat(counts: List[int], p: float=0.19708846607794472, target_prob: float=0.04389485961315148):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19708846607794472, target_prob=0.04389485961315148):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_359",
    "sat": "def sat(counts: List[int], p: float=0.9190384947022818, target_prob: float=3.4785069188292687e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9190384947022818, target_prob=3.4785069188292687e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_360",
    "sat": "def sat(counts: List[int], p: float=0.03302781036194824, target_prob: float=0.22721351615959914):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03302781036194824, target_prob=0.22721351615959914):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_361",
    "sat": "def sat(counts: List[int], p: float=0.9785659616210626, target_prob: float=0.9785659616210626):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9785659616210626, target_prob=0.9785659616210626):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_362",
    "sat": "def sat(counts: List[int], p: float=0.05653511349188978, target_prob: float=0.00013640045379970493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05653511349188978, target_prob=0.00013640045379970493):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_363",
    "sat": "def sat(counts: List[int], p: float=0.5548977322864083, target_prob: float=0.016199091176105476):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5548977322864083, target_prob=0.016199091176105476):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_364",
    "sat": "def sat(counts: List[int], p: float=0.902120285289617, target_prob: float=0.14458728823042466):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.902120285289617, target_prob=0.14458728823042466):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_365",
    "sat": "def sat(counts: List[int], p: float=0.17684705984653248, target_prob: float=0.04657625753058288):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17684705984653248, target_prob=0.04657625753058288):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_366",
    "sat": "def sat(counts: List[int], p: float=0.8519446586350766, target_prob: float=0.0003636495333733054):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8519446586350766, target_prob=0.0003636495333733054):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_367",
    "sat": "def sat(counts: List[int], p: float=0.29466648400625184, target_prob: float=0.36465219311303954):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.29466648400625184, target_prob=0.36465219311303954):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_368",
    "sat": "def sat(counts: List[int], p: float=0.14347244280572768, target_prob: float=0.25062758388725437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14347244280572768, target_prob=0.25062758388725437):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_369",
    "sat": "def sat(counts: List[int], p: float=0.13360520041998458, target_prob: float=1.3564702262296787e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13360520041998458, target_prob=1.3564702262296787e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_370",
    "sat": "def sat(counts: List[int], p: float=0.4932567730819526, target_prob: float=0.24330224419122087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4932567730819526, target_prob=0.24330224419122087):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_371",
    "sat": "def sat(counts: List[int], p: float=0.6526101539222497, target_prob: float=0.07459359877229316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6526101539222497, target_prob=0.07459359877229316):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_372",
    "sat": "def sat(counts: List[int], p: float=0.31866137046256027, target_prob: float=0.3433614026617442):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31866137046256027, target_prob=0.3433614026617442):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_373",
    "sat": "def sat(counts: List[int], p: float=0.9476114606911998, target_prob: float=3.568991121532588e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9476114606911998, target_prob=3.568991121532588e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_374",
    "sat": "def sat(counts: List[int], p: float=0.40558814593279824, target_prob: float=0.29152355526306706):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40558814593279824, target_prob=0.29152355526306706):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_375",
    "sat": "def sat(counts: List[int], p: float=0.91538904359531, target_prob: float=0.0006057310166923513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.91538904359531, target_prob=0.0006057310166923513):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_376",
    "sat": "def sat(counts: List[int], p: float=0.526175862129676, target_prob: float=0.07665203430036954):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.526175862129676, target_prob=0.07665203430036954):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_377",
    "sat": "def sat(counts: List[int], p: float=0.2354078467029621, target_prob: float=0.0027857575336121903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2354078467029621, target_prob=0.0027857575336121903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_378",
    "sat": "def sat(counts: List[int], p: float=0.9401580465117231, target_prob: float=2.0669558019554805e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9401580465117231, target_prob=2.0669558019554805e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_379",
    "sat": "def sat(counts: List[int], p: float=0.8483925587788054, target_prob: float=0.15160744122119463):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8483925587788054, target_prob=0.15160744122119463):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_380",
    "sat": "def sat(counts: List[int], p: float=0.5094310213612868, target_prob: float=0.11777972058981465):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5094310213612868, target_prob=0.11777972058981465):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_381",
    "sat": "def sat(counts: List[int], p: float=0.5513055106228378, target_prob: float=0.30393776604310796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5513055106228378, target_prob=0.30393776604310796):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_382",
    "sat": "def sat(counts: List[int], p: float=0.17491158502340443, target_prob: float=0.3572241475499206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17491158502340443, target_prob=0.3572241475499206):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_383",
    "sat": "def sat(counts: List[int], p: float=0.2999968374124633, target_prob: float=0.0210029041681986):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2999968374124633, target_prob=0.0210029041681986):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_384",
    "sat": "def sat(counts: List[int], p: float=0.6653885565518192, target_prob: float=0.03746470939532843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6653885565518192, target_prob=0.03746470939532843):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_385",
    "sat": "def sat(counts: List[int], p: float=0.9974900011120102, target_prob: float=5.962487021842237e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9974900011120102, target_prob=5.962487021842237e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_386",
    "sat": "def sat(counts: List[int], p: float=0.7377857693404216, target_prob: float=8.523025807689501e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7377857693404216, target_prob=8.523025807689501e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_387",
    "sat": "def sat(counts: List[int], p: float=0.1764407988517973, target_prob: float=0.24768028796640273):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1764407988517973, target_prob=0.24768028796640273):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_388",
    "sat": "def sat(counts: List[int], p: float=0.27756066984939465, target_prob: float=0.43459221680156995):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27756066984939465, target_prob=0.43459221680156995):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_389",
    "sat": "def sat(counts: List[int], p: float=0.9361448335426885, target_prob: float=0.0008938288840021867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9361448335426885, target_prob=0.0008938288840021867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_390",
    "sat": "def sat(counts: List[int], p: float=0.5002509353492323, target_prob: float=0.3124997638679989):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5002509353492323, target_prob=0.3124997638679989):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_391",
    "sat": "def sat(counts: List[int], p: float=0.7651944845777043, target_prob: float=0.24701997933066192):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7651944845777043, target_prob=0.24701997933066192):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_392",
    "sat": "def sat(counts: List[int], p: float=0.721597162991563, target_prob: float=0.2364193843428981):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.721597162991563, target_prob=0.2364193843428981):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_393",
    "sat": "def sat(counts: List[int], p: float=0.22187155306917128, target_prob: float=0.02483612474055978):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22187155306917128, target_prob=0.02483612474055978):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_394",
    "sat": "def sat(counts: List[int], p: float=0.19674558350643268, target_prob: float=0.3808311736091895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19674558350643268, target_prob=0.3808311736091895):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_395",
    "sat": "def sat(counts: List[int], p: float=0.9896278310988512, target_prob: float=1.291478146270911e-14):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9896278310988512, target_prob=1.291478146270911e-14):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_396",
    "sat": "def sat(counts: List[int], p: float=0.7951698717139303, target_prob: float=0.25160461321982747):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7951698717139303, target_prob=0.25160461321982747):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_397",
    "sat": "def sat(counts: List[int], p: float=0.029629417305284123, target_prob: float=0.0012532723839145479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.029629417305284123, target_prob=0.0012532723839145479):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_398",
    "sat": "def sat(counts: List[int], p: float=0.9286914387688783, target_prob: float=0.8624677884426092):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9286914387688783, target_prob=0.8624677884426092):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_399",
    "sat": "def sat(counts: List[int], p: float=0.5111716141285613, target_prob: float=0.027911429872107145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5111716141285613, target_prob=0.027911429872107145):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_400",
    "sat": "def sat(counts: List[int], p: float=0.047462626707382216, target_prob: float=4.759589642688576e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.047462626707382216, target_prob=4.759589642688576e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_401",
    "sat": "def sat(counts: List[int], p: float=0.7282221985001522, target_prob: float=0.016512659571875747):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7282221985001522, target_prob=0.016512659571875747):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_402",
    "sat": "def sat(counts: List[int], p: float=0.028848733705188367, target_prob: float=0.9711512662948116):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.028848733705188367, target_prob=0.9711512662948116):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_403",
    "sat": "def sat(counts: List[int], p: float=0.12354706715480979, target_prob: float=0.3645162041526461):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12354706715480979, target_prob=0.3645162041526461):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_404",
    "sat": "def sat(counts: List[int], p: float=0.6139817862268069, target_prob: float=0.06432688637872991):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6139817862268069, target_prob=0.06432688637872991):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_405",
    "sat": "def sat(counts: List[int], p: float=0.6546618269975053, target_prob: float=0.07872308574586435):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6546618269975053, target_prob=0.07872308574586435):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_406",
    "sat": "def sat(counts: List[int], p: float=0.46221272064045926, target_prob: float=0.46221272064045926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46221272064045926, target_prob=0.46221272064045926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_407",
    "sat": "def sat(counts: List[int], p: float=0.9194655488962377, target_prob: float=0.026511674799369948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9194655488962377, target_prob=0.026511674799369948):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_408",
    "sat": "def sat(counts: List[int], p: float=0.9481886960844188, target_prob: float=0.13974469300178793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9481886960844188, target_prob=0.13974469300178793):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_409",
    "sat": "def sat(counts: List[int], p: float=0.550101065102476, target_prob: float=0.15947001243407188):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.550101065102476, target_prob=0.15947001243407188):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_410",
    "sat": "def sat(counts: List[int], p: float=0.8979537228269038, target_prob: float=0.24684613458560323):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8979537228269038, target_prob=0.24684613458560323):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_411",
    "sat": "def sat(counts: List[int], p: float=0.2251614535328903, target_prob: float=0.17853618340116392):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2251614535328903, target_prob=0.17853618340116392):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_412",
    "sat": "def sat(counts: List[int], p: float=0.5915429295753014, target_prob: float=0.1612447241168491):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5915429295753014, target_prob=0.1612447241168491):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_413",
    "sat": "def sat(counts: List[int], p: float=0.050397061676020094, target_prob: float=4.1614217281817356e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.050397061676020094, target_prob=4.1614217281817356e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_414",
    "sat": "def sat(counts: List[int], p: float=0.6184091133734749, target_prob: float=0.14625257602369393):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6184091133734749, target_prob=0.14625257602369393):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_415",
    "sat": "def sat(counts: List[int], p: float=0.9892009372359603, target_prob: float=8.716980932863958e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9892009372359603, target_prob=8.716980932863958e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_416",
    "sat": "def sat(counts: List[int], p: float=0.7910906428624425, target_prob: float=0.33053247527585994):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7910906428624425, target_prob=0.33053247527585994):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_417",
    "sat": "def sat(counts: List[int], p: float=0.7880677920189139, target_prob: float=0.00011374056280810393):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7880677920189139, target_prob=0.00011374056280810393):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_418",
    "sat": "def sat(counts: List[int], p: float=0.646802222891203, target_prob: float=0.09737164373772918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.646802222891203, target_prob=0.09737164373772918):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_419",
    "sat": "def sat(counts: List[int], p: float=0.3213100063332147, target_prob: float=0.32856821253785684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3213100063332147, target_prob=0.32856821253785684):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_420",
    "sat": "def sat(counts: List[int], p: float=0.05319952643335257, target_prob: float=0.30918470919228414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05319952643335257, target_prob=0.30918470919228414):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_421",
    "sat": "def sat(counts: List[int], p: float=0.8990236223129202, target_prob: float=0.0026439942292534315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8990236223129202, target_prob=0.0026439942292534315):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_422",
    "sat": "def sat(counts: List[int], p: float=0.3027803190569196, target_prob: float=0.42220879489741914):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3027803190569196, target_prob=0.42220879489741914):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_423",
    "sat": "def sat(counts: List[int], p: float=0.20291737125616616, target_prob: float=0.047905825444086024):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20291737125616616, target_prob=0.047905825444086024):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_424",
    "sat": "def sat(counts: List[int], p: float=0.13906053106833405, target_prob: float=0.860939468931666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13906053106833405, target_prob=0.860939468931666):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_425",
    "sat": "def sat(counts: List[int], p: float=0.8734210771554788, target_prob: float=0.041982443669658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8734210771554788, target_prob=0.041982443669658):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_426",
    "sat": "def sat(counts: List[int], p: float=0.9738546176083448, target_prob: float=8.370743877550793e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9738546176083448, target_prob=8.370743877550793e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_427",
    "sat": "def sat(counts: List[int], p: float=0.47948958938502095, target_prob: float=0.13756759775043648):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47948958938502095, target_prob=0.13756759775043648):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_428",
    "sat": "def sat(counts: List[int], p: float=0.3968911555672924, target_prob: float=0.19803234619611798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3968911555672924, target_prob=0.19803234619611798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_429",
    "sat": "def sat(counts: List[int], p: float=0.9590130466198571, target_prob: float=0.00927025235818609):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9590130466198571, target_prob=0.00927025235818609):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_430",
    "sat": "def sat(counts: List[int], p: float=0.012531875537053816, target_prob: float=2.669237811396917e-14):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.012531875537053816, target_prob=2.669237811396917e-14):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_431",
    "sat": "def sat(counts: List[int], p: float=0.73013720005643, target_prob: float=0.0003862407860389296):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.73013720005643, target_prob=0.0003862407860389296):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_432",
    "sat": "def sat(counts: List[int], p: float=0.4417349375908587, target_prob: float=0.21918318435751472):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4417349375908587, target_prob=0.21918318435751472):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_433",
    "sat": "def sat(counts: List[int], p: float=0.6690967685268803, target_prob: float=0.44281256574753336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6690967685268803, target_prob=0.44281256574753336):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_434",
    "sat": "def sat(counts: List[int], p: float=0.812885514229763, target_prob: float=0.15877342882321094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.812885514229763, target_prob=0.15877342882321094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_435",
    "sat": "def sat(counts: List[int], p: float=0.6933411165247128, target_prob: float=0.30665888347528725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6933411165247128, target_prob=0.30665888347528725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_436",
    "sat": "def sat(counts: List[int], p: float=0.3113641451932738, target_prob: float=0.009398843139437375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3113641451932738, target_prob=0.009398843139437375):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_437",
    "sat": "def sat(counts: List[int], p: float=0.35608713802607905, target_prob: float=0.643912861973921):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35608713802607905, target_prob=0.643912861973921):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_438",
    "sat": "def sat(counts: List[int], p: float=0.2865113065684908, target_prob: float=0.4088451555538141):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2865113065684908, target_prob=0.4088451555538141):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_439",
    "sat": "def sat(counts: List[int], p: float=0.33123436651705906, target_prob: float=0.30821928714806535):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33123436651705906, target_prob=0.30821928714806535):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_440",
    "sat": "def sat(counts: List[int], p: float=0.4480928263452757, target_prob: float=0.5519071736547243):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4480928263452757, target_prob=0.5519071736547243):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_441",
    "sat": "def sat(counts: List[int], p: float=0.635356701020954, target_prob: float=0.0023507661144117316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.635356701020954, target_prob=0.0023507661144117316):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_442",
    "sat": "def sat(counts: List[int], p: float=0.7344426883203649, target_prob: float=0.25903677100327105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7344426883203649, target_prob=0.25903677100327105):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_443",
    "sat": "def sat(counts: List[int], p: float=0.8295258990218988, target_prob: float=0.0001439766432651685):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8295258990218988, target_prob=0.0001439766432651685):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_444",
    "sat": "def sat(counts: List[int], p: float=0.03920274549271929, target_prob: float=2.186997809063797e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03920274549271929, target_prob=2.186997809063797e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_445",
    "sat": "def sat(counts: List[int], p: float=0.109703987281352, target_prob: float=0.30966041324456844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.109703987281352, target_prob=0.30966041324456844):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_446",
    "sat": "def sat(counts: List[int], p: float=0.2679288127541998, target_prob: float=0.39228592810064944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2679288127541998, target_prob=0.39228592810064944):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_447",
    "sat": "def sat(counts: List[int], p: float=0.04570557122306851, target_prob: float=9.116221030090466e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04570557122306851, target_prob=9.116221030090466e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_448",
    "sat": "def sat(counts: List[int], p: float=0.7707752282463054, target_prob: float=0.04424839127082896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7707752282463054, target_prob=0.04424839127082896):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_449",
    "sat": "def sat(counts: List[int], p: float=0.6797908667504952, target_prob: float=0.24539770169338124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6797908667504952, target_prob=0.24539770169338124):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_450",
    "sat": "def sat(counts: List[int], p: float=0.616424670907652, target_prob: float=0.21878661709462283):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.616424670907652, target_prob=0.21878661709462283):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_451",
    "sat": "def sat(counts: List[int], p: float=0.9038674552639179, target_prob: float=0.002207313642699769):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9038674552639179, target_prob=0.002207313642699769):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_452",
    "sat": "def sat(counts: List[int], p: float=0.4408351413446685, target_prob: float=0.00027718011573687524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4408351413446685, target_prob=0.00027718011573687524):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_453",
    "sat": "def sat(counts: List[int], p: float=0.7304236302108403, target_prob: float=0.0014236692450915328):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7304236302108403, target_prob=0.0014236692450915328):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_454",
    "sat": "def sat(counts: List[int], p: float=0.9693154917822914, target_prob: float=0.17815914911219696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9693154917822914, target_prob=0.17815914911219696):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_455",
    "sat": "def sat(counts: List[int], p: float=0.9909560889833499, target_prob: float=7.397225225035612e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9909560889833499, target_prob=7.397225225035612e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_456",
    "sat": "def sat(counts: List[int], p: float=0.13239446726442428, target_prob: float=0.002320649273578227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13239446726442428, target_prob=0.002320649273578227):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_457",
    "sat": "def sat(counts: List[int], p: float=0.6502478005466265, target_prob: float=0.046470714494933944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6502478005466265, target_prob=0.046470714494933944):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_458",
    "sat": "def sat(counts: List[int], p: float=0.5300124299988304, target_prob: float=0.46998757000116964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5300124299988304, target_prob=0.46998757000116964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_459",
    "sat": "def sat(counts: List[int], p: float=0.9256974569967464, target_prob: float=0.8569157818902432):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9256974569967464, target_prob=0.8569157818902432):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_460",
    "sat": "def sat(counts: List[int], p: float=0.6558661416395363, target_prob: float=0.22996293421545644):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6558661416395363, target_prob=0.22996293421545644):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_461",
    "sat": "def sat(counts: List[int], p: float=0.5351363810375134, target_prob: float=0.5351363810375134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5351363810375134, target_prob=0.5351363810375134):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_462",
    "sat": "def sat(counts: List[int], p: float=0.4695736357222583, target_prob: float=0.2813521279209035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4695736357222583, target_prob=0.2813521279209035):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_463",
    "sat": "def sat(counts: List[int], p: float=0.32043662947424734, target_prob: float=0.20933195349480022):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32043662947424734, target_prob=0.20933195349480022):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_464",
    "sat": "def sat(counts: List[int], p: float=0.7163105326755259, target_prob: float=0.11714730707606222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7163105326755259, target_prob=0.11714730707606222):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_465",
    "sat": "def sat(counts: List[int], p: float=0.5605203455382244, target_prob: float=0.055136158388253226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5605203455382244, target_prob=0.055136158388253226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_466",
    "sat": "def sat(counts: List[int], p: float=0.9826868069260705, target_prob: float=0.007557934583104622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9826868069260705, target_prob=0.007557934583104622):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_467",
    "sat": "def sat(counts: List[int], p: float=0.9424566039974984, target_prob: float=0.10846430715800173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9424566039974984, target_prob=0.10846430715800173):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_468",
    "sat": "def sat(counts: List[int], p: float=0.7799193570691195, target_prob: float=0.0023459966327267945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7799193570691195, target_prob=0.0023459966327267945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_469",
    "sat": "def sat(counts: List[int], p: float=0.761676784323523, target_prob: float=0.23832321567647696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.761676784323523, target_prob=0.23832321567647696):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_470",
    "sat": "def sat(counts: List[int], p: float=0.5235294954474756, target_prob: float=0.2228488040621526):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5235294954474756, target_prob=0.2228488040621526):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_471",
    "sat": "def sat(counts: List[int], p: float=0.553292784593383, target_prob: float=0.19728038206312348):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.553292784593383, target_prob=0.19728038206312348):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_472",
    "sat": "def sat(counts: List[int], p: float=0.6446029791079992, target_prob: float=0.015953468974716698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6446029791079992, target_prob=0.015953468974716698):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_473",
    "sat": "def sat(counts: List[int], p: float=0.2159193512949109, target_prob: float=0.012668583764304497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2159193512949109, target_prob=0.012668583764304497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_474",
    "sat": "def sat(counts: List[int], p: float=0.5487727585432426, target_prob: float=0.30115154051916004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5487727585432426, target_prob=0.30115154051916004):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_475",
    "sat": "def sat(counts: List[int], p: float=0.5229772436206779, target_prob: float=0.13539704507379685):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5229772436206779, target_prob=0.13539704507379685):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_476",
    "sat": "def sat(counts: List[int], p: float=0.9695755037309537, target_prob: float=4.1537965825430375e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9695755037309537, target_prob=4.1537965825430375e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_477",
    "sat": "def sat(counts: List[int], p: float=0.30385118888265794, target_prob: float=0.26673417727774473):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30385118888265794, target_prob=0.26673417727774473):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_478",
    "sat": "def sat(counts: List[int], p: float=0.8270317650428286, target_prob: float=0.003701328315663125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8270317650428286, target_prob=0.003701328315663125):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_479",
    "sat": "def sat(counts: List[int], p: float=0.14138041786955002, target_prob: float=0.00039953703631593035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14138041786955002, target_prob=0.00039953703631593035):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_480",
    "sat": "def sat(counts: List[int], p: float=0.6407291751984026, target_prob: float=0.003960209341423262):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6407291751984026, target_prob=0.003960209341423262):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_481",
    "sat": "def sat(counts: List[int], p: float=0.48612232250750487, target_prob: float=0.15042912478285117):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48612232250750487, target_prob=0.15042912478285117):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_482",
    "sat": "def sat(counts: List[int], p: float=0.6881209168741429, target_prob: float=0.009461173249148306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6881209168741429, target_prob=0.009461173249148306):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_483",
    "sat": "def sat(counts: List[int], p: float=0.029111155902885377, target_prob: float=0.029111155902885377):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.029111155902885377, target_prob=0.029111155902885377):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_484",
    "sat": "def sat(counts: List[int], p: float=0.6534927212309817, target_prob: float=0.3350788279951405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6534927212309817, target_prob=0.3350788279951405):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_485",
    "sat": "def sat(counts: List[int], p: float=0.37867750197217953, target_prob: float=0.6213224980278205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37867750197217953, target_prob=0.6213224980278205):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_486",
    "sat": "def sat(counts: List[int], p: float=0.49609764210292484, target_prob: float=0.2460188068634105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49609764210292484, target_prob=0.2460188068634105):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_487",
    "sat": "def sat(counts: List[int], p: float=0.5554869797770279, target_prob: float=0.21161674311576292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5554869797770279, target_prob=0.21161674311576292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_488",
    "sat": "def sat(counts: List[int], p: float=0.5358071714253823, target_prob: float=0.21547498210010446):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5358071714253823, target_prob=0.21547498210010446):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_489",
    "sat": "def sat(counts: List[int], p: float=0.8674411151585659, target_prob: float=0.13255888484143408):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8674411151585659, target_prob=0.13255888484143408):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_490",
    "sat": "def sat(counts: List[int], p: float=0.9016821206631365, target_prob: float=7.812124177832023e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9016821206631365, target_prob=7.812124177832023e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_491",
    "sat": "def sat(counts: List[int], p: float=0.18338629892595015, target_prob: float=0.3552822480290766):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18338629892595015, target_prob=0.3552822480290766):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_492",
    "sat": "def sat(counts: List[int], p: float=0.6747623472045193, target_prob: float=0.0928567086978663):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6747623472045193, target_prob=0.0928567086978663):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_493",
    "sat": "def sat(counts: List[int], p: float=0.30893457878716835, target_prob: float=0.0752721185073373):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30893457878716835, target_prob=0.0752721185073373):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_494",
    "sat": "def sat(counts: List[int], p: float=0.2363244669034641, target_prob: float=0.0403176238537147):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2363244669034641, target_prob=0.0403176238537147):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_495",
    "sat": "def sat(counts: List[int], p: float=0.5881506694277945, target_prob: float=0.20408754848821867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5881506694277945, target_prob=0.20408754848821867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_496",
    "sat": "def sat(counts: List[int], p: float=0.5872509009761013, target_prob: float=0.5872509009761013):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5872509009761013, target_prob=0.5872509009761013):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_497",
    "sat": "def sat(counts: List[int], p: float=0.8137530068636908, target_prob: float=5.0221849252126265e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8137530068636908, target_prob=5.0221849252126265e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_498",
    "sat": "def sat(counts: List[int], p: float=0.9697497440202776, target_prob: float=0.02130954521713227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9697497440202776, target_prob=0.02130954521713227):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_499",
    "sat": "def sat(counts: List[int], p: float=0.6807632084584484, target_prob: float=0.3215245240568545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6807632084584484, target_prob=0.3215245240568545):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_500",
    "sat": "def sat(counts: List[int], p: float=0.969512430831172, target_prob: float=0.030487569168828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.969512430831172, target_prob=0.030487569168828):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_501",
    "sat": "def sat(counts: List[int], p: float=0.8722268920983753, target_prob: float=0.024646426746523585):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8722268920983753, target_prob=0.024646426746523585):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_502",
    "sat": "def sat(counts: List[int], p: float=0.7854250617140537, target_prob: float=0.2347623936610102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7854250617140537, target_prob=0.2347623936610102):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_503",
    "sat": "def sat(counts: List[int], p: float=0.1784609374970484, target_prob: float=0.1289715819133808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1784609374970484, target_prob=0.1289715819133808):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_504",
    "sat": "def sat(counts: List[int], p: float=0.360784904778357, target_prob: float=0.2744108058101724):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.360784904778357, target_prob=0.2744108058101724):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_505",
    "sat": "def sat(counts: List[int], p: float=0.8069583295413115, target_prob: float=0.001388686674347818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8069583295413115, target_prob=0.001388686674347818):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_506",
    "sat": "def sat(counts: List[int], p: float=0.8819349671396699, target_prob: float=0.0008812602360499886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8819349671396699, target_prob=0.0008812602360499886):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_507",
    "sat": "def sat(counts: List[int], p: float=0.3159142798833038, target_prob: float=0.10248567108976067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3159142798833038, target_prob=0.10248567108976067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_508",
    "sat": "def sat(counts: List[int], p: float=0.2194926896215631, target_prob: float=5.387167541595628e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2194926896215631, target_prob=5.387167541595628e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_509",
    "sat": "def sat(counts: List[int], p: float=0.7692349037206534, target_prob: float=0.24239138978792701):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7692349037206534, target_prob=0.24239138978792701):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_510",
    "sat": "def sat(counts: List[int], p: float=0.42178577676515694, target_prob: float=0.09150113838168875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42178577676515694, target_prob=0.09150113838168875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_511",
    "sat": "def sat(counts: List[int], p: float=0.3969803582062704, target_prob: float=0.00155375713118559):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3969803582062704, target_prob=0.00155375713118559):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_512",
    "sat": "def sat(counts: List[int], p: float=0.711128796268654, target_prob: float=0.08344657234519681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.711128796268654, target_prob=0.08344657234519681):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_513",
    "sat": "def sat(counts: List[int], p: float=0.9109838561057102, target_prob: float=0.0890161438942898):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9109838561057102, target_prob=0.0890161438942898):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_514",
    "sat": "def sat(counts: List[int], p: float=0.8679696853217931, target_prob: float=0.10250242078374226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8679696853217931, target_prob=0.10250242078374226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_515",
    "sat": "def sat(counts: List[int], p: float=0.46259000847840626, target_prob: float=0.24848801932868728):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46259000847840626, target_prob=0.24848801932868728):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_516",
    "sat": "def sat(counts: List[int], p: float=0.6209007372728319, target_prob: float=0.1486239167101195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6209007372728319, target_prob=0.1486239167101195):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_517",
    "sat": "def sat(counts: List[int], p: float=0.8441029294751834, target_prob: float=3.4890214160178143e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8441029294751834, target_prob=3.4890214160178143e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_518",
    "sat": "def sat(counts: List[int], p: float=0.05108387778281953, target_prob: float=1.664526789323767e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05108387778281953, target_prob=1.664526789323767e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_519",
    "sat": "def sat(counts: List[int], p: float=0.05311958357433866, target_prob: float=0.29000840856043225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05311958357433866, target_prob=0.29000840856043225):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_520",
    "sat": "def sat(counts: List[int], p: float=0.7390970843747359, target_prob: float=0.24317841175885702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7390970843747359, target_prob=0.24317841175885702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_521",
    "sat": "def sat(counts: List[int], p: float=0.666684253568397, target_prob: float=0.08672366231391579):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.666684253568397, target_prob=0.08672366231391579):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_522",
    "sat": "def sat(counts: List[int], p: float=0.4698202961286855, target_prob: float=0.10370395577248533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4698202961286855, target_prob=0.10370395577248533):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_523",
    "sat": "def sat(counts: List[int], p: float=0.14084042717669487, target_prob: float=8.365541956741685e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14084042717669487, target_prob=8.365541956741685e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_524",
    "sat": "def sat(counts: List[int], p: float=0.7351516600876846, target_prob: float=0.15785620349795063):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7351516600876846, target_prob=0.15785620349795063):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_525",
    "sat": "def sat(counts: List[int], p: float=0.3590237472281089, target_prob: float=0.1023924278012783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3590237472281089, target_prob=0.1023924278012783):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_526",
    "sat": "def sat(counts: List[int], p: float=0.5906199771932176, target_prob: float=0.2922002020659162):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5906199771932176, target_prob=0.2922002020659162):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_527",
    "sat": "def sat(counts: List[int], p: float=0.5711901009759885, target_prob: float=0.42880989902401145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5711901009759885, target_prob=0.42880989902401145):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_528",
    "sat": "def sat(counts: List[int], p: float=0.1709076617767964, target_prob: float=0.00014463391335602007):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1709076617767964, target_prob=0.00014463391335602007):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_529",
    "sat": "def sat(counts: List[int], p: float=0.5113634058580827, target_prob: float=0.02720956200484083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5113634058580827, target_prob=0.02720956200484083):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_530",
    "sat": "def sat(counts: List[int], p: float=0.32942188066375744, target_prob: float=0.16075188850728434):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32942188066375744, target_prob=0.16075188850728434):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_531",
    "sat": "def sat(counts: List[int], p: float=0.6422642625364381, target_prob: float=0.316740370781079):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6422642625364381, target_prob=0.316740370781079):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_532",
    "sat": "def sat(counts: List[int], p: float=0.5016043981438739, target_prob: float=0.0018974389470752266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5016043981438739, target_prob=0.0018974389470752266):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_533",
    "sat": "def sat(counts: List[int], p: float=0.6485468932927584, target_prob: float=0.3369449278717883):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6485468932927584, target_prob=0.3369449278717883):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_534",
    "sat": "def sat(counts: List[int], p: float=0.8184391620949195, target_prob: float=0.36485158495944825):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8184391620949195, target_prob=0.36485158495944825):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_535",
    "sat": "def sat(counts: List[int], p: float=0.47114173971587214, target_prob: float=0.005153010991522774):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47114173971587214, target_prob=0.005153010991522774):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_536",
    "sat": "def sat(counts: List[int], p: float=0.957745865548683, target_prob: float=0.7717945637595425):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.957745865548683, target_prob=0.7717945637595425):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_537",
    "sat": "def sat(counts: List[int], p: float=0.8990430221550854, target_prob: float=6.463068497489103e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8990430221550854, target_prob=6.463068497489103e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_538",
    "sat": "def sat(counts: List[int], p: float=0.05144426646407929, target_prob: float=0.0975955078241042):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05144426646407929, target_prob=0.0975955078241042):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_539",
    "sat": "def sat(counts: List[int], p: float=0.16831404201330724, target_prob: float=0.162974180597319):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16831404201330724, target_prob=0.162974180597319):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_540",
    "sat": "def sat(counts: List[int], p: float=0.7160156668343198, target_prob: float=0.41698645498788345):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7160156668343198, target_prob=0.41698645498788345):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_541",
    "sat": "def sat(counts: List[int], p: float=0.6356720132907168, target_prob: float=0.3250938034231198):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6356720132907168, target_prob=0.3250938034231198):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_542",
    "sat": "def sat(counts: List[int], p: float=0.46063706367885005, target_prob: float=0.12141899124441911):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46063706367885005, target_prob=0.12141899124441911):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_543",
    "sat": "def sat(counts: List[int], p: float=0.5723341346621449, target_prob: float=0.26899860836220324):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5723341346621449, target_prob=0.26899860836220324):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_544",
    "sat": "def sat(counts: List[int], p: float=0.5044181301997089, target_prob: float=0.49558186980029106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5044181301997089, target_prob=0.49558186980029106):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_545",
    "sat": "def sat(counts: List[int], p: float=0.4095358478959634, target_prob: float=0.012414663968393325):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4095358478959634, target_prob=0.012414663968393325):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_546",
    "sat": "def sat(counts: List[int], p: float=0.02084603747024283, target_prob: float=0.00017008009715007067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02084603747024283, target_prob=0.00017008009715007067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_547",
    "sat": "def sat(counts: List[int], p: float=0.3072838841914176, target_prob: float=0.3537781072347812):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3072838841914176, target_prob=0.3537781072347812):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_548",
    "sat": "def sat(counts: List[int], p: float=0.5086324821896602, target_prob: float=0.06692931285196303):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5086324821896602, target_prob=0.06692931285196303):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_549",
    "sat": "def sat(counts: List[int], p: float=0.8695142006677382, target_prob: float=0.016797440418601844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8695142006677382, target_prob=0.016797440418601844):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_550",
    "sat": "def sat(counts: List[int], p: float=0.2863439160215395, target_prob: float=0.3180417050904118):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2863439160215395, target_prob=0.3180417050904118):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_551",
    "sat": "def sat(counts: List[int], p: float=0.883988907848495, target_prob: float=0.1525641182572888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.883988907848495, target_prob=0.1525641182572888):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_552",
    "sat": "def sat(counts: List[int], p: float=0.9454816786186158, target_prob: float=0.0014485505704644915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9454816786186158, target_prob=0.0014485505704644915):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_553",
    "sat": "def sat(counts: List[int], p: float=0.5139077543097403, target_prob: float=0.36428711617119985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5139077543097403, target_prob=0.36428711617119985):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_554",
    "sat": "def sat(counts: List[int], p: float=0.16675671888973664, target_prob: float=0.032195388111950086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16675671888973664, target_prob=0.032195388111950086):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_555",
    "sat": "def sat(counts: List[int], p: float=0.5167948520742294, target_prob: float=0.2667755847289974):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5167948520742294, target_prob=0.2667755847289974):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_556",
    "sat": "def sat(counts: List[int], p: float=0.5805693403212101, target_prob: float=0.2382574922873045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5805693403212101, target_prob=0.2382574922873045):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_557",
    "sat": "def sat(counts: List[int], p: float=0.3384510461401625, target_prob: float=0.22733953291524295):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3384510461401625, target_prob=0.22733953291524295):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_558",
    "sat": "def sat(counts: List[int], p: float=0.33153801876909716, target_prob: float=0.21770085998558703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33153801876909716, target_prob=0.21770085998558703):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_559",
    "sat": "def sat(counts: List[int], p: float=0.6701236088071248, target_prob: float=0.00014021997272900725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6701236088071248, target_prob=0.00014021997272900725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_560",
    "sat": "def sat(counts: List[int], p: float=0.9500397211085656, target_prob: float=0.0009619871966562709):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9500397211085656, target_prob=0.0009619871966562709):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_561",
    "sat": "def sat(counts: List[int], p: float=0.4478566641962659, target_prob: float=0.00400224069532913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4478566641962659, target_prob=0.00400224069532913):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_562",
    "sat": "def sat(counts: List[int], p: float=0.7764418993704341, target_prob: float=0.02557163248525874):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7764418993704341, target_prob=0.02557163248525874):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_563",
    "sat": "def sat(counts: List[int], p: float=0.9555019425354743, target_prob: float=5.1924931171795776e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9555019425354743, target_prob=5.1924931171795776e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_564",
    "sat": "def sat(counts: List[int], p: float=0.5515405057682564, target_prob: float=0.0007336839273086191):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5515405057682564, target_prob=0.0007336839273086191):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_565",
    "sat": "def sat(counts: List[int], p: float=0.48543627287191593, target_prob: float=0.23811587048920946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48543627287191593, target_prob=0.23811587048920946):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_566",
    "sat": "def sat(counts: List[int], p: float=0.597799091113302, target_prob: float=0.402200908886698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.597799091113302, target_prob=0.402200908886698):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_567",
    "sat": "def sat(counts: List[int], p: float=0.8209327671196079, target_prob: float=0.17906723288039206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8209327671196079, target_prob=0.17906723288039206):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_568",
    "sat": "def sat(counts: List[int], p: float=0.7505865134346426, target_prob: float=0.0012647899246974385):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7505865134346426, target_prob=0.0012647899246974385):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_569",
    "sat": "def sat(counts: List[int], p: float=0.4590621180890916, target_prob: float=0.5409378819109084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4590621180890916, target_prob=0.5409378819109084):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_570",
    "sat": "def sat(counts: List[int], p: float=0.3552306638398297, target_prob: float=0.240311449761958):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3552306638398297, target_prob=0.240311449761958):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_571",
    "sat": "def sat(counts: List[int], p: float=0.10038377592571124, target_prob: float=0.809309350617681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10038377592571124, target_prob=0.809309350617681):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_572",
    "sat": "def sat(counts: List[int], p: float=0.9660971497025442, target_prob: float=0.7588682910607351):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9660971497025442, target_prob=0.7588682910607351):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_573",
    "sat": "def sat(counts: List[int], p: float=0.6463427506807282, target_prob: float=0.6463427506807282):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6463427506807282, target_prob=0.6463427506807282):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_574",
    "sat": "def sat(counts: List[int], p: float=0.7241709146242387, target_prob: float=0.7241709146242387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7241709146242387, target_prob=0.7241709146242387):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_575",
    "sat": "def sat(counts: List[int], p: float=0.39789816376577714, target_prob: float=0.020608479415738106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39789816376577714, target_prob=0.020608479415738106):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_576",
    "sat": "def sat(counts: List[int], p: float=0.6110093535474285, target_prob: float=0.22338093719579388):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6110093535474285, target_prob=0.22338093719579388):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_577",
    "sat": "def sat(counts: List[int], p: float=0.008794224924156047, target_prob: float=0.9824888885437045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.008794224924156047, target_prob=0.9824888885437045):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_578",
    "sat": "def sat(counts: List[int], p: float=0.912161881035627, target_prob: float=0.005638880864600144):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.912161881035627, target_prob=0.005638880864600144):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_579",
    "sat": "def sat(counts: List[int], p: float=0.7600332143788004, target_prob: float=0.4158507917041952):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7600332143788004, target_prob=0.4158507917041952):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_580",
    "sat": "def sat(counts: List[int], p: float=0.9997023459384446, target_prob: float=2.4763152074315753e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9997023459384446, target_prob=2.4763152074315753e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_581",
    "sat": "def sat(counts: List[int], p: float=0.30444418241192917, target_prob: float=0.20428756757212488):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30444418241192917, target_prob=0.20428756757212488):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_582",
    "sat": "def sat(counts: List[int], p: float=0.46247995678084275, target_prob: float=0.21268330560969761):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46247995678084275, target_prob=0.21268330560969761):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_583",
    "sat": "def sat(counts: List[int], p: float=0.9332815421380983, target_prob: float=0.06618730182304178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9332815421380983, target_prob=0.06618730182304178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_584",
    "sat": "def sat(counts: List[int], p: float=0.3802973435205197, target_prob: float=0.12049003811908196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3802973435205197, target_prob=0.12049003811908196):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_585",
    "sat": "def sat(counts: List[int], p: float=0.18010007845228804, target_prob: float=0.12120874576419949):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18010007845228804, target_prob=0.12120874576419949):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_586",
    "sat": "def sat(counts: List[int], p: float=0.4047743533013247, target_prob: float=0.21088461961481691):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4047743533013247, target_prob=0.21088461961481691):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_587",
    "sat": "def sat(counts: List[int], p: float=0.2328529307820757, target_prob: float=0.002010893620237144):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2328529307820757, target_prob=0.002010893620237144):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_588",
    "sat": "def sat(counts: List[int], p: float=0.959360740336726, target_prob: float=1.1084827482825862e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.959360740336726, target_prob=1.1084827482825862e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_589",
    "sat": "def sat(counts: List[int], p: float=0.6396258957486023, target_prob: float=0.26921313340120506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6396258957486023, target_prob=0.26921313340120506):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_590",
    "sat": "def sat(counts: List[int], p: float=0.27228242886541143, target_prob: float=0.058759988311559964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27228242886541143, target_prob=0.058759988311559964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_591",
    "sat": "def sat(counts: List[int], p: float=0.29136602870500883, target_prob: float=0.36736416625961926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.29136602870500883, target_prob=0.36736416625961926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_592",
    "sat": "def sat(counts: List[int], p: float=0.4230323538005418, target_prob: float=0.21528648201515643):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4230323538005418, target_prob=0.21528648201515643):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_593",
    "sat": "def sat(counts: List[int], p: float=0.7704789546648552, target_prob: float=0.2338698569799736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7704789546648552, target_prob=0.2338698569799736):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_594",
    "sat": "def sat(counts: List[int], p: float=0.25673974100734487, target_prob: float=0.30174571114950766):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25673974100734487, target_prob=0.30174571114950766):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_595",
    "sat": "def sat(counts: List[int], p: float=0.5346538076085343, target_prob: float=0.216547078773235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5346538076085343, target_prob=0.216547078773235):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_596",
    "sat": "def sat(counts: List[int], p: float=0.3787508580721286, target_prob: float=0.03571581898830801):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3787508580721286, target_prob=0.03571581898830801):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_597",
    "sat": "def sat(counts: List[int], p: float=0.41397081094753196, target_prob: float=0.17167901401854185):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41397081094753196, target_prob=0.17167901401854185):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_598",
    "sat": "def sat(counts: List[int], p: float=0.2567127204965195, target_prob: float=4.842019144906301e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2567127204965195, target_prob=4.842019144906301e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_599",
    "sat": "def sat(counts: List[int], p: float=0.17727988167920772, target_prob: float=0.6768683930897784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17727988167920772, target_prob=0.6768683930897784):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_600",
    "sat": "def sat(counts: List[int], p: float=0.9804858669073047, target_prob: float=3.7899628603934797e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9804858669073047, target_prob=3.7899628603934797e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_601",
    "sat": "def sat(counts: List[int], p: float=0.5905458690129479, target_prob: float=0.297019802344444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5905458690129479, target_prob=0.297019802344444):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_602",
    "sat": "def sat(counts: List[int], p: float=0.0889999155882436, target_prob: float=0.08183594793931984):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0889999155882436, target_prob=0.08183594793931984):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_603",
    "sat": "def sat(counts: List[int], p: float=0.7655330639946626, target_prob: float=0.05497474407973099):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7655330639946626, target_prob=0.05497474407973099):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_604",
    "sat": "def sat(counts: List[int], p: float=0.7806980929714351, target_prob: float=0.0023129680467529287):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7806980929714351, target_prob=0.0023129680467529287):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_605",
    "sat": "def sat(counts: List[int], p: float=0.026656188177221152, target_prob: float=1.8112585812184998e-16):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.026656188177221152, target_prob=1.8112585812184998e-16):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_606",
    "sat": "def sat(counts: List[int], p: float=0.5986641106512398, target_prob: float=0.3444432351159851):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5986641106512398, target_prob=0.3444432351159851):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_607",
    "sat": "def sat(counts: List[int], p: float=0.014619294913793435, target_prob: float=2.2505038853732795e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.014619294913793435, target_prob=2.2505038853732795e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_608",
    "sat": "def sat(counts: List[int], p: float=0.7953179104426731, target_prob: float=0.000409371735871372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7953179104426731, target_prob=0.000409371735871372):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_609",
    "sat": "def sat(counts: List[int], p: float=0.7221513412142201, target_prob: float=0.03492321496247317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7221513412142201, target_prob=0.03492321496247317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_610",
    "sat": "def sat(counts: List[int], p: float=0.45213536935246856, target_prob: float=0.08558666533998169):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45213536935246856, target_prob=0.08558666533998169):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_611",
    "sat": "def sat(counts: List[int], p: float=0.5676916445988401, target_prob: float=0.18295214543337224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5676916445988401, target_prob=0.18295214543337224):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_612",
    "sat": "def sat(counts: List[int], p: float=0.23705735329518773, target_prob: float=0.0009477865017490741):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23705735329518773, target_prob=0.0009477865017490741):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_613",
    "sat": "def sat(counts: List[int], p: float=0.9611391672783832, target_prob: float=1.0959852012925186e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9611391672783832, target_prob=1.0959852012925186e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_614",
    "sat": "def sat(counts: List[int], p: float=0.45240240615280913, target_prob: float=0.053437435919321985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45240240615280913, target_prob=0.053437435919321985):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_615",
    "sat": "def sat(counts: List[int], p: float=0.4264052090224216, target_prob: float=0.033059022327594716):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4264052090224216, target_prob=0.033059022327594716):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_616",
    "sat": "def sat(counts: List[int], p: float=0.5076120105209312, target_prob: float=0.05896534267789462):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5076120105209312, target_prob=0.05896534267789462):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_617",
    "sat": "def sat(counts: List[int], p: float=0.7630712314552078, target_prob: float=0.2451212433282605):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7630712314552078, target_prob=0.2451212433282605):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_618",
    "sat": "def sat(counts: List[int], p: float=0.20080767288847556, target_prob: float=0.7991923271115244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20080767288847556, target_prob=0.7991923271115244):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_619",
    "sat": "def sat(counts: List[int], p: float=0.25334751301376734, target_prob: float=0.0002644233922134021):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25334751301376734, target_prob=0.0002644233922134021):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_620",
    "sat": "def sat(counts: List[int], p: float=0.5401059635510302, target_prob: float=0.08509732142595622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5401059635510302, target_prob=0.08509732142595622):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_621",
    "sat": "def sat(counts: List[int], p: float=0.8557076853994562, target_prob: float=0.03573918874399652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8557076853994562, target_prob=0.03573918874399652):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_622",
    "sat": "def sat(counts: List[int], p: float=0.5770960039298948, target_prob: float=0.07563544503366025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5770960039298948, target_prob=0.07563544503366025):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_623",
    "sat": "def sat(counts: List[int], p: float=0.15476367014612236, target_prob: float=0.3738208135572753):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15476367014612236, target_prob=0.3738208135572753):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_624",
    "sat": "def sat(counts: List[int], p: float=0.33541007541050083, target_prob: float=0.2935359236186902):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33541007541050083, target_prob=0.2935359236186902):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_625",
    "sat": "def sat(counts: List[int], p: float=0.39700077690230906, target_prob: float=0.39700077690230906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39700077690230906, target_prob=0.39700077690230906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_626",
    "sat": "def sat(counts: List[int], p: float=0.11255972227197275, target_prob: float=9.620672934258179e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11255972227197275, target_prob=9.620672934258179e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_627",
    "sat": "def sat(counts: List[int], p: float=0.12021139610323828, target_prob: float=0.00020882503547230578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12021139610323828, target_prob=0.00020882503547230578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_628",
    "sat": "def sat(counts: List[int], p: float=0.8165537826178789, target_prob: float=0.03365251467180842):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8165537826178789, target_prob=0.03365251467180842):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_629",
    "sat": "def sat(counts: List[int], p: float=0.6358038364122174, target_prob: float=0.1634152476356867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6358038364122174, target_prob=0.1634152476356867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_630",
    "sat": "def sat(counts: List[int], p: float=0.48875762304743375, target_prob: float=0.15301044792320045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48875762304743375, target_prob=0.15301044792320045):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_631",
    "sat": "def sat(counts: List[int], p: float=0.63493702511241, target_prob: float=0.24907223612945412):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.63493702511241, target_prob=0.24907223612945412):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_632",
    "sat": "def sat(counts: List[int], p: float=0.5792099009612852, target_prob: float=0.09061086837502588):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5792099009612852, target_prob=0.09061086837502588):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_633",
    "sat": "def sat(counts: List[int], p: float=0.9308901196412366, target_prob: float=2.348985469142262e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9308901196412366, target_prob=2.348985469142262e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_634",
    "sat": "def sat(counts: List[int], p: float=0.9582306979826762, target_prob: float=0.0006691320219381666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9582306979826762, target_prob=0.0006691320219381666):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_635",
    "sat": "def sat(counts: List[int], p: float=0.5743577441085655, target_prob: float=0.4212413084848078):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5743577441085655, target_prob=0.4212413084848078):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_636",
    "sat": "def sat(counts: List[int], p: float=0.7313578175373256, target_prob: float=0.16737691951759948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7313578175373256, target_prob=0.16737691951759948):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_637",
    "sat": "def sat(counts: List[int], p: float=0.034539719386683654, target_prob: float=1.7600595414876983e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.034539719386683654, target_prob=1.7600595414876983e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_638",
    "sat": "def sat(counts: List[int], p: float=0.5695323741888096, target_prob: float=0.2924461529874258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5695323741888096, target_prob=0.2924461529874258):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_639",
    "sat": "def sat(counts: List[int], p: float=0.8007363352207341, target_prob: float=0.8007363352207341):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8007363352207341, target_prob=0.8007363352207341):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_640",
    "sat": "def sat(counts: List[int], p: float=0.9389787787595926, target_prob: float=0.06102122124040743):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9389787787595926, target_prob=0.06102122124040743):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_641",
    "sat": "def sat(counts: List[int], p: float=0.3955344342977226, target_prob: float=0.3955344342977226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3955344342977226, target_prob=0.3955344342977226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_642",
    "sat": "def sat(counts: List[int], p: float=0.37097769487771437, target_prob: float=0.05956995108631539):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37097769487771437, target_prob=0.05956995108631539):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_643",
    "sat": "def sat(counts: List[int], p: float=0.7036547830709762, target_prob: float=0.2700323858680436):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7036547830709762, target_prob=0.2700323858680436):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_644",
    "sat": "def sat(counts: List[int], p: float=0.615940210258539, target_prob: float=0.012759892410860906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.615940210258539, target_prob=0.012759892410860906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_645",
    "sat": "def sat(counts: List[int], p: float=0.033382575769680956, target_prob: float=0.09357295338220999):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.033382575769680956, target_prob=0.09357295338220999):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_646",
    "sat": "def sat(counts: List[int], p: float=0.8244103754254248, target_prob: float=0.28951581663266984):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8244103754254248, target_prob=0.28951581663266984):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_647",
    "sat": "def sat(counts: List[int], p: float=0.13261078275931681, target_prob: float=0.00809115509554066):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13261078275931681, target_prob=0.00809115509554066):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_648",
    "sat": "def sat(counts: List[int], p: float=0.6565182642993047, target_prob: float=0.17466447055617046):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6565182642993047, target_prob=0.17466447055617046):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_649",
    "sat": "def sat(counts: List[int], p: float=0.8491344945247924, target_prob: float=0.8491344945247924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8491344945247924, target_prob=0.8491344945247924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_650",
    "sat": "def sat(counts: List[int], p: float=0.9201510644730189, target_prob: float=0.07984893552698114):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9201510644730189, target_prob=0.07984893552698114):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_651",
    "sat": "def sat(counts: List[int], p: float=0.48313055924500226, target_prob: float=0.28169879770436634):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48313055924500226, target_prob=0.28169879770436634):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_652",
    "sat": "def sat(counts: List[int], p: float=0.6415142211422096, target_prob: float=0.16936557978841377):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6415142211422096, target_prob=0.16936557978841377):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_653",
    "sat": "def sat(counts: List[int], p: float=0.90860846789633, target_prob: float=0.046831339476606074):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.90860846789633, target_prob=0.046831339476606074):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_654",
    "sat": "def sat(counts: List[int], p: float=0.8805257125274922, target_prob: float=0.006006553936029491):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8805257125274922, target_prob=0.006006553936029491):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_655",
    "sat": "def sat(counts: List[int], p: float=0.4762918556531235, target_prob: float=0.35641575492181776):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4762918556531235, target_prob=0.35641575492181776):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_656",
    "sat": "def sat(counts: List[int], p: float=0.2656063739769233, target_prob: float=0.005824687284990901):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2656063739769233, target_prob=0.005824687284990901):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_657",
    "sat": "def sat(counts: List[int], p: float=0.6693039894119909, target_prob: float=0.0001430314844669923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6693039894119909, target_prob=0.0001430314844669923):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_658",
    "sat": "def sat(counts: List[int], p: float=0.7108331550223939, target_prob: float=0.024179398317661194):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7108331550223939, target_prob=0.024179398317661194):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_659",
    "sat": "def sat(counts: List[int], p: float=0.07657044758314757, target_prob: float=0.007070088663486773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07657044758314757, target_prob=0.007070088663486773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_660",
    "sat": "def sat(counts: List[int], p: float=0.0937178492359082, target_prob: float=0.006760733128946656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0937178492359082, target_prob=0.006760733128946656):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_661",
    "sat": "def sat(counts: List[int], p: float=0.9934544801306416, target_prob: float=7.161763092085443e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9934544801306416, target_prob=7.161763092085443e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_662",
    "sat": "def sat(counts: List[int], p: float=0.45264748623506457, target_prob: float=0.062404934501201575):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45264748623506457, target_prob=0.062404934501201575):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_663",
    "sat": "def sat(counts: List[int], p: float=0.06697796420662228, target_prob: float=0.17491900550896744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06697796420662228, target_prob=0.17491900550896744):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_664",
    "sat": "def sat(counts: List[int], p: float=0.9380631866872946, target_prob: float=0.003922589350083389):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9380631866872946, target_prob=0.003922589350083389):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_665",
    "sat": "def sat(counts: List[int], p: float=0.6171327203375404, target_prob: float=6.768345590610795e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6171327203375404, target_prob=6.768345590610795e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_666",
    "sat": "def sat(counts: List[int], p: float=0.250530520740022, target_prob: float=3.888174699496551e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.250530520740022, target_prob=3.888174699496551e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_667",
    "sat": "def sat(counts: List[int], p: float=0.416919343364324, target_prob: float=0.42523653256298843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.416919343364324, target_prob=0.42523653256298843):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_668",
    "sat": "def sat(counts: List[int], p: float=0.6861856344277368, target_prob: float=0.07162940634517069):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6861856344277368, target_prob=0.07162940634517069):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_669",
    "sat": "def sat(counts: List[int], p: float=0.23922975794498902, target_prob: float=0.05723087708641804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23922975794498902, target_prob=0.05723087708641804):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_670",
    "sat": "def sat(counts: List[int], p: float=0.027007188992322795, target_prob: float=0.09951035357132083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.027007188992322795, target_prob=0.09951035357132083):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_671",
    "sat": "def sat(counts: List[int], p: float=0.03642259111453683, target_prob: float=2.334667460820446e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03642259111453683, target_prob=2.334667460820446e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_672",
    "sat": "def sat(counts: List[int], p: float=0.7935150963027037, target_prob: float=0.29803399406508707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7935150963027037, target_prob=0.29803399406508707):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_673",
    "sat": "def sat(counts: List[int], p: float=0.7819853575458343, target_prob: float=0.21801464245416569):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7819853575458343, target_prob=0.21801464245416569):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_674",
    "sat": "def sat(counts: List[int], p: float=0.31754800029995234, target_prob: float=0.6824519997000477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31754800029995234, target_prob=0.6824519997000477):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_675",
    "sat": "def sat(counts: List[int], p: float=0.6458902391055165, target_prob: float=0.004641230538811583):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6458902391055165, target_prob=0.004641230538811583):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_676",
    "sat": "def sat(counts: List[int], p: float=0.32311313968563615, target_prob: float=0.32311313968563615):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32311313968563615, target_prob=0.32311313968563615):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_677",
    "sat": "def sat(counts: List[int], p: float=0.3776360440515393, target_prob: float=0.364138608929065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3776360440515393, target_prob=0.364138608929065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_678",
    "sat": "def sat(counts: List[int], p: float=0.4813300794306059, target_prob: float=0.11151390077575342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4813300794306059, target_prob=0.11151390077575342):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_679",
    "sat": "def sat(counts: List[int], p: float=0.3866800773427349, target_prob: float=0.3866800773427349):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3866800773427349, target_prob=0.3866800773427349):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_680",
    "sat": "def sat(counts: List[int], p: float=0.9906378735121257, target_prob: float=1.850269172714293e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9906378735121257, target_prob=1.850269172714293e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_681",
    "sat": "def sat(counts: List[int], p: float=0.9030890673915274, target_prob: float=5.23679125358032e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9030890673915274, target_prob=5.23679125358032e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_682",
    "sat": "def sat(counts: List[int], p: float=0.6765858213597624, target_prob: float=0.1045967309455395):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6765858213597624, target_prob=0.1045967309455395):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_683",
    "sat": "def sat(counts: List[int], p: float=0.13800786276382715, target_prob: float=1.56544486748172e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13800786276382715, target_prob=1.56544486748172e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_684",
    "sat": "def sat(counts: List[int], p: float=0.9313381215795185, target_prob: float=0.06866187842048155):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9313381215795185, target_prob=0.06866187842048155):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_685",
    "sat": "def sat(counts: List[int], p: float=0.07969296886504473, target_prob: float=0.7173497646793938):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07969296886504473, target_prob=0.7173497646793938):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_686",
    "sat": "def sat(counts: List[int], p: float=0.2623040735523826, target_prob: float=0.14490296000252678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2623040735523826, target_prob=0.14490296000252678):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_687",
    "sat": "def sat(counts: List[int], p: float=0.01745207635128332, target_prob: float=0.00030457496897102245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.01745207635128332, target_prob=0.00030457496897102245):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_688",
    "sat": "def sat(counts: List[int], p: float=0.16423602346059363, target_prob: float=0.3267542565666218):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16423602346059363, target_prob=0.3267542565666218):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_689",
    "sat": "def sat(counts: List[int], p: float=0.32288509412612487, target_prob: float=0.4584845957565868):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32288509412612487, target_prob=0.4584845957565868):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_690",
    "sat": "def sat(counts: List[int], p: float=0.9640764985777713, target_prob: float=0.9294434951099755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9640764985777713, target_prob=0.9294434951099755):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_691",
    "sat": "def sat(counts: List[int], p: float=0.7023650339705315, target_prob: float=0.16901325339063067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7023650339705315, target_prob=0.16901325339063067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_692",
    "sat": "def sat(counts: List[int], p: float=0.38784391704917953, target_prob: float=0.6121560829508205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38784391704917953, target_prob=0.6121560829508205):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_693",
    "sat": "def sat(counts: List[int], p: float=0.2819225296669706, target_prob: float=0.00014154954752974692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2819225296669706, target_prob=0.00014154954752974692):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_694",
    "sat": "def sat(counts: List[int], p: float=0.8109327360024329, target_prob: float=0.00025928709967038585):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8109327360024329, target_prob=0.00025928709967038585):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_695",
    "sat": "def sat(counts: List[int], p: float=0.010041469505834955, target_prob: float=0.010041469505834955):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.010041469505834955, target_prob=0.010041469505834955):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_696",
    "sat": "def sat(counts: List[int], p: float=0.6245298354279848, target_prob: float=0.24359006526584653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6245298354279848, target_prob=0.24359006526584653):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_697",
    "sat": "def sat(counts: List[int], p: float=0.6530825764423799, target_prob: float=0.02081857025151512):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6530825764423799, target_prob=0.02081857025151512):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_698",
    "sat": "def sat(counts: List[int], p: float=0.6568078879207158, target_prob: float=0.4508225725716885):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6568078879207158, target_prob=0.4508225725716885):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_699",
    "sat": "def sat(counts: List[int], p: float=0.6706758459547308, target_prob: float=0.2182132362590112):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6706758459547308, target_prob=0.2182132362590112):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_700",
    "sat": "def sat(counts: List[int], p: float=0.8434547901981448, target_prob: float=0.3961475948242078):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8434547901981448, target_prob=0.3961475948242078):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_701",
    "sat": "def sat(counts: List[int], p: float=0.7856151394921337, target_prob: float=0.18470085620050533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7856151394921337, target_prob=0.18470085620050533):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_702",
    "sat": "def sat(counts: List[int], p: float=0.1260997207232306, target_prob: float=0.5832402837113954):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1260997207232306, target_prob=0.5832402837113954):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_703",
    "sat": "def sat(counts: List[int], p: float=0.4883997623288149, target_prob: float=0.12823977305867834):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4883997623288149, target_prob=0.12823977305867834):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_704",
    "sat": "def sat(counts: List[int], p: float=0.5763258848459184, target_prob: float=0.5763258848459184):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5763258848459184, target_prob=0.5763258848459184):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_705",
    "sat": "def sat(counts: List[int], p: float=0.4976992151004829, target_prob: float=0.3110488364466871):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4976992151004829, target_prob=0.3110488364466871):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_706",
    "sat": "def sat(counts: List[int], p: float=0.5699053623677203, target_prob: float=0.25840301124157594):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5699053623677203, target_prob=0.25840301124157594):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_707",
    "sat": "def sat(counts: List[int], p: float=0.2075738447190224, target_prob: float=0.00044370325892819593):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2075738447190224, target_prob=0.00044370325892819593):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_708",
    "sat": "def sat(counts: List[int], p: float=0.7448885598884463, target_prob: float=0.15194515566186773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7448885598884463, target_prob=0.15194515566186773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_709",
    "sat": "def sat(counts: List[int], p: float=0.5457147266823308, target_prob: float=0.4542852733176692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5457147266823308, target_prob=0.4542852733176692):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_710",
    "sat": "def sat(counts: List[int], p: float=0.34080217155870884, target_prob: float=0.44931210283915446):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34080217155870884, target_prob=0.44931210283915446):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_711",
    "sat": "def sat(counts: List[int], p: float=0.0036618772255903043, target_prob: float=4.9103374389223306e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0036618772255903043, target_prob=4.9103374389223306e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_712",
    "sat": "def sat(counts: List[int], p: float=0.598381583589171, target_prob: float=0.18486553994878382):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.598381583589171, target_prob=0.18486553994878382):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_713",
    "sat": "def sat(counts: List[int], p: float=0.9686606339722176, target_prob: float=2.969145274876521e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9686606339722176, target_prob=2.969145274876521e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_714",
    "sat": "def sat(counts: List[int], p: float=0.9932882367652399, target_prob: float=0.006711763234760082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9932882367652399, target_prob=0.006711763234760082):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_715",
    "sat": "def sat(counts: List[int], p: float=0.11205052906344637, target_prob: float=9.410421158926382e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11205052906344637, target_prob=9.410421158926382e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_716",
    "sat": "def sat(counts: List[int], p: float=0.6030194236885159, target_prob: float=0.6030194236885159):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6030194236885159, target_prob=0.6030194236885159):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_717",
    "sat": "def sat(counts: List[int], p: float=0.9624052106322319, target_prob: float=0.9262237894520707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9624052106322319, target_prob=0.9262237894520707):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_718",
    "sat": "def sat(counts: List[int], p: float=0.15572057832550779, target_prob: float=0.00016034739682183513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15572057832550779, target_prob=0.00016034739682183513):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_719",
    "sat": "def sat(counts: List[int], p: float=0.9244852242766858, target_prob: float=0.00043062160040362434):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9244852242766858, target_prob=0.00043062160040362434):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_720",
    "sat": "def sat(counts: List[int], p: float=0.012851126149950765, target_prob: float=0.0009656037255433565):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.012851126149950765, target_prob=0.0009656037255433565):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_721",
    "sat": "def sat(counts: List[int], p: float=0.5585105135162742, target_prob: float=0.3647998807239332):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5585105135162742, target_prob=0.3647998807239332):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_722",
    "sat": "def sat(counts: List[int], p: float=0.19372222075913725, target_prob: float=0.2886855559549847):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19372222075913725, target_prob=0.2886855559549847):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_723",
    "sat": "def sat(counts: List[int], p: float=0.32034726268371083, target_prob: float=0.04842768182732243):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32034726268371083, target_prob=0.04842768182732243):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_724",
    "sat": "def sat(counts: List[int], p: float=0.6391683443239169, target_prob: float=0.00407228029148155):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6391683443239169, target_prob=0.00407228029148155):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_725",
    "sat": "def sat(counts: List[int], p: float=0.20347609789281207, target_prob: float=0.7965239021071879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20347609789281207, target_prob=0.7965239021071879):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_726",
    "sat": "def sat(counts: List[int], p: float=0.6738910801524247, target_prob: float=0.21226928318291793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6738910801524247, target_prob=0.21226928318291793):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_727",
    "sat": "def sat(counts: List[int], p: float=0.3715717642177855, target_prob: float=0.16020456406228237):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3715717642177855, target_prob=0.16020456406228237):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_728",
    "sat": "def sat(counts: List[int], p: float=0.20404857498106688, target_prob: float=0.7959514250189331):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20404857498106688, target_prob=0.7959514250189331):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_729",
    "sat": "def sat(counts: List[int], p: float=0.22474266874103666, target_prob: float=0.46594820773933604):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22474266874103666, target_prob=0.46594820773933604):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_730",
    "sat": "def sat(counts: List[int], p: float=0.917988172872081, target_prob: float=0.013710265047554966):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.917988172872081, target_prob=0.013710265047554966):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_731",
    "sat": "def sat(counts: List[int], p: float=0.1727632117402017, target_prob: float=0.38739070758587874):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1727632117402017, target_prob=0.38739070758587874):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_732",
    "sat": "def sat(counts: List[int], p: float=0.3969422496476789, target_prob: float=0.6030577503523211):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3969422496476789, target_prob=0.6030577503523211):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_733",
    "sat": "def sat(counts: List[int], p: float=0.3615247138851524, target_prob: float=0.19871304115194852):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3615247138851524, target_prob=0.19871304115194852):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_734",
    "sat": "def sat(counts: List[int], p: float=0.1302559166500996, target_prob: float=0.2847890896254909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1302559166500996, target_prob=0.2847890896254909):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_735",
    "sat": "def sat(counts: List[int], p: float=0.6996058274823547, target_prob: float=0.41144496276410714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6996058274823547, target_prob=0.41144496276410714):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_736",
    "sat": "def sat(counts: List[int], p: float=0.6787201418598331, target_prob: float=0.01393989443221107):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6787201418598331, target_prob=0.01393989443221107):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_737",
    "sat": "def sat(counts: List[int], p: float=0.5308250171725787, target_prob: float=0.24375272509203158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5308250171725787, target_prob=0.24375272509203158):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_738",
    "sat": "def sat(counts: List[int], p: float=0.4604203736547746, target_prob: float=0.18202344137730936):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4604203736547746, target_prob=0.18202344137730936):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_739",
    "sat": "def sat(counts: List[int], p: float=0.1801026128240062, target_prob: float=0.004313298955176291):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1801026128240062, target_prob=0.004313298955176291):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_740",
    "sat": "def sat(counts: List[int], p: float=0.11069993672763812, target_prob: float=8.870261777785951e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11069993672763812, target_prob=8.870261777785951e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_741",
    "sat": "def sat(counts: List[int], p: float=0.947874397306567, target_prob: float=0.947874397306567):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.947874397306567, target_prob=0.947874397306567):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_742",
    "sat": "def sat(counts: List[int], p: float=0.0840425726276407, target_prob: float=0.6447278686537089):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0840425726276407, target_prob=0.6447278686537089):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_743",
    "sat": "def sat(counts: List[int], p: float=0.017602534042921336, target_prob: float=0.9314272385385397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.017602534042921336, target_prob=0.9314272385385397):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_744",
    "sat": "def sat(counts: List[int], p: float=0.190441305547, target_prob: float=0.08808295912178186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.190441305547, target_prob=0.08808295912178186):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_745",
    "sat": "def sat(counts: List[int], p: float=0.18800060538817698, target_prob: float=0.007041276231063839):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18800060538817698, target_prob=0.007041276231063839):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_746",
    "sat": "def sat(counts: List[int], p: float=0.8781257636260783, target_prob: float=0.3623337500991439):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8781257636260783, target_prob=0.3623337500991439):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_747",
    "sat": "def sat(counts: List[int], p: float=0.6411607992215306, target_prob: float=0.05136326486749946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6411607992215306, target_prob=0.05136326486749946):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_748",
    "sat": "def sat(counts: List[int], p: float=0.6498189293833427, target_prob: float=0.6498189293833427):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6498189293833427, target_prob=0.6498189293833427):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_749",
    "sat": "def sat(counts: List[int], p: float=0.031583674021856134, target_prob: float=6.189516749597933e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.031583674021856134, target_prob=6.189516749597933e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_750",
    "sat": "def sat(counts: List[int], p: float=0.8366132221407913, target_prob: float=3.108267282915583e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8366132221407913, target_prob=3.108267282915583e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_751",
    "sat": "def sat(counts: List[int], p: float=0.05314218856445663, target_prob: float=9.066732565844889e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05314218856445663, target_prob=9.066732565844889e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_752",
    "sat": "def sat(counts: List[int], p: float=0.4931504597477627, target_prob: float=0.25684824603007017):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4931504597477627, target_prob=0.25684824603007017):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_753",
    "sat": "def sat(counts: List[int], p: float=0.409967961520355, target_prob: float=0.29750665564776657):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.409967961520355, target_prob=0.29750665564776657):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_754",
    "sat": "def sat(counts: List[int], p: float=0.303628758527578, target_prob: float=0.0779703583651975):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.303628758527578, target_prob=0.0779703583651975):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_755",
    "sat": "def sat(counts: List[int], p: float=0.880428443829194, target_prob: float=0.006020571250151673):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.880428443829194, target_prob=0.006020571250151673):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_756",
    "sat": "def sat(counts: List[int], p: float=0.15886436668585835, target_prob: float=0.02523788700249886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15886436668585835, target_prob=0.02523788700249886):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_757",
    "sat": "def sat(counts: List[int], p: float=0.42396301412764303, target_prob: float=0.2528626306191206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42396301412764303, target_prob=0.2528626306191206):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_758",
    "sat": "def sat(counts: List[int], p: float=0.6071212533499368, target_prob: float=0.2164351138641583):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6071212533499368, target_prob=0.2164351138641583):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_759",
    "sat": "def sat(counts: List[int], p: float=0.7500973543341638, target_prob: float=0.14053373742288935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7500973543341638, target_prob=0.14053373742288935):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_760",
    "sat": "def sat(counts: List[int], p: float=0.6804971532558955, target_prob: float=0.1020820690775867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6804971532558955, target_prob=0.1020820690775867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_761",
    "sat": "def sat(counts: List[int], p: float=0.7601337223171463, target_prob: float=0.08472469199398283):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7601337223171463, target_prob=0.08472469199398283):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_762",
    "sat": "def sat(counts: List[int], p: float=0.6970024176149359, target_prob: float=0.07991715068347904):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6970024176149359, target_prob=0.07991715068347904):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_763",
    "sat": "def sat(counts: List[int], p: float=0.5902268068400187, target_prob: float=0.15084193717016867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5902268068400187, target_prob=0.15084193717016867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_764",
    "sat": "def sat(counts: List[int], p: float=0.22042757076693764, target_prob: float=0.136411746672923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22042757076693764, target_prob=0.136411746672923):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_765",
    "sat": "def sat(counts: List[int], p: float=0.7971355128294314, target_prob: float=0.00834868513645707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7971355128294314, target_prob=0.00834868513645707):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_766",
    "sat": "def sat(counts: List[int], p: float=0.6758641642926094, target_prob: float=0.3241358357073906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6758641642926094, target_prob=0.3241358357073906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_767",
    "sat": "def sat(counts: List[int], p: float=0.09674577352893299, target_prob: float=0.0003956471230937519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09674577352893299, target_prob=0.0003956471230937519):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_768",
    "sat": "def sat(counts: List[int], p: float=0.6718107112231273, target_prob: float=0.2619889180440298):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6718107112231273, target_prob=0.2619889180440298):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_769",
    "sat": "def sat(counts: List[int], p: float=0.3241799474032213, target_prob: float=0.3241799474032213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3241799474032213, target_prob=0.3241799474032213):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_770",
    "sat": "def sat(counts: List[int], p: float=0.179147621458426, target_prob: float=0.179147621458426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.179147621458426, target_prob=0.179147621458426):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_771",
    "sat": "def sat(counts: List[int], p: float=0.8434435755064249, target_prob: float=0.1565564244935751):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8434435755064249, target_prob=0.1565564244935751):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_772",
    "sat": "def sat(counts: List[int], p: float=0.015686177745767305, target_prob: float=3.859680853698681e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.015686177745767305, target_prob=3.859680853698681e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_773",
    "sat": "def sat(counts: List[int], p: float=0.7395021881782791, target_prob: float=0.004784774067832889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7395021881782791, target_prob=0.004784774067832889):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_774",
    "sat": "def sat(counts: List[int], p: float=0.6234550630239423, target_prob: float=0.26519176621195234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6234550630239423, target_prob=0.26519176621195234):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_775",
    "sat": "def sat(counts: List[int], p: float=0.30766766586973027, target_prob: float=0.23419201036383894):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30766766586973027, target_prob=0.23419201036383894):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_776",
    "sat": "def sat(counts: List[int], p: float=0.44780827696031, target_prob: float=0.0007241508561686292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44780827696031, target_prob=0.0007241508561686292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_777",
    "sat": "def sat(counts: List[int], p: float=0.22209169927145567, target_prob: float=0.22209169927145567):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22209169927145567, target_prob=0.22209169927145567):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_778",
    "sat": "def sat(counts: List[int], p: float=0.3151075034036277, target_prob: float=0.004693241660595973):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3151075034036277, target_prob=0.004693241660595973):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_779",
    "sat": "def sat(counts: List[int], p: float=0.4064540159401603, target_prob: float=0.2533308470585587):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4064540159401603, target_prob=0.2533308470585587):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_780",
    "sat": "def sat(counts: List[int], p: float=0.5856055969557022, target_prob: float=0.17172272127443988):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5856055969557022, target_prob=0.17172272127443988):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_781",
    "sat": "def sat(counts: List[int], p: float=0.38833532997423814, target_prob: float=0.0012285010401409306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38833532997423814, target_prob=0.0012285010401409306):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_782",
    "sat": "def sat(counts: List[int], p: float=0.7899124740050394, target_prob: float=0.029298120702157746):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7899124740050394, target_prob=0.029298120702157746):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_783",
    "sat": "def sat(counts: List[int], p: float=0.1493385904187705, target_prob: float=0.8506614095812295):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1493385904187705, target_prob=0.8506614095812295):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_784",
    "sat": "def sat(counts: List[int], p: float=0.725668253218172, target_prob: float=0.725668253218172):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.725668253218172, target_prob=0.725668253218172):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_785",
    "sat": "def sat(counts: List[int], p: float=0.5944363267805332, target_prob: float=0.5944363267805332):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5944363267805332, target_prob=0.5944363267805332):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_786",
    "sat": "def sat(counts: List[int], p: float=0.6907062067619519, target_prob: float=0.32951870783724163):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6907062067619519, target_prob=0.32951870783724163):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_787",
    "sat": "def sat(counts: List[int], p: float=0.5285739747564323, target_prob: float=0.02188218284950659):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5285739747564323, target_prob=0.02188218284950659):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_788",
    "sat": "def sat(counts: List[int], p: float=0.9658873379233572, target_prob: float=0.001868818942266886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9658873379233572, target_prob=0.001868818942266886):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_789",
    "sat": "def sat(counts: List[int], p: float=0.1664461418156995, target_prob: float=0.0779155080264627):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1664461418156995, target_prob=0.0779155080264627):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_790",
    "sat": "def sat(counts: List[int], p: float=0.943605549116026, target_prob: float=1.0665522308927243e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.943605549116026, target_prob=1.0665522308927243e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_791",
    "sat": "def sat(counts: List[int], p: float=0.12772554657585267, target_prob: float=0.02461780312118006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12772554657585267, target_prob=0.02461780312118006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_792",
    "sat": "def sat(counts: List[int], p: float=0.26547406349667857, target_prob: float=0.07047647838943852):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26547406349667857, target_prob=0.07047647838943852):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_793",
    "sat": "def sat(counts: List[int], p: float=0.04880558775196109, target_prob: float=0.8606129387343006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04880558775196109, target_prob=0.8606129387343006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_794",
    "sat": "def sat(counts: List[int], p: float=0.0378069846557062, target_prob: float=6.37004951932576e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0378069846557062, target_prob=6.37004951932576e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_795",
    "sat": "def sat(counts: List[int], p: float=0.6890759367486727, target_prob: float=0.07376826839578925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6890759367486727, target_prob=0.07376826839578925):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_796",
    "sat": "def sat(counts: List[int], p: float=0.22795475422348344, target_prob: float=0.0027001918189601):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22795475422348344, target_prob=0.0027001918189601):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_797",
    "sat": "def sat(counts: List[int], p: float=0.45451488992828126, target_prob: float=0.5454851100717187):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45451488992828126, target_prob=0.5454851100717187):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_798",
    "sat": "def sat(counts: List[int], p: float=0.33433411113483424, target_prob: float=0.6656658888651658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33433411113483424, target_prob=0.6656658888651658):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_799",
    "sat": "def sat(counts: List[int], p: float=0.5902412020392933, target_prob: float=0.20605006872715925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5902412020392933, target_prob=0.20605006872715925):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_800",
    "sat": "def sat(counts: List[int], p: float=0.6352559095343181, target_prob: float=0.017699176370063106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6352559095343181, target_prob=0.017699176370063106):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_801",
    "sat": "def sat(counts: List[int], p: float=0.07540008943825505, target_prob: float=1.0446598130482648e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07540008943825505, target_prob=1.0446598130482648e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_802",
    "sat": "def sat(counts: List[int], p: float=0.6966581354910807, target_prob: float=0.11431896363934549):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6966581354910807, target_prob=0.11431896363934549):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_803",
    "sat": "def sat(counts: List[int], p: float=0.8452704058140674, target_prob: float=0.031163226112594936):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8452704058140674, target_prob=0.031163226112594936):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_804",
    "sat": "def sat(counts: List[int], p: float=0.13460975718430923, target_prob: float=0.0024391000918515967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13460975718430923, target_prob=0.0024391000918515967):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_805",
    "sat": "def sat(counts: List[int], p: float=0.9518070131092499, target_prob: float=0.9059365902039518):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9518070131092499, target_prob=0.9059365902039518):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_806",
    "sat": "def sat(counts: List[int], p: float=0.016789746721719068, target_prob: float=0.9832102532782809):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.016789746721719068, target_prob=0.9832102532782809):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_807",
    "sat": "def sat(counts: List[int], p: float=0.3483124535784732, target_prob: float=0.4246966581609097):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3483124535784732, target_prob=0.4246966581609097):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_808",
    "sat": "def sat(counts: List[int], p: float=0.08403420040829057, target_prob: float=0.5905756674862213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08403420040829057, target_prob=0.5905756674862213):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_809",
    "sat": "def sat(counts: List[int], p: float=0.25257352488324736, target_prob: float=0.5586463357054536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25257352488324736, target_prob=0.5586463357054536):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_810",
    "sat": "def sat(counts: List[int], p: float=0.17383082436760078, target_prob: float=0.017358386256536205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17383082436760078, target_prob=0.017358386256536205):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_811",
    "sat": "def sat(counts: List[int], p: float=0.482263159995896, target_prob: float=0.2677141244030814):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.482263159995896, target_prob=0.2677141244030814):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_812",
    "sat": "def sat(counts: List[int], p: float=0.46381403955587186, target_prob: float=0.497381152533472):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46381403955587186, target_prob=0.497381152533472):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_813",
    "sat": "def sat(counts: List[int], p: float=0.5123924065381327, target_prob: float=0.48760759346186733):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5123924065381327, target_prob=0.48760759346186733):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_814",
    "sat": "def sat(counts: List[int], p: float=0.5042849580512928, target_prob: float=0.052380137964652115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5042849580512928, target_prob=0.052380137964652115):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_815",
    "sat": "def sat(counts: List[int], p: float=0.8604599271634754, target_prob: float=0.03461933967544096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8604599271634754, target_prob=0.03461933967544096):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_816",
    "sat": "def sat(counts: List[int], p: float=0.9758038946149059, target_prob: float=2.175354788331393e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9758038946149059, target_prob=2.175354788331393e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_817",
    "sat": "def sat(counts: List[int], p: float=0.4190699329001851, target_prob: float=0.045051330115955676):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4190699329001851, target_prob=0.045051330115955676):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_818",
    "sat": "def sat(counts: List[int], p: float=0.5906891430669281, target_prob: float=0.4835509586595725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5906891430669281, target_prob=0.4835509586595725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_819",
    "sat": "def sat(counts: List[int], p: float=0.7139851822320039, target_prob: float=0.02388984527780004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7139851822320039, target_prob=0.02388984527780004):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_820",
    "sat": "def sat(counts: List[int], p: float=0.331600111393771, target_prob: float=0.2654286280995706):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.331600111393771, target_prob=0.2654286280995706):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_821",
    "sat": "def sat(counts: List[int], p: float=0.7522660265722566, target_prob: float=0.011088940022915224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7522660265722566, target_prob=0.011088940022915224):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_822",
    "sat": "def sat(counts: List[int], p: float=0.8472059874945308, target_prob: float=0.7177579852465831):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8472059874945308, target_prob=0.7177579852465831):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_823",
    "sat": "def sat(counts: List[int], p: float=0.9438135446844764, target_prob: float=5.5806490016856906e-12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9438135446844764, target_prob=5.5806490016856906e-12):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_824",
    "sat": "def sat(counts: List[int], p: float=0.5124940049917613, target_prob: float=0.16815319481355065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5124940049917613, target_prob=0.16815319481355065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_825",
    "sat": "def sat(counts: List[int], p: float=0.3465339484985942, target_prob: float=0.11915579028547033):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3465339484985942, target_prob=0.11915579028547033):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_826",
    "sat": "def sat(counts: List[int], p: float=0.1632745564275545, target_prob: float=0.007166300409497112):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1632745564275545, target_prob=0.007166300409497112):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_827",
    "sat": "def sat(counts: List[int], p: float=0.2961890519877982, target_prob: float=0.2961890519877982):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2961890519877982, target_prob=0.2961890519877982):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_828",
    "sat": "def sat(counts: List[int], p: float=0.5800881043957472, target_prob: float=0.42390384119409064):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5800881043957472, target_prob=0.42390384119409064):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_829",
    "sat": "def sat(counts: List[int], p: float=0.05387553914698073, target_prob: float=0.00823858798315917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05387553914698073, target_prob=0.00823858798315917):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_830",
    "sat": "def sat(counts: List[int], p: float=0.7406787497146343, target_prob: float=0.051665923506502245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7406787497146343, target_prob=0.051665923506502245):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_831",
    "sat": "def sat(counts: List[int], p: float=0.014102273710386637, target_prob: float=0.02780679917316795):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.014102273710386637, target_prob=0.02780679917316795):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_832",
    "sat": "def sat(counts: List[int], p: float=0.22103734054132917, target_prob: float=0.22103734054132917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22103734054132917, target_prob=0.22103734054132917):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_833",
    "sat": "def sat(counts: List[int], p: float=0.39244501678143906, target_prob: float=0.14688655159710967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39244501678143906, target_prob=0.14688655159710967):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_834",
    "sat": "def sat(counts: List[int], p: float=0.449231921154543, target_prob: float=0.20180931898420157):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.449231921154543, target_prob=0.20180931898420157):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_835",
    "sat": "def sat(counts: List[int], p: float=0.5506658825954188, target_prob: float=0.09072107461753266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5506658825954188, target_prob=0.09072107461753266):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_836",
    "sat": "def sat(counts: List[int], p: float=0.27158264842148083, target_prob: float=0.16117793064326072):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27158264842148083, target_prob=0.16117793064326072):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_837",
    "sat": "def sat(counts: List[int], p: float=0.7520914529939019, target_prob: float=0.5656415536664785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7520914529939019, target_prob=0.5656415536664785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_838",
    "sat": "def sat(counts: List[int], p: float=0.2952299676211696, target_prob: float=0.29906354965580983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2952299676211696, target_prob=0.29906354965580983):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_839",
    "sat": "def sat(counts: List[int], p: float=0.5269592292038796, target_prob: float=0.4730407707961204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5269592292038796, target_prob=0.4730407707961204):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_840",
    "sat": "def sat(counts: List[int], p: float=0.854865342618932, target_prob: float=0.6247311077717179):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.854865342618932, target_prob=0.6247311077717179):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_841",
    "sat": "def sat(counts: List[int], p: float=0.9469147363772, target_prob: float=0.0568815261439553):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9469147363772, target_prob=0.0568815261439553):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_842",
    "sat": "def sat(counts: List[int], p: float=0.38394410892492803, target_prob: float=0.17782811397466713):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38394410892492803, target_prob=0.17782811397466713):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_843",
    "sat": "def sat(counts: List[int], p: float=0.29461756601671507, target_prob: float=0.32233472529625984):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.29461756601671507, target_prob=0.32233472529625984):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_844",
    "sat": "def sat(counts: List[int], p: float=0.9960660107540983, target_prob: float=0.01170929275983953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9960660107540983, target_prob=0.01170929275983953):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_845",
    "sat": "def sat(counts: List[int], p: float=0.07947859187303952, target_prob: float=0.7800127100090917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07947859187303952, target_prob=0.7800127100090917):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_846",
    "sat": "def sat(counts: List[int], p: float=0.1277742184865065, target_prob: float=0.334989624702844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1277742184865065, target_prob=0.334989624702844):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_847",
    "sat": "def sat(counts: List[int], p: float=0.4791310718386549, target_prob: float=0.00693134433624649):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4791310718386549, target_prob=0.00693134433624649):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_848",
    "sat": "def sat(counts: List[int], p: float=0.085296836771252, target_prob: float=0.0022705911946485306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.085296836771252, target_prob=0.0022705911946485306):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_849",
    "sat": "def sat(counts: List[int], p: float=0.0005474684723678624, target_prob: float=5.730520572449763e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0005474684723678624, target_prob=5.730520572449763e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_850",
    "sat": "def sat(counts: List[int], p: float=0.11896712509758178, target_prob: float=0.11896712509758178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11896712509758178, target_prob=0.11896712509758178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_851",
    "sat": "def sat(counts: List[int], p: float=0.21458189428581387, target_prob: float=0.21458189428581387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21458189428581387, target_prob=0.21458189428581387):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_852",
    "sat": "def sat(counts: List[int], p: float=0.35159650694240485, target_prob: float=0.18290040476439293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35159650694240485, target_prob=0.18290040476439293):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_853",
    "sat": "def sat(counts: List[int], p: float=0.929392671987015, target_prob: float=0.8027821948647065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.929392671987015, target_prob=0.8027821948647065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_854",
    "sat": "def sat(counts: List[int], p: float=0.01093859130382302, target_prob: float=0.00011965277971207259):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.01093859130382302, target_prob=0.00011965277971207259):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_855",
    "sat": "def sat(counts: List[int], p: float=0.12621631430081337, target_prob: float=0.07297768826276932):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12621631430081337, target_prob=0.07297768826276932):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_856",
    "sat": "def sat(counts: List[int], p: float=0.15827272111887514, target_prob: float=0.22227388658367814):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15827272111887514, target_prob=0.22227388658367814):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_857",
    "sat": "def sat(counts: List[int], p: float=0.3705454958707297, target_prob: float=0.39621297276862555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3705454958707297, target_prob=0.39621297276862555):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_858",
    "sat": "def sat(counts: List[int], p: float=0.35459843529066126, target_prob: float=0.11198247705159703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35459843529066126, target_prob=0.11198247705159703):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_859",
    "sat": "def sat(counts: List[int], p: float=0.7666434460770895, target_prob: float=0.3454408624081843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7666434460770895, target_prob=0.3454408624081843):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_860",
    "sat": "def sat(counts: List[int], p: float=0.5362333985289459, target_prob: float=0.2875462576979033):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5362333985289459, target_prob=0.2875462576979033):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_861",
    "sat": "def sat(counts: List[int], p: float=0.6765852954746451, target_prob: float=0.0143639079893432):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6765852954746451, target_prob=0.0143639079893432):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_862",
    "sat": "def sat(counts: List[int], p: float=0.1568651733770826, target_prob: float=4.848817442338234e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1568651733770826, target_prob=4.848817442338234e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_863",
    "sat": "def sat(counts: List[int], p: float=0.40350474505093137, target_prob: float=0.07551530247428336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40350474505093137, target_prob=0.07551530247428336):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_864",
    "sat": "def sat(counts: List[int], p: float=0.31788482817311703, target_prob: float=0.010211256901477667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31788482817311703, target_prob=0.010211256901477667):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_865",
    "sat": "def sat(counts: List[int], p: float=0.6511056587159326, target_prob: float=0.04246995267550369):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6511056587159326, target_prob=0.04246995267550369):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_866",
    "sat": "def sat(counts: List[int], p: float=0.48096490758134336, target_prob: float=0.5190350924186566):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48096490758134336, target_prob=0.5190350924186566):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_867",
    "sat": "def sat(counts: List[int], p: float=0.7997715705727665, target_prob: float=0.39310340204851896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7997715705727665, target_prob=0.39310340204851896):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_868",
    "sat": "def sat(counts: List[int], p: float=0.7271023825242569, target_prob: float=0.020323534182382256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7271023825242569, target_prob=0.020323534182382256):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_869",
    "sat": "def sat(counts: List[int], p: float=0.17580244507224163, target_prob: float=0.016094656222445353):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17580244507224163, target_prob=0.016094656222445353):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_870",
    "sat": "def sat(counts: List[int], p: float=0.9710298279809277, target_prob: float=0.9710298279809277):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9710298279809277, target_prob=0.9710298279809277):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_871",
    "sat": "def sat(counts: List[int], p: float=0.9780637117487335, target_prob: float=0.00904443231578002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9780637117487335, target_prob=0.00904443231578002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_872",
    "sat": "def sat(counts: List[int], p: float=0.27641098293535993, target_prob: float=0.3182656124592328):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27641098293535993, target_prob=0.3182656124592328):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_873",
    "sat": "def sat(counts: List[int], p: float=0.3534482870686405, target_prob: float=0.11419337315374711):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3534482870686405, target_prob=0.11419337315374711):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_874",
    "sat": "def sat(counts: List[int], p: float=0.4355132411640943, target_prob: float=0.032353595751913315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4355132411640943, target_prob=0.032353595751913315):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_875",
    "sat": "def sat(counts: List[int], p: float=0.8633647209050953, target_prob: float=6.140789677560901e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8633647209050953, target_prob=6.140789677560901e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_876",
    "sat": "def sat(counts: List[int], p: float=0.43687360402560615, target_prob: float=0.027405564815171646):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43687360402560615, target_prob=0.027405564815171646):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_877",
    "sat": "def sat(counts: List[int], p: float=0.5862386503993999, target_prob: float=0.2014760109164042):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5862386503993999, target_prob=0.2014760109164042):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_878",
    "sat": "def sat(counts: List[int], p: float=0.6554740910731653, target_prob: float=0.11869810192186157):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6554740910731653, target_prob=0.11869810192186157):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_879",
    "sat": "def sat(counts: List[int], p: float=0.8486919306562927, target_prob: float=0.0423512744576244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8486919306562927, target_prob=0.0423512744576244):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_880",
    "sat": "def sat(counts: List[int], p: float=0.15872947277208416, target_prob: float=0.07011056428976568):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15872947277208416, target_prob=0.07011056428976568):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_881",
    "sat": "def sat(counts: List[int], p: float=0.5008338038134629, target_prob: float=0.25083449904226224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5008338038134629, target_prob=0.25083449904226224):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_882",
    "sat": "def sat(counts: List[int], p: float=0.9988730710333396, target_prob: float=2.601191566910434e-24):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9988730710333396, target_prob=2.601191566910434e-24):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_883",
    "sat": "def sat(counts: List[int], p: float=0.21296826646298606, target_prob: float=0.282159940324881):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21296826646298606, target_prob=0.282159940324881):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_884",
    "sat": "def sat(counts: List[int], p: float=0.23682007252028425, target_prob: float=0.0878299134048589):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23682007252028425, target_prob=0.0878299134048589):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_885",
    "sat": "def sat(counts: List[int], p: float=0.08968435472205183, target_prob: float=4.224488000371179e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08968435472205183, target_prob=4.224488000371179e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_886",
    "sat": "def sat(counts: List[int], p: float=0.7808050292907939, target_prob: float=0.0006062114764421986):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7808050292907939, target_prob=0.0006062114764421986):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_887",
    "sat": "def sat(counts: List[int], p: float=0.0775816722450191, target_prob: float=0.3659527656729559):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0775816722450191, target_prob=0.3659527656729559):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_888",
    "sat": "def sat(counts: List[int], p: float=0.4328086204196432, target_prob: float=0.18394048173451405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4328086204196432, target_prob=0.18394048173451405):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_889",
    "sat": "def sat(counts: List[int], p: float=0.3378575309295928, target_prob: float=0.3378575309295928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3378575309295928, target_prob=0.3378575309295928):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_890",
    "sat": "def sat(counts: List[int], p: float=0.10565774395016136, target_prob: float=0.188988370187047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10565774395016136, target_prob=0.188988370187047):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_891",
    "sat": "def sat(counts: List[int], p: float=0.9434635975610356, target_prob: float=0.7923199519296594):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9434635975610356, target_prob=0.7923199519296594):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_892",
    "sat": "def sat(counts: List[int], p: float=0.2602135076600034, target_prob: float=0.21862988414648785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2602135076600034, target_prob=0.21862988414648785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_893",
    "sat": "def sat(counts: List[int], p: float=0.474087529761685, target_prob: float=0.3099887963181848):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.474087529761685, target_prob=0.3099887963181848):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_894",
    "sat": "def sat(counts: List[int], p: float=0.16177915123706188, target_prob: float=0.41380172180334945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16177915123706188, target_prob=0.41380172180334945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_895",
    "sat": "def sat(counts: List[int], p: float=0.639469940909899, target_prob: float=0.11986836049638229):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.639469940909899, target_prob=0.11986836049638229):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_896",
    "sat": "def sat(counts: List[int], p: float=0.32414162291407067, target_prob: float=0.32414162291407067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32414162291407067, target_prob=0.32414162291407067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_897",
    "sat": "def sat(counts: List[int], p: float=0.8889095905375118, target_prob: float=0.0018051475774598768):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8889095905375118, target_prob=0.0018051475774598768):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_898",
    "sat": "def sat(counts: List[int], p: float=0.30854213883052684, target_prob: float=2.5341386444604168e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30854213883052684, target_prob=2.5341386444604168e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_899",
    "sat": "def sat(counts: List[int], p: float=0.9591020844166154, target_prob: float=0.8115666165768257):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9591020844166154, target_prob=0.8115666165768257):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_900",
    "sat": "def sat(counts: List[int], p: float=0.18259476968293487, target_prob: float=0.0002029745869819877):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18259476968293487, target_prob=0.0002029745869819877):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_901",
    "sat": "def sat(counts: List[int], p: float=0.3229892784349161, target_prob: float=0.036839860401292016):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3229892784349161, target_prob=0.036839860401292016):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_902",
    "sat": "def sat(counts: List[int], p: float=0.8643584027153943, target_prob: float=0.21483595738360903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8643584027153943, target_prob=0.21483595738360903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_903",
    "sat": "def sat(counts: List[int], p: float=0.006576609218631457, target_prob: float=4.325178881458827e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.006576609218631457, target_prob=4.325178881458827e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_904",
    "sat": "def sat(counts: List[int], p: float=0.6193772336538299, target_prob: float=6.381865008838863e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6193772336538299, target_prob=6.381865008838863e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_905",
    "sat": "def sat(counts: List[int], p: float=0.3321477023459145, target_prob: float=0.25514290717273297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3321477023459145, target_prob=0.25514290717273297):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_906",
    "sat": "def sat(counts: List[int], p: float=0.44972284638932525, target_prob: float=0.00033841492427812093):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44972284638932525, target_prob=0.00033841492427812093):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_907",
    "sat": "def sat(counts: List[int], p: float=0.795949649082165, target_prob: float=0.3911258990220388):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.795949649082165, target_prob=0.3911258990220388):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_908",
    "sat": "def sat(counts: List[int], p: float=0.26718159516583917, target_prob: float=0.07019130266691545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26718159516583917, target_prob=0.07019130266691545):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_909",
    "sat": "def sat(counts: List[int], p: float=0.59058103692584, target_prob: float=0.35078915194006344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.59058103692584, target_prob=0.35078915194006344):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_910",
    "sat": "def sat(counts: List[int], p: float=0.5575031704126342, target_prob: float=0.30669887231892706):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5575031704126342, target_prob=0.30669887231892706):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_911",
    "sat": "def sat(counts: List[int], p: float=0.903135943178389, target_prob: float=0.0003975335136202833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.903135943178389, target_prob=0.0003975335136202833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_912",
    "sat": "def sat(counts: List[int], p: float=0.7176096919482698, target_prob: float=0.28239030805173015):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7176096919482698, target_prob=0.28239030805173015):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_913",
    "sat": "def sat(counts: List[int], p: float=0.8480655023959669, target_prob: float=0.011375796459465206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8480655023959669, target_prob=0.011375796459465206):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_914",
    "sat": "def sat(counts: List[int], p: float=0.6283821197027059, target_prob: float=0.37161788029729415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6283821197027059, target_prob=0.37161788029729415):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_915",
    "sat": "def sat(counts: List[int], p: float=0.8762321790881974, target_prob: float=0.3926739761409805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8762321790881974, target_prob=0.3926739761409805):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_916",
    "sat": "def sat(counts: List[int], p: float=0.09208186922745498, target_prob: float=4.759563666343774e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09208186922745498, target_prob=4.759563666343774e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_917",
    "sat": "def sat(counts: List[int], p: float=0.9478647704420902, target_prob: float=3.50139854463343e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9478647704420902, target_prob=3.50139854463343e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_918",
    "sat": "def sat(counts: List[int], p: float=0.926504491878601, target_prob: float=3.8656126797961315e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.926504491878601, target_prob=3.8656126797961315e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_919",
    "sat": "def sat(counts: List[int], p: float=0.34750485141042864, target_prob: float=0.11574015326092844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34750485141042864, target_prob=0.11574015326092844):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_920",
    "sat": "def sat(counts: List[int], p: float=0.7694178609955961, target_prob: float=0.3088751294749552):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7694178609955961, target_prob=0.3088751294749552):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_921",
    "sat": "def sat(counts: List[int], p: float=0.034053450590563195, target_prob: float=1.8820967715310364e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.034053450590563195, target_prob=1.8820967715310364e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_922",
    "sat": "def sat(counts: List[int], p: float=0.8232341312857899, target_prob: float=0.005523256798078702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8232341312857899, target_prob=0.005523256798078702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_923",
    "sat": "def sat(counts: List[int], p: float=0.12844649258359087, target_prob: float=0.0780207938849333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12844649258359087, target_prob=0.0780207938849333):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_924",
    "sat": "def sat(counts: List[int], p: float=0.6452449326202303, target_prob: float=0.049126015207751714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6452449326202303, target_prob=0.049126015207751714):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_925",
    "sat": "def sat(counts: List[int], p: float=0.15120147761645564, target_prob: float=0.04104602687916081):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15120147761645564, target_prob=0.04104602687916081):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_926",
    "sat": "def sat(counts: List[int], p: float=0.5963958499416478, target_prob: float=0.21213085293519696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5963958499416478, target_prob=0.21213085293519696):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_927",
    "sat": "def sat(counts: List[int], p: float=0.3765473268967149, target_prob: float=0.4695188750073068):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3765473268967149, target_prob=0.4695188750073068):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_928",
    "sat": "def sat(counts: List[int], p: float=0.4893792094360093, target_prob: float=0.24421720908548888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4893792094360093, target_prob=0.24421720908548888):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_929",
    "sat": "def sat(counts: List[int], p: float=0.41944709534235036, target_prob: float=0.08985051520282783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41944709534235036, target_prob=0.08985051520282783):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_930",
    "sat": "def sat(counts: List[int], p: float=0.7168543186203724, target_prob: float=0.2098077344717944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7168543186203724, target_prob=0.2098077344717944):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_931",
    "sat": "def sat(counts: List[int], p: float=0.5274327622711353, target_prob: float=0.09128500457847173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5274327622711353, target_prob=0.09128500457847173):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_932",
    "sat": "def sat(counts: List[int], p: float=0.9809471761277412, target_prob: float=6.655325501096862e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9809471761277412, target_prob=6.655325501096862e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_933",
    "sat": "def sat(counts: List[int], p: float=0.985696495426279, target_prob: float=1.7520224767999185e-15):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.985696495426279, target_prob=1.7520224767999185e-15):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_934",
    "sat": "def sat(counts: List[int], p: float=0.5224663470274659, target_prob: float=0.49899052650248293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5224663470274659, target_prob=0.49899052650248293):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_935",
    "sat": "def sat(counts: List[int], p: float=0.9940276822295433, target_prob: float=1.1577349498041396e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9940276822295433, target_prob=1.1577349498041396e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_936",
    "sat": "def sat(counts: List[int], p: float=0.5515337101295608, target_prob: float=0.09253121139785779):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5515337101295608, target_prob=0.09253121139785779):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_937",
    "sat": "def sat(counts: List[int], p: float=0.8798759528639658, target_prob: float=0.014429786700340164):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8798759528639658, target_prob=0.014429786700340164):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_938",
    "sat": "def sat(counts: List[int], p: float=0.9592448271017634, target_prob: float=0.846677197203449):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9592448271017634, target_prob=0.846677197203449):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_939",
    "sat": "def sat(counts: List[int], p: float=0.3526281189943705, target_prob: float=0.24149545818813914):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3526281189943705, target_prob=0.24149545818813914):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_940",
    "sat": "def sat(counts: List[int], p: float=0.1547432747016505, target_prob: float=0.06072023673307675):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1547432747016505, target_prob=0.06072023673307675):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_941",
    "sat": "def sat(counts: List[int], p: float=0.931820250833236, target_prob: float=0.931820250833236):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.931820250833236, target_prob=0.931820250833236):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_942",
    "sat": "def sat(counts: List[int], p: float=0.4562523693284253, target_prob: float=0.00039088709060862463):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4562523693284253, target_prob=0.00039088709060862463):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_943",
    "sat": "def sat(counts: List[int], p: float=0.5244247133957713, target_prob: float=0.23892500819036375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5244247133957713, target_prob=0.23892500819036375):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_944",
    "sat": "def sat(counts: List[int], p: float=0.8778087780740429, target_prob: float=0.8778087780740429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8778087780740429, target_prob=0.8778087780740429):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_945",
    "sat": "def sat(counts: List[int], p: float=0.06522571826349977, target_prob: float=0.8168085322529759):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06522571826349977, target_prob=0.8168085322529759):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_946",
    "sat": "def sat(counts: List[int], p: float=0.2405717552330061, target_prob: float=0.4214682505466143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2405717552330061, target_prob=0.4214682505466143):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_947",
    "sat": "def sat(counts: List[int], p: float=0.230859984794072, target_prob: float=0.01112584222815895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.230859984794072, target_prob=0.01112584222815895):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_948",
    "sat": "def sat(counts: List[int], p: float=0.35389319831402044, target_prob: float=0.04450671283466669):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35389319831402044, target_prob=0.04450671283466669):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_949",
    "sat": "def sat(counts: List[int], p: float=0.14733656053216915, target_prob: float=0.3963459433433967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14733656053216915, target_prob=0.3963459433433967):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_950",
    "sat": "def sat(counts: List[int], p: float=0.7772580685867786, target_prob: float=0.0020658576673251226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7772580685867786, target_prob=0.0020658576673251226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_951",
    "sat": "def sat(counts: List[int], p: float=0.16937482039028584, target_prob: float=0.004858996016754262):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16937482039028584, target_prob=0.004858996016754262):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_952",
    "sat": "def sat(counts: List[int], p: float=0.6763266781053456, target_prob: float=0.2687146448625426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6763266781053456, target_prob=0.2687146448625426):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_953",
    "sat": "def sat(counts: List[int], p: float=0.6574561755708698, target_prob: float=0.019551879091786867):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6574561755708698, target_prob=0.019551879091786867):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_954",
    "sat": "def sat(counts: List[int], p: float=0.42931331149692775, target_prob: float=0.2590935947053401):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42931331149692775, target_prob=0.2590935947053401):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_955",
    "sat": "def sat(counts: List[int], p: float=0.6966669177274577, target_prob: float=0.009587276589223225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6966669177274577, target_prob=0.009587276589223225):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_956",
    "sat": "def sat(counts: List[int], p: float=0.47233392795011364, target_prob: float=0.2784314835925559):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47233392795011364, target_prob=0.2784314835925559):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_957",
    "sat": "def sat(counts: List[int], p: float=0.06660182425527938, target_prob: float=1.5178729035592522e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06660182425527938, target_prob=1.5178729035592522e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_958",
    "sat": "def sat(counts: List[int], p: float=0.6784865859507789, target_prob: float=0.4362850772712704):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6784865859507789, target_prob=0.4362850772712704):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_959",
    "sat": "def sat(counts: List[int], p: float=0.4497166971099713, target_prob: float=0.08740878114086681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4497166971099713, target_prob=0.08740878114086681):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_960",
    "sat": "def sat(counts: List[int], p: float=0.12854908257176256, target_prob: float=7.456788963068693e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12854908257176256, target_prob=7.456788963068693e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_961",
    "sat": "def sat(counts: List[int], p: float=0.5170945046477415, target_prob: float=0.37412384609504135):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5170945046477415, target_prob=0.37412384609504135):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_962",
    "sat": "def sat(counts: List[int], p: float=0.7026747472356857, target_prob: float=0.7026747472356857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7026747472356857, target_prob=0.7026747472356857):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_963",
    "sat": "def sat(counts: List[int], p: float=0.4593292667717258, target_prob: float=0.21098337531305125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4593292667717258, target_prob=0.21098337531305125):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_964",
    "sat": "def sat(counts: List[int], p: float=0.059058438689616466, target_prob: float=1.3358398824164184e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.059058438689616466, target_prob=1.3358398824164184e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_965",
    "sat": "def sat(counts: List[int], p: float=0.34433307359238285, target_prob: float=0.6556669264076171):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34433307359238285, target_prob=0.6556669264076171):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_966",
    "sat": "def sat(counts: List[int], p: float=0.5166205310974158, target_prob: float=0.0006964372661825249):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5166205310974158, target_prob=0.0006964372661825249):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_967",
    "sat": "def sat(counts: List[int], p: float=0.8564400649318402, target_prob: float=0.14355993506815978):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8564400649318402, target_prob=0.14355993506815978):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_968",
    "sat": "def sat(counts: List[int], p: float=0.8472017564259402, target_prob: float=0.00916065628380102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8472017564259402, target_prob=0.00916065628380102):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_969",
    "sat": "def sat(counts: List[int], p: float=0.1586077041692482, target_prob: float=9.376532082270889e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1586077041692482, target_prob=9.376532082270889e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_970",
    "sat": "def sat(counts: List[int], p: float=0.5119986264180885, target_prob: float=0.14518541083928682):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5119986264180885, target_prob=0.14518541083928682):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_971",
    "sat": "def sat(counts: List[int], p: float=0.5558903455880327, target_prob: float=0.3289204038841134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5558903455880327, target_prob=0.3289204038841134):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_972",
    "sat": "def sat(counts: List[int], p: float=0.16062237238437493, target_prob: float=0.2257450908374562):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16062237238437493, target_prob=0.2257450908374562):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_973",
    "sat": "def sat(counts: List[int], p: float=0.35902802506360343, target_prob: float=0.30300829660171674):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35902802506360343, target_prob=0.30300829660171674):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_974",
    "sat": "def sat(counts: List[int], p: float=0.715789312557191, target_prob: float=0.11762283278051211):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.715789312557191, target_prob=0.11762283278051211):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_975",
    "sat": "def sat(counts: List[int], p: float=0.6808739500933549, target_prob: float=0.22256691610085338):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6808739500933549, target_prob=0.22256691610085338):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_976",
    "sat": "def sat(counts: List[int], p: float=0.11429194541536747, target_prob: float=0.2971022504696026):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11429194541536747, target_prob=0.2971022504696026):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_977",
    "sat": "def sat(counts: List[int], p: float=0.6988597093324536, target_prob: float=0.4884048933282415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6988597093324536, target_prob=0.4884048933282415):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_978",
    "sat": "def sat(counts: List[int], p: float=0.009189558572695766, target_prob: float=0.01821022117186952):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.009189558572695766, target_prob=0.01821022117186952):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_979",
    "sat": "def sat(counts: List[int], p: float=0.3718927329395364, target_prob: float=0.24780008691607863):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3718927329395364, target_prob=0.24780008691607863):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_980",
    "sat": "def sat(counts: List[int], p: float=0.22157352180089473, target_prob: float=0.4067787572649313):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22157352180089473, target_prob=0.4067787572649313):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_981",
    "sat": "def sat(counts: List[int], p: float=0.983632154327646, target_prob: float=1.922866482488502e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.983632154327646, target_prob=1.922866482488502e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_982",
    "sat": "def sat(counts: List[int], p: float=0.9053520940628199, target_prob: float=6.095356167891816e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9053520940628199, target_prob=6.095356167891816e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_983",
    "sat": "def sat(counts: List[int], p: float=0.5116758040598696, target_prob: float=0.009182568248577768):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5116758040598696, target_prob=0.009182568248577768):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_984",
    "sat": "def sat(counts: List[int], p: float=0.014274052586420227, target_prob: float=9.520882872410784e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.014274052586420227, target_prob=9.520882872410784e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_985",
    "sat": "def sat(counts: List[int], p: float=0.6509766427323287, target_prob: float=0.6509766427323287):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6509766427323287, target_prob=0.6509766427323287):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_986",
    "sat": "def sat(counts: List[int], p: float=0.867072542013652, target_prob: float=0.02786189775003758):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.867072542013652, target_prob=0.02786189775003758):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_987",
    "sat": "def sat(counts: List[int], p: float=0.8753422754516577, target_prob: float=0.2865472580984655):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8753422754516577, target_prob=0.2865472580984655):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_988",
    "sat": "def sat(counts: List[int], p: float=0.7981083853237368, target_prob: float=0.7981083853237368):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7981083853237368, target_prob=0.7981083853237368):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_989",
    "sat": "def sat(counts: List[int], p: float=0.666074314540292, target_prob: float=0.666074314540292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.666074314540292, target_prob=0.666074314540292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_990",
    "sat": "def sat(counts: List[int], p: float=0.8113181014675124, target_prob: float=0.3187880789463346):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8113181014675124, target_prob=0.3187880789463346):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_991",
    "sat": "def sat(counts: List[int], p: float=0.26537702778464645, target_prob: float=0.04014889267239709):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26537702778464645, target_prob=0.04014889267239709):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_992",
    "sat": "def sat(counts: List[int], p: float=0.5617906197033761, target_prob: float=0.4923638386333455):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5617906197033761, target_prob=0.4923638386333455):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_993",
    "sat": "def sat(counts: List[int], p: float=0.6646560080019511, target_prob: float=0.4417676089730897):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6646560080019511, target_prob=0.4417676089730897):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_994",
    "sat": "def sat(counts: List[int], p: float=0.9419466830964223, target_prob: float=5.3493926803344286e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9419466830964223, target_prob=5.3493926803344286e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_995",
    "sat": "def sat(counts: List[int], p: float=0.6742018291920107, target_prob: float=0.19774920402491333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6742018291920107, target_prob=0.19774920402491333):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_996",
    "sat": "def sat(counts: List[int], p: float=0.2356609095769383, target_prob: float=0.03125738037554038):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2356609095769383, target_prob=0.03125738037554038):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_997",
    "sat": "def sat(counts: List[int], p: float=0.8685638119441695, target_prob: float=0.39211825208241885):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8685638119441695, target_prob=0.39211825208241885):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_998",
    "sat": "def sat(counts: List[int], p: float=0.5032233879420137, target_prob: float=0.3725669741739772):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5032233879420137, target_prob=0.3725669741739772):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_999",
    "sat": "def sat(counts: List[int], p: float=0.6111046726304952, target_prob: float=0.001345330770428227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6111046726304952, target_prob=0.001345330770428227):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "ExponentialProbability_0",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.5):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_1",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.4377831189366187):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.4377831189366187):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_2",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.4696658807570542):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.4696658807570542):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_3",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.07065230859252358):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.07065230859252358):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_4",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.7248811218694797):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.7248811218694797):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_5",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.09977870572613567):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.09977870572613567):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_6",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.13513519602176394):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.13513519602176394):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_7",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.6332253735040363):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.6332253735040363):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_8",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.15784142970276505):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.15784142970276505):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_9",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.77476337772637):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.77476337772637):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_10",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.03146669037996097):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.03146669037996097):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_11",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.8992024981214418):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.8992024981214418):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_12",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.12626911933709728):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.12626911933709728):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_13",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.6067923396033):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.6067923396033):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_14",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.6174883006771207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.6174883006771207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_15",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.004742802586306216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.004742802586306216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_16",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.08807495207276816):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.08807495207276816):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_17",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.22733545174079983):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.22733545174079983):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_18",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.19628499546233635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.19628499546233635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_19",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.11421587034844127):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.11421587034844127):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_20",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.2862686703759897):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.2862686703759897):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_21",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.09782708237564075):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.09782708237564075):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_22",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.21197960196308208):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.21197960196308208):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_23",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.5824323751489046):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.5824323751489046):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_24",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.007825391286578998):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.007825391286578998):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_25",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.43123922886718646):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.43123922886718646):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_26",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.13857958796377812):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.13857958796377812):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_27",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.35790559775628283):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.35790559775628283):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_28",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.08459889746582683):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.08459889746582683):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_29",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.6545513603228929):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.6545513603228929):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_30",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.7614901481201518):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.7614901481201518):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_31",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.5808060930335353):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.5808060930335353):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_32",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.9541158888114395):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.9541158888114395):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_33",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.41688556707732183):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.41688556707732183):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_34",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.10122392321875928):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.10122392321875928):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_35",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.5858784859141649):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.5858784859141649):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_36",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.7253945983773102):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.7253945983773102):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_37",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.775258650158668):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.775258650158668):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_38",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.9895967901226632):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.9895967901226632):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_39",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.03502316918344872):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.03502316918344872):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_40",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.5098381509191847):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.5098381509191847):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_41",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.802569050679426):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.802569050679426):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_42",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.6020554769079631):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.6020554769079631):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_43",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.7794074672512918):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.7794074672512918):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_44",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.8209016763072855):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.8209016763072855):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_45",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.5081560923659318):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.5081560923659318):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_46",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.3758530310592515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.3758530310592515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_47",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.5606746019610924):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.5606746019610924):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_48",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.6664791872905199):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.6664791872905199):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_49",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.007922895131751817):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.007922895131751817):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_50",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.8504913689942161):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.8504913689942161):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_51",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.0687841189577083):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.0687841189577083):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_52",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.9671387384133937):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.9671387384133937):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_53",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.5131641388135519):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.5131641388135519):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_54",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.29878812897954266):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.29878812897954266):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_55",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.11648295086208249):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.11648295086208249):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_56",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.6399101957527804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.6399101957527804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_57",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.0008606902347518819):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.0008606902347518819):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_58",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.4696428457295653):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.4696428457295653):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_59",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.244185779990303):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.244185779990303):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_60",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.2943935739152823):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.2943935739152823):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_61",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.9199654511678914):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.9199654511678914):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_62",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.858831600338873):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.858831600338873):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_63",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.22029454371980717):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.22029454371980717):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_64",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.9146039194711179):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.9146039194711179):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_65",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.052665438915439955):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.052665438915439955):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_66",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.2154452090098059):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.2154452090098059):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_67",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.7804070125087307):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.7804070125087307):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_68",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.20351559702362043):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.20351559702362043):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_69",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.2668605982687423):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.2668605982687423):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_70",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.16701768584653798):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.16701768584653798):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_71",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.1505117575155348):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.1505117575155348):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_72",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.7887608182420727):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.7887608182420727):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_73",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.16467082244022413):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.16467082244022413):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_74",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.7887795993816682):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.7887795993816682):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_75",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.6660194468240512):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.6660194468240512):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_76",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.5336934355819042):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.5336934355819042):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_77",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.4182110182151555):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.4182110182151555):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_78",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.24144354531117618):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.24144354531117618):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_79",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.19101540598881006):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.19101540598881006):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_80",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.22000874442520502):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.22000874442520502):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_81",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.4475966894695288):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.4475966894695288):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_82",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.8512323648167771):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.8512323648167771):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_83",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.1530005185028227):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.1530005185028227):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_84",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.7284172776421278):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.7284172776421278):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_85",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.9737658547295609):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.9737658547295609):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_86",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.7660855883884451):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.7660855883884451):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_87",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.9695165914279774):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.9695165914279774):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_88",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.045685810463304666):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.045685810463304666):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_89",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.4721617524726762):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.4721617524726762):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_90",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.8009657914974851):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.8009657914974851):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_91",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.845462114636189):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.845462114636189):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_92",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.24614826291326242):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.24614826291326242):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_93",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.7250132189562183):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.7250132189562183):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_94",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.7530874793548152):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.7530874793548152):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_95",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.4987944700776743):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.4987944700776743):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_96",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.8705904012555628):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.8705904012555628):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_97",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.4605923173566112):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.4605923173566112):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_98",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.924259519463325):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.924259519463325):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_99",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.9116930340376402):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.9116930340376402):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_100",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.30817737768270403):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.30817737768270403):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_101",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.6410214775315531):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.6410214775315531):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_102",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.6120828668249619):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.6120828668249619):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_103",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.9931944565745083):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.9931944565745083):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_104",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.37367926832642806):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.37367926832642806):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_105",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.7378928104474289):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.7378928104474289):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_106",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.684183940801535):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.684183940801535):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_107",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.8022837925775312):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.8022837925775312):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_108",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.21688568413103693):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.21688568413103693):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_109",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.5241551025763284):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.5241551025763284):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_110",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.0038971101422015098):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.0038971101422015098):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_111",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.525117723776889):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.525117723776889):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_112",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.4339522980966821):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.4339522980966821):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_113",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.8089378361226205):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.8089378361226205):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_114",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.09480961697731138):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.09480961697731138):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_115",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.2251160912692166):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.2251160912692166):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_116",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.11833751620376132):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.11833751620376132):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_117",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.6177671208750224):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.6177671208750224):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_118",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.03831910038825015):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.03831910038825015):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_119",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.7004994295224722):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.7004994295224722):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_120",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.24779676304483633):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.24779676304483633):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_121",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.969754145881908):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.969754145881908):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_122",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.48672912508893174):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.48672912508893174):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_123",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.4194751480736105):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.4194751480736105):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_124",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.6454244433662913):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.6454244433662913):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_125",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.6784617473600525):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.6784617473600525):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_126",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.26433798677469633):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.26433798677469633):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_127",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.7943388298449419):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.7943388298449419):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_128",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.0868292601682299):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.0868292601682299):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_129",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.1674837718860468):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.1674837718860468):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_130",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.9462648431495823):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.9462648431495823):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_131",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.9703156067594658):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.9703156067594658):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_132",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.3043887339117045):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.3043887339117045):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_133",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.49033166283027585):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.49033166283027585):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_134",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.8069265787934752):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.8069265787934752):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_135",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.2958056829381225):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.2958056829381225):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_136",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.2584508168711054):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.2584508168711054):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_137",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.37621151305251854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.37621151305251854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_138",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.4978688617670324):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.4978688617670324):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_139",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.778868097527861):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.778868097527861):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_140",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.5141542223275475):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.5141542223275475):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_141",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.11497102711427665):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.11497102711427665):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_142",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.3508875092294169):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.3508875092294169):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_143",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.2504444651934161):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.2504444651934161):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_144",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.2863313068716604):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.2863313068716604):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_145",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.7910113728375615):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.7910113728375615):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_146",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.19600318652516846):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.19600318652516846):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_147",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.557893562169243):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.557893562169243):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_148",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.6909856227681367):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.6909856227681367):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_149",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.693669394762575):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.693669394762575):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_150",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.5129131053578634):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.5129131053578634):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_151",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.5074321366636678):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.5074321366636678):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_152",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.9634774649626325):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.9634774649626325):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_153",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.806032485480152):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.806032485480152):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_154",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.06766521042896134):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.06766521042896134):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_155",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.7310588129250867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.7310588129250867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_156",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.3258813253861941):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.3258813253861941):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_157",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.7633393583174916):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.7633393583174916):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_158",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.5998487201618841):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.5998487201618841):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_159",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.4275833465124107):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.4275833465124107):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_160",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.3450427513177573):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.3450427513177573):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_161",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.8768634013582095):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.8768634013582095):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_162",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.9145837546693509):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.9145837546693509):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_163",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.22564749970183418):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.22564749970183418):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_164",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.910133647706299):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.910133647706299):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_165",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7220054602941484):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7220054602941484):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_166",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.9805800954030052):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.9805800954030052):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_167",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.9758313930551722):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.9758313930551722):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_168",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.791143864814091):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.791143864814091):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_169",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.39736134840980997):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.39736134840980997):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_170",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.38672193528794774):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.38672193528794774):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_171",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.30848777859776055):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.30848777859776055):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_172",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7685277482279962):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7685277482279962):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_173",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.9752879313460009):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.9752879313460009):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_174",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.13794698283894158):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.13794698283894158):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_175",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.7626941236662591):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.7626941236662591):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_176",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.23330531264878562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.23330531264878562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_177",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.09129737025342377):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.09129737025342377):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_178",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.6699239757956841):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.6699239757956841):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_179",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.6405463559089011):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.6405463559089011):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_180",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.805292609545049):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.805292609545049):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_181",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.49526466890853094):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.49526466890853094):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_182",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.5736456049480457):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.5736456049480457):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_183",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.24175961074994823):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.24175961074994823):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_184",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.42829107208650663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.42829107208650663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_185",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.8880543764017541):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.8880543764017541):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_186",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.5585150308555635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.5585150308555635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_187",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.15648220507349186):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.15648220507349186):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_188",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.14235522258712585):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.14235522258712585):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_189",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.7165818296412308):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.7165818296412308):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_190",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.20398361239765783):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.20398361239765783):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_191",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.9893239920428272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.9893239920428272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_192",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.6441395598337273):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.6441395598337273):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_193",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.2887100637322614):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.2887100637322614):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_194",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.3705627794604698):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.3705627794604698):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_195",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.4916848160362546):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.4916848160362546):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_196",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.08431853104641329):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.08431853104641329):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_197",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.3336681998559212):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.3336681998559212):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_198",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.8365237636243772):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.8365237636243772):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_199",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.7171193658915286):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.7171193658915286):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_200",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.31092287394558893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.31092287394558893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_201",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.14114460667524487):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.14114460667524487):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_202",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.5354413035088867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.5354413035088867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_203",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.2509865616621487):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.2509865616621487):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_204",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9571252843622751):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9571252843622751):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_205",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.5870161942733676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.5870161942733676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_206",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.28898665059445516):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.28898665059445516):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_207",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.739648502078156):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.739648502078156):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_208",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.1545433261954654):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.1545433261954654):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_209",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.4459285498112312):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.4459285498112312):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_210",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.9710293958866333):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.9710293958866333):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_211",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.3931155449675553):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.3931155449675553):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_212",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.11916914507061371):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.11916914507061371):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_213",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.2391779389219123):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.2391779389219123):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_214",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.08344039504692025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.08344039504692025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_215",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.49883145666732664):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.49883145666732664):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_216",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.13748755681728497):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.13748755681728497):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_217",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.29562203550254473):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.29562203550254473):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_218",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.07035371499442178):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.07035371499442178):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_219",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.6495468110516562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.6495468110516562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_220",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.9409907950253883):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.9409907950253883):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_221",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.4598822553959627):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.4598822553959627):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_222",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.9353869702656237):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.9353869702656237):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_223",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.3660769393880047):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.3660769393880047):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_224",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.47521949059298163):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.47521949059298163):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_225",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.5341334629377015):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.5341334629377015):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_226",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.46206965024227176):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.46206965024227176):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_227",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.10160317307089328):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.10160317307089328):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_228",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.022073623707619672):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.022073623707619672):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_229",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.44421824429061096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.44421824429061096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_230",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.10862890133546887):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.10862890133546887):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_231",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.30888294205896705):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.30888294205896705):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_232",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.25240441207507336):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.25240441207507336):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_233",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.6779752943223926):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.6779752943223926):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_234",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.654400887330458):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.654400887330458):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_235",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.380419742441651):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.380419742441651):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_236",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.42337282923722097):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.42337282923722097):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_237",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.2738342038825782):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.2738342038825782):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_238",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.8474714702065892):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.8474714702065892):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_239",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.9911100556115289):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.9911100556115289):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_240",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.9555837706525441):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.9555837706525441):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_241",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.08985621219442319):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.08985621219442319):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_242",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.07653301145687519):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.07653301145687519):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_243",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6774871937788549):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6774871937788549):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_244",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.7019475847561751):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.7019475847561751):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_245",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.781921478229985):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.781921478229985):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_246",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.573406912175074):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.573406912175074):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_247",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.7414387247758064):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.7414387247758064):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_248",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.7522718035826728):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.7522718035826728):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_249",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.5585531144964635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.5585531144964635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_250",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.8341168431876961):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.8341168431876961):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_251",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.6171418355705477):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.6171418355705477):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_252",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.6099287400211867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.6099287400211867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_253",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.5901596550216746):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.5901596550216746):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_254",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.8494959576802172):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.8494959576802172):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_255",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.14490669480231044):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.14490669480231044):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_256",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.27267377795701986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.27267377795701986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_257",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.7724179554190499):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.7724179554190499):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_258",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.17740858392730663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.17740858392730663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_259",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6951584804080437):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6951584804080437):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_260",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.19510817885940934):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.19510817885940934):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_261",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.011836739766476478):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.011836739766476478):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_262",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.7032826128894505):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.7032826128894505):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_263",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.19995991952179915):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.19995991952179915):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_264",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.006841134311192487):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.006841134311192487):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_265",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.3102244087964857):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.3102244087964857):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_266",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.8357314767457823):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.8357314767457823):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_267",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.2559873272645893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.2559873272645893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_268",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.7699186230758893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.7699186230758893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_269",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.06741214764939452):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.06741214764939452):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_270",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.3557918989826725):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.3557918989826725):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_271",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.40266909334489165):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.40266909334489165):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_272",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.2371339850462162):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.2371339850462162):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_273",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.444102127676789):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.444102127676789):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_274",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.15626825628142882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.15626825628142882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_275",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.7318137703069937):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.7318137703069937):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_276",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.1431380144849267):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.1431380144849267):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_277",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.2887925592434448):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.2887925592434448):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_278",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.9274243815469363):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.9274243815469363):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_279",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.7195992276181231):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.7195992276181231):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_280",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.2875335494968845):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.2875335494968845):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_281",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.33503616026353855):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.33503616026353855):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_282",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.764587225706097):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.764587225706097):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_283",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.4664206375320409):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.4664206375320409):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_284",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.8271287173928795):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.8271287173928795):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_285",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.5126547392495712):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.5126547392495712):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_286",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.24168757409600206):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.24168757409600206):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_287",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.11781956093030332):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.11781956093030332):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_288",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.3941378306485652):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.3941378306485652):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_289",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.030545560538947414):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.030545560538947414):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_290",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.25782867590940217):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.25782867590940217):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_291",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.43403315931387576):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.43403315931387576):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_292",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.49807551891702606):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.49807551891702606):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_293",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.5108496825058699):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.5108496825058699):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_294",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.7554379389832433):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.7554379389832433):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_295",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.9974193796741964):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.9974193796741964):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_296",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=2.0462132816367884e-05):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=2.0462132816367884e-05):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_297",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.017556311273302705):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.017556311273302705):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_298",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.4452245551793892):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.4452245551793892):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_299",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.5562521980544506):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.5562521980544506):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_300",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.1301328187034274):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.1301328187034274):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_301",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.6282153631272526):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.6282153631272526):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_302",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.9831152337744343):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.9831152337744343):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_303",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.9360421310562929):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.9360421310562929):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_304",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.5011085143141594):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.5011085143141594):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_305",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.985309121704028):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.985309121704028):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_306",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.006213603599826145):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.006213603599826145):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_307",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.5624547996768772):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.5624547996768772):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_308",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.17575154851813202):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.17575154851813202):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_309",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.37312061784048056):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.37312061784048056):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_310",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.10626217259229165):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.10626217259229165):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_311",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.17473858110288498):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.17473858110288498):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_312",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.7571926563513725):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.7571926563513725):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_313",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6056612878972676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6056612878972676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_314",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.011864994339528367):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.011864994339528367):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_315",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.8655027223085276):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.8655027223085276):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_316",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.885345339022922):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.885345339022922):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_317",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.6235580785902114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.6235580785902114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_318",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.5337333919862081):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.5337333919862081):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_319",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.2691098561417008):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.2691098561417008):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_320",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.874033769510824):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.874033769510824):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_321",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.9608354257749816):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.9608354257749816):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_322",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.666753149071551):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.666753149071551):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_323",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.23847299348345719):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.23847299348345719):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_324",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.6779155282981996):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.6779155282981996):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_325",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.8224329653191882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.8224329653191882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_326",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.5601567818609609):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.5601567818609609):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_327",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.7362258090017412):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.7362258090017412):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_328",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.47067352195197476):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.47067352195197476):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_329",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.538409837655214):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.538409837655214):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_330",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.1333046644919219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.1333046644919219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_331",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.9784488686550197):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.9784488686550197):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_332",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.21260841513752138):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.21260841513752138):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_333",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.8317035338289611):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.8317035338289611):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_334",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.7950900749112285):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.7950900749112285):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_335",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.17907190441302223):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.17907190441302223):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_336",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.13653198127817812):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.13653198127817812):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_337",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.3171479854671929):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.3171479854671929):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_338",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.6076557217765219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.6076557217765219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_339",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.860907336447328):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.860907336447328):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_340",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.3741011590900065):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.3741011590900065):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_341",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.487147182910613):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.487147182910613):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_342",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.9503285813835494):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.9503285813835494):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_343",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.4527143919299005):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.4527143919299005):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_344",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.35009105628153714):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.35009105628153714):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_345",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.6487383365857207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.6487383365857207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_346",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.789452338244973):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.789452338244973):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_347",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.01570652621323998):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.01570652621323998):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_348",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.39012775965798374):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.39012775965798374):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_349",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.5074397922146082):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.5074397922146082):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_350",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.770621109216477):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.770621109216477):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_351",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.058858353196269975):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.058858353196269975):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_352",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6492642372514766):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6492642372514766):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_353",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.8106457251098262):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.8106457251098262):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_354",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.36823332073889203):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.36823332073889203):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_355",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.5080149203867272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.5080149203867272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_356",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.3001713618303389):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.3001713618303389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_357",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.08367783172828025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.08367783172828025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_358",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.7003203923310336):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.7003203923310336):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_359",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.43843721633626176):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.43843721633626176):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_360",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.847807567855237):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.847807567855237):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_361",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.9570651623636772):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.9570651623636772):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_362",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.12493666701346628):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.12493666701346628):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_363",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.2271106945161001):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.2271106945161001):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_364",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.20169238696208247):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.20169238696208247):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_365",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.670350941329093):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.670350941329093):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_366",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.7555481464447145):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.7555481464447145):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_367",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.13516351796137616):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.13516351796137616):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_368",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.6543841328378447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.6543841328378447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_369",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.72259388457896):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.72259388457896):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_370",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.9587545665852287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.9587545665852287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_371",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.8382162719813591):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.8382162719813591):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_372",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.14053610438166253):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.14053610438166253):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_373",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.0321093360276723):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.0321093360276723):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_374",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.8055370150117772):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.8055370150117772):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_375",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.8759376812483947):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.8759376812483947):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_376",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.1446515144649292):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.1446515144649292):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_377",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.05097721922802467):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.05097721922802467):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_378",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.1225856216212664):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.1225856216212664):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_379",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.4980627753002025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.4980627753002025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_380",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.05070038825005563):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.05070038825005563):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_381",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.08589301446102549):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.08589301446102549):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_382",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.07753724190757583):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.07753724190757583):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_383",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.4609211890510696):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.4609211890510696):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_384",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.8978908269530924):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.8978908269530924):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_385",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.11854550242767437):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.11854550242767437):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_386",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.5178853422081159):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.5178853422081159):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_387",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.5442024841244346):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.5442024841244346):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_388",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.5440560634745445):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.5440560634745445):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_389",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.563958604748818):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.563958604748818):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_390",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.0800131220087118):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.0800131220087118):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_391",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.7425260722619571):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.7425260722619571):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_392",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.45632605071903753):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.45632605071903753):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_393",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.23864122362945817):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.23864122362945817):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_394",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.0735747898840392):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.0735747898840392):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_395",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.6174670011594708):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.6174670011594708):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_396",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.736224290892088):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.736224290892088):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_397",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.9208234979753789):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.9208234979753789):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_398",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.8837534395718232):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.8837534395718232):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_399",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.7826645516807325):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.7826645516807325):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_400",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.034634833735778026):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.034634833735778026):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_401",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.7599584716243682):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.7599584716243682):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_402",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.5164862694226326):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.5164862694226326):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_403",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.4933748565340834):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.4933748565340834):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_404",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.13977865083241214):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.13977865083241214):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_405",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.1728761480965164):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.1728761480965164):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_406",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.1721539382029188):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.1721539382029188):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_407",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.32180899384681005):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.32180899384681005):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_408",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.31440769990735673):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.31440769990735673):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_409",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.3094150417169107):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.3094150417169107):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_410",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.8830783037879096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.8830783037879096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_411",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.9510445750682207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.9510445750682207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_412",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.6799274070551651):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.6799274070551651):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_413",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.9317646817689113):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.9317646817689113):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_414",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.4525647045729425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.4525647045729425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_415",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.1683930026622209):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.1683930026622209):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_416",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.7039568137291112):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.7039568137291112):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_417",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.15180653761230722):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.15180653761230722):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_418",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.5972935843282238):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.5972935843282238):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_419",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.10888117817993692):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.10888117817993692):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_420",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.7115184658944002):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.7115184658944002):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_421",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.06074155204273146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.06074155204273146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_422",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.3178000366833992):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.3178000366833992):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_423",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.287230746301402):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.287230746301402):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_424",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.9025026880142523):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.9025026880142523):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_425",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.006148890625668257):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.006148890625668257):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_426",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.8983009522478227):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.8983009522478227):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_427",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.9201763821967505):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.9201763821967505):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_428",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.31107653556321213):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.31107653556321213):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_429",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.04462165067186685):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.04462165067186685):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_430",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.5496480672476625):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.5496480672476625):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_431",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.8034744675252427):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.8034744675252427):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_432",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.7409016281929632):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.7409016281929632):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_433",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.8788319140615503):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.8788319140615503):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_434",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.09149208596451297):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.09149208596451297):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_435",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.5479765219929704):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.5479765219929704):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_436",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.48615758378160345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.48615758378160345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_437",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.18904346718813603):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.18904346718813603):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_438",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.07621725184804429):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.07621725184804429):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_439",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.9553224528635601):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.9553224528635601):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_440",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.9889371060719077):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.9889371060719077):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_441",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.7658463494303086):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.7658463494303086):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_442",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.4920257086360337):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.4920257086360337):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_443",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.5335958817407448):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.5335958817407448):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_444",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.9620805351588004):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.9620805351588004):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_445",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.8795448594650025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.8795448594650025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_446",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.5324340018639724):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.5324340018639724):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_447",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.5090295145967986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.5090295145967986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_448",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.34380719598511955):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.34380719598511955):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_449",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.8749963512475871):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.8749963512475871):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_450",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.447807222004311):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.447807222004311):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_451",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.7525892769226172):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.7525892769226172):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_452",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.2612407649292309):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.2612407649292309):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_453",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.8512465096464953):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.8512465096464953):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_454",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.22885442365871744):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.22885442365871744):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_455",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.04271071546119809):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.04271071546119809):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_456",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.9161067183576262):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.9161067183576262):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_457",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.6698914904440059):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.6698914904440059):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_458",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.8693805744669159):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.8693805744669159):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_459",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.3497421205790977):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.3497421205790977):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_460",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.0977375408006691):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.0977375408006691):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_461",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.06522713445845685):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.06522713445845685):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_462",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.3090622664525572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.3090622664525572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_463",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.7596545799145946):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.7596545799145946):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_464",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.9543723624900338):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.9543723624900338):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_465",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.5396839297855068):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.5396839297855068):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_466",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.6351402256733111):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.6351402256733111):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_467",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.2639076782422819):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.2639076782422819):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_468",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.2894002723238791):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.2894002723238791):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_469",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.3782192362794201):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.3782192362794201):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_470",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.13893770870381605):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.13893770870381605):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_471",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.9587366223550695):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.9587366223550695):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_472",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.03193733920162778):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.03193733920162778):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_473",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.7494634785647891):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.7494634785647891):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_474",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.24666005530112434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.24666005530112434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_475",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.5076544190016049):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.5076544190016049):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_476",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.19355934691858945):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.19355934691858945):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_477",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.9629146761051411):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.9629146761051411):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_478",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.26903295152275575):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.26903295152275575):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_479",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.2640614041427948):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.2640614041427948):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_480",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.6896055276248696):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.6896055276248696):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_481",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.525632786029607):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.525632786029607):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_482",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.4138458568405754):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.4138458568405754):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_483",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.10738558241244167):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.10738558241244167):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_484",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.5903135629460939):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.5903135629460939):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_485",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.16335200103285152):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.16335200103285152):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_486",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.8698943050165941):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.8698943050165941):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_487",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.41128492069139355):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.41128492069139355):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_488",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.44804970453670145):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.44804970453670145):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_489",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.9010340582151514):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.9010340582151514):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_490",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.5321027322953781):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.5321027322953781):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_491",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.4015359776450932):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.4015359776450932):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_492",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.09278239897175633):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.09278239897175633):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_493",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.5425177348021643):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.5425177348021643):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_494",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.17033600961679052):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.17033600961679052):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_495",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.6257561853385296):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.6257561853385296):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_496",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.5143391939789146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.5143391939789146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_497",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.36728359872737326):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.36728359872737326):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_498",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.24399919051087793):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.24399919051087793):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_499",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.37805309056265446):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.37805309056265446):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_500",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.85167920058194):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.85167920058194):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_501",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.22257868710331374):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.22257868710331374):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_502",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.7336276556881042):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.7336276556881042):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_503",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.42579669618757565):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.42579669618757565):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_504",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.2236459781233493):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.2236459781233493):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_505",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.112839340584447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.112839340584447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_506",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.6517052830667774):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.6517052830667774):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_507",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.22532698468007173):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.22532698468007173):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_508",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.1493288242730486):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.1493288242730486):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_509",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.6007432768833053):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.6007432768833053):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_510",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.127282149620203):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.127282149620203):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_511",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.5878243367579509):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.5878243367579509):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_512",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.8956427416252669):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.8956427416252669):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_513",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.40988605614780316):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.40988605614780316):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_514",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.0760745040210129):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.0760745040210129):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_515",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.40926137389075645):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.40926137389075645):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_516",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.12994676628919122):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.12994676628919122):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_517",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.26418642503215495):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.26418642503215495):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_518",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.5411149745663292):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.5411149745663292):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_519",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.5973656950210121):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.5973656950210121):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_520",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.11901617686385568):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.11901617686385568):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_521",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.7464790293443353):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.7464790293443353):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_522",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.300670080810858):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.300670080810858):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_523",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.22740028730921535):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.22740028730921535):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_524",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.7823288551632961):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.7823288551632961):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_525",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.0065598878991115495):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.0065598878991115495):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_526",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.7666927474902586):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.7666927474902586):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_527",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.8674412316041351):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.8674412316041351):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_528",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.49312457461892034):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.49312457461892034):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_529",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=3.240862070430506e-05):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=3.240862070430506e-05):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_530",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7449183798191233):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7449183798191233):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_531",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.4842657181510547):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.4842657181510547):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_532",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.018888411280274853):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.018888411280274853):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_533",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.6183371433575776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.6183371433575776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_534",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6267383502928316):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6267383502928316):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_535",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.1615819001641321):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.1615819001641321):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_536",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.5260761541534882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.5260761541534882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_537",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.08789536102644369):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.08789536102644369):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_538",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.8114016136914384):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.8114016136914384):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_539",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.8371524672902299):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.8371524672902299):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_540",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.43964579162322515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.43964579162322515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_541",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.5532562303000135):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.5532562303000135):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_542",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.11390594865252257):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.11390594865252257):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_543",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.953281405457726):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.953281405457726):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_544",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.6938828000446391):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.6938828000446391):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_545",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.2061908609608707):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.2061908609608707):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_546",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.42757002607343897):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.42757002607343897):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_547",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.855498855041425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.855498855041425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_548",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.6665630083350003):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.6665630083350003):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_549",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.3411224405900787):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.3411224405900787):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_550",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.5183316901625439):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.5183316901625439):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_551",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.6666939435467766):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.6666939435467766):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_552",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.369080777552261):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.369080777552261):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_553",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.7287222547830802):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.7287222547830802):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_554",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.8624624900165522):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.8624624900165522):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_555",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.5319245160110428):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.5319245160110428):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_556",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.2895565999055809):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.2895565999055809):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_557",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.6197927824779601):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.6197927824779601):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_558",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.3554196857705628):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.3554196857705628):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_559",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.29008244134309147):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.29008244134309147):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_560",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.13528463538796043):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.13528463538796043):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_561",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.33092643870576355):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.33092643870576355):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_562",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.2520273256284663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.2520273256284663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_563",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.4831961355174593):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.4831961355174593):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_564",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.03597864299440623):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.03597864299440623):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_565",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.5872239635611803):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.5872239635611803):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_566",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.8326977038515148):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.8326977038515148):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_567",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.8598492201817272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.8598492201817272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_568",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.6002876695999123):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.6002876695999123):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_569",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.9774428644683568):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.9774428644683568):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_570",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.7397692882655641):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.7397692882655641):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_571",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.3848421048975669):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.3848421048975669):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_572",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.0795187101044843):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.0795187101044843):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_573",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.8259047959914002):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.8259047959914002):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_574",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.14342445336824838):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.14342445336824838):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_575",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.22692144553169014):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.22692144553169014):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_576",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.04732989161232415):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.04732989161232415):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_577",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.9372869196701635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.9372869196701635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_578",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.7022746810951815):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.7022746810951815):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_579",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.1617625624507676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.1617625624507676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_580",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.9294779944114776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.9294779944114776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_581",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.33840767358065627):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.33840767358065627):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_582",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.043857774642670044):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.043857774642670044):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_583",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.745633374210235):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.745633374210235):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_584",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.10141506998242289):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.10141506998242289):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_585",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.3854978441186201):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.3854978441186201):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_586",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.09308106824716356):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.09308106824716356):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_587",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.8398997220069947):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.8398997220069947):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_588",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.8290052662422057):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.8290052662422057):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_589",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.3087199968757308):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.3087199968757308):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_590",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.351154364171425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.351154364171425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_591",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.06777114225176062):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.06777114225176062):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_592",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.9026600909921406):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.9026600909921406):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_593",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.8041056567489886):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.8041056567489886):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_594",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.08900188697028422):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.08900188697028422):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_595",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.6467566070164205):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.6467566070164205):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_596",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.05489199203186568):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.05489199203186568):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_597",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.7693434150556571):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.7693434150556571):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_598",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.08866691557198336):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.08866691557198336):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_599",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.45592208619888863):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.45592208619888863):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_600",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.21382463889751713):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.21382463889751713):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_601",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.01884988775126506):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.01884988775126506):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_602",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.0785476493030225):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.0785476493030225):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_603",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.2367185615320878):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.2367185615320878):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_604",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.6665372294644677):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.6665372294644677):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_605",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.021465480802839276):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.021465480802839276):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_606",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.5967551093384401):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.5967551093384401):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_607",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5628345137306893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.5628345137306893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_608",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.7041824838083607):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.7041824838083607):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_609",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.07720738510866154):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.07720738510866154):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_610",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.28454041414948195):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.28454041414948195):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_611",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.1876185180799561):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.1876185180799561):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_612",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.38901730753080854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.38901730753080854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_613",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.007852538964258304):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.007852538964258304):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_614",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.6709351734389652):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.6709351734389652):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_615",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.5224431523178704):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.5224431523178704):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_616",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.5017378409134415):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.5017378409134415):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_617",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.2871807354942699):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.2871807354942699):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_618",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.9288579210576756):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.9288579210576756):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_619",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.012736568569356232):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.012736568569356232):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_620",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.35107819447492616):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.35107819447492616):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_621",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.5919327828848534):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.5919327828848534):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_622",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.6228857192456285):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.6228857192456285):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_623",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.07552959723191166):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.07552959723191166):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_624",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.495908202142359):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.495908202142359):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_625",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.9565479382201839):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.9565479382201839):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_626",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.14412956601683735):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.14412956601683735):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_627",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.3076016336368186):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.3076016336368186):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_628",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.018186072922814045):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.018186072922814045):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_629",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.9759672397198198):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.9759672397198198):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_630",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.7675939773672936):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.7675939773672936):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_631",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.9795732788705669):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.9795732788705669):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_632",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.5354136588773741):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.5354136588773741):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_633",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.3984447228307467):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.3984447228307467):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_634",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.001589188537862607):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.001589188537862607):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_635",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.5768518408041856):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.5768518408041856):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_636",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.7532309140636404):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.7532309140636404):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_637",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.3430222875695649):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.3430222875695649):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_638",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.49859214939599816):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.49859214939599816):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_639",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.9049136430688216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.9049136430688216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_640",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.07621051394266887):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.07621051394266887):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_641",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.3375294714191892):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.3375294714191892):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_642",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.49503340828491527):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.49503340828491527):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_643",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.8516147899180928):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.8516147899180928):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_644",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.9531139145914796):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.9531139145914796):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_645",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.36276082371937757):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.36276082371937757):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_646",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6884379175188111):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6884379175188111):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_647",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.5518211477810849):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.5518211477810849):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_648",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.33838766175874):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.33838766175874):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_649",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.4982953435415489):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.4982953435415489):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_650",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.022150143703628555):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.022150143703628555):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_651",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.9059890504399901):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.9059890504399901):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_652",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.18232467283341336):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.18232467283341336):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_653",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.5625629197303976):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.5625629197303976):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_654",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.5142410728706555):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.5142410728706555):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_655",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.3400711941890132):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.3400711941890132):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_656",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.8552780827432512):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.8552780827432512):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_657",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.7542650853452061):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.7542650853452061):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_658",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.09398066775429992):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.09398066775429992):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_659",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.3666170701376166):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.3666170701376166):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_660",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.7866393299873767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.7866393299873767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_661",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.5535213959921202):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.5535213959921202):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_662",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.6170875913669805):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.6170875913669805):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_663",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.649354411225257):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.649354411225257):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_664",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.5409334351483946):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.5409334351483946):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_665",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.6115242861595432):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.6115242861595432):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_666",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.7408821900031681):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.7408821900031681):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_667",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.7913773452490007):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.7913773452490007):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_668",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.8087081031872967):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.8087081031872967):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_669",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.67845622798842):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.67845622798842):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_670",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.1261583071649558):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.1261583071649558):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_671",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.08827054209502683):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.08827054209502683):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_672",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.7251010269838719):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.7251010269838719):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_673",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.2761348855364525):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.2761348855364525):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_674",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.5240597933607255):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.5240597933607255):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_675",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7816986835832338):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7816986835832338):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_676",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.19484475173395055):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.19484475173395055):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_677",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.896600944090751):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.896600944090751):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_678",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.1583392315267398):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.1583392315267398):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_679",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.1170337523320707):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.1170337523320707):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_680",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.42246942481343863):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.42246942481343863):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_681",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.9457229761345193):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.9457229761345193):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_682",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9242290203616745):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9242290203616745):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_683",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.5569041044804187):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.5569041044804187):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_684",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.2689653313592042):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.2689653313592042):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_685",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.8000956652734887):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.8000956652734887):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_686",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.5992802092913713):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.5992802092913713):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_687",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.07519022977784906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.07519022977784906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_688",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.7486242044277001):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.7486242044277001):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_689",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.17450317347230682):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.17450317347230682):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_690",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.6974224414637428):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.6974224414637428):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_691",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.6510475887732015):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.6510475887732015):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_692",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.1486115790736564):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.1486115790736564):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_693",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.6049633352944219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.6049633352944219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_694",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.9264443248166805):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.9264443248166805):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_695",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.8304324859181057):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.8304324859181057):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_696",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.2114829904061708):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.2114829904061708):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_697",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.5752601222693581):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.5752601222693581):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_698",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.14665371708506547):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.14665371708506547):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_699",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.35960058366542047):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.35960058366542047):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_700",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.2550085503052958):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.2550085503052958):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_701",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.9757515220884141):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.9757515220884141):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_702",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.7793811094359004):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.7793811094359004):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_703",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.03460379580460338):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.03460379580460338):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_704",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.16036326462328854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.16036326462328854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_705",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.0918128756919987):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.0918128756919987):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_706",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.11898432424134853):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.11898432424134853):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_707",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.6623370902347677):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.6623370902347677):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_708",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.3445160854829792):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.3445160854829792):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_709",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.16037557482704345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.16037557482704345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_710",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.6162791040546558):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.6162791040546558):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_711",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.6363625005107844):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.6363625005107844):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_712",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.29828502701914306):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.29828502701914306):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_713",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.8637135034602829):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.8637135034602829):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_714",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.18282144884899476):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.18282144884899476):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_715",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.244027920440691):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.244027920440691):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_716",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.6511701969762179):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.6511701969762179):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_717",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.38863672550659056):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.38863672550659056):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_718",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.7849459539646217):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.7849459539646217):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_719",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.180762050821634):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.180762050821634):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_720",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.3151537070974745):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.3151537070974745):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_721",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.7250598479528287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.7250598479528287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_722",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.8222120265096884):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.8222120265096884):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_723",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.2003694208437491):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.2003694208437491):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_724",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.8216797843556672):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.8216797843556672):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_725",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.6270509548272785):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.6270509548272785):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_726",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.7069006611267379):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.7069006611267379):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_727",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.5271606350251726):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.5271606350251726):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_728",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.6562424085686931):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.6562424085686931):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_729",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.6561059680168819):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.6561059680168819):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_730",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.9420444984387039):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.9420444984387039):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_731",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.9048441609616448):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.9048441609616448):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_732",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.6737098405692673):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.6737098405692673):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_733",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.8283417615716551):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.8283417615716551):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_734",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.6203001342128459):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.6203001342128459):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_735",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.2741924576897192):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.2741924576897192):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_736",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.3754271707724469):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.3754271707724469):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_737",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.660613268434493):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.660613268434493):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_738",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.5716643954813865):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.5716643954813865):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_739",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.40558002476502075):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.40558002476502075):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_740",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.5636919320796703):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.5636919320796703):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_741",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.6501935476790893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.6501935476790893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_742",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.6716508475122482):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.6716508475122482):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_743",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.07099154473800962):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.07099154473800962):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_744",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.2555737655604565):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.2555737655604565):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_745",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.6799410339202946):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.6799410339202946):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_746",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.24077481625769492):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.24077481625769492):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_747",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6362496110356763):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6362496110356763):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_748",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.0020679243826794425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.0020679243826794425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_749",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.5995636531870036):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.5995636531870036):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_750",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.48699079750791907):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.48699079750791907):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_751",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.7760985937500767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.7760985937500767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_752",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.5398234258214389):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.5398234258214389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_753",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.043079035568509005):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.043079035568509005):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_754",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.861705021547229):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.861705021547229):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_755",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.4967384741717217):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.4967384741717217):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_756",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.9644382410640981):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.9644382410640981):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_757",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.07619016079993024):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.07619016079993024):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_758",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.43086814459808676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.43086814459808676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_759",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.22784692732343703):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.22784692732343703):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_760",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.5747814908628321):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.5747814908628321):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_761",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.9158098348160109):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.9158098348160109):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_762",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.1645235359077838):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.1645235359077838):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_763",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.9097298400517195):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.9097298400517195):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_764",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.715832304525041):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.715832304525041):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_765",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.5609474824741407):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.5609474824741407):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_766",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.9194419954367832):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.9194419954367832):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_767",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.03984068321001588):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.03984068321001588):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_768",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.7761735328161621):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.7761735328161621):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_769",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.6490574490359725):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.6490574490359725):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_770",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.810085874243433):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.810085874243433):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_771",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.10742855986496114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.10742855986496114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_772",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.3427913336867916):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.3427913336867916):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_773",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.38060804457025255):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.38060804457025255):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_774",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.021920231328594775):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.021920231328594775):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_775",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.6511774559285834):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.6511774559285834):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_776",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.3532697546133198):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.3532697546133198):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_777",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.06955527570233289):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.06955527570233289):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_778",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.8158903745470841):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.8158903745470841):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_779",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.7256893423381672):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.7256893423381672):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_780",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.5867026420540434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.5867026420540434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_781",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.5363622951525575):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.5363622951525575):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_782",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.8866502106289925):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.8866502106289925):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_783",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.9336430756221179):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.9336430756221179):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_784",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.7794968756823919):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.7794968756823919):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_785",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.9827146753351442):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.9827146753351442):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_786",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.6193954267628189):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.6193954267628189):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_787",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.03683014473948942):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.03683014473948942):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_788",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.6575570204574925):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.6575570204574925):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_789",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.17343213282632497):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.17343213282632497):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_790",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.41774495093392094):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.41774495093392094):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_791",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.43116716271450584):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.43116716271450584):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_792",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.5316809007556667):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.5316809007556667):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_793",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.5414528716695404):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.5414528716695404):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_794",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.8600796077646511):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.8600796077646511):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_795",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.3858950344535562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.3858950344535562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_796",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.19503900023444143):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.19503900023444143):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_797",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.372161663716873):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.372161663716873):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_798",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.9087842817947912):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.9087842817947912):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_799",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.5010532464589614):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.5010532464589614):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_800",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.1417986346636405):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.1417986346636405):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_801",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.797746387747677):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.797746387747677):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_802",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.41431337589801276):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.41431337589801276):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_803",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.7508747175375508):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.7508747175375508):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_804",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.8920553062125441):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.8920553062125441):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_805",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.2482653515245309):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.2482653515245309):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_806",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7004499018420742):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7004499018420742):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_807",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.7196766392636315):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.7196766392636315):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_808",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.9945166696243088):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.9945166696243088):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_809",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.5692909866219684):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.5692909866219684):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_810",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.046082907087320435):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.046082907087320435):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_811",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.7820503558697067):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.7820503558697067):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_812",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.6411368676810505):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.6411368676810505):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_813",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.4409219122680895):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.4409219122680895):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_814",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.14262446974794174):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.14262446974794174):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_815",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.787798624157273):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.787798624157273):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_816",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.8932839156739906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.8932839156739906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_817",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.3398168245299902):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.3398168245299902):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_818",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.5551783758722141):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.5551783758722141):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_819",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.5315274553133562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.5315274553133562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_820",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.9313836182033947):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.9313836182033947):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_821",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.6288648382120123):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.6288648382120123):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_822",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.10677416609536816):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.10677416609536816):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_823",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.605596021317401):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.605596021317401):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_824",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.8633413560220462):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.8633413560220462):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_825",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.5498047007620236):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.5498047007620236):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_826",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.346082964750846):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.346082964750846):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_827",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.501509808080927):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.501509808080927):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_828",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.6075448075360919):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.6075448075360919):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_829",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.652820677759961):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.652820677759961):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_830",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.40860630079305893):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.40860630079305893):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_831",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.6361459432391748):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.6361459432391748):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_832",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9451642524207853):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9451642524207853):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_833",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.5845934181638394):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.5845934181638394):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_834",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.39542545140844043):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.39542545140844043):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_835",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.7754206146687029):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.7754206146687029):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_836",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.8868632597203492):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.8868632597203492):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_837",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.7488048387838461):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.7488048387838461):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_838",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7431034277071878):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7431034277071878):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_839",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.884766766409357):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.884766766409357):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_840",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.4595553410637343):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.4595553410637343):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_841",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.6230697854458455):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.6230697854458455):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_842",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.40643504740459646):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.40643504740459646):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_843",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.3206781709537513):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.3206781709537513):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_844",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.06162524270777081):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.06162524270777081):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_845",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.661164683974422):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.661164683974422):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_846",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.10356593586257734):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.10356593586257734):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_847",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.7621488483734069):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.7621488483734069):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_848",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.06346054636953213):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.06346054636953213):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_849",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.560797230944838):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.560797230944838):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_850",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.1301172608786274):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.1301172608786274):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_851",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.022923155073099832):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.022923155073099832):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_852",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.06616749596804194):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.06616749596804194):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_853",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.0862523679178182):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.0862523679178182):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_854",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.30050586928932776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.30050586928932776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_855",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.6873542080538175):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.6873542080538175):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_856",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.33363544046634785):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.33363544046634785):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_857",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.06746720052177668):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.06746720052177668):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_858",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.9506440818018836):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.9506440818018836):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_859",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.5377558240225775):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.5377558240225775):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_860",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.7905317614383078):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.7905317614383078):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_861",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.32941223962595767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.32941223962595767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_862",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.48586536189437335):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.48586536189437335):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_863",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.03668286004272192):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.03668286004272192):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_864",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.8328962006935965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.8328962006935965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_865",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.4453111037628599):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.4453111037628599):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_866",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.933833165608111):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.933833165608111):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_867",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.8420621823225847):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.8420621823225847):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_868",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.9668547132138735):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.9668547132138735):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_869",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.036396125669685864):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.036396125669685864):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_870",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.24342461331105347):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.24342461331105347):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_871",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.8501267757345924):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.8501267757345924):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_872",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.7857929533998761):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.7857929533998761):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_873",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.6429061889290172):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.6429061889290172):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_874",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.688703399283747):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.688703399283747):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_875",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.06844132075714626):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.06844132075714626):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_876",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.16157760265939913):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.16157760265939913):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_877",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.46666293910679346):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.46666293910679346):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_878",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.44501943129109856):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.44501943129109856):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_879",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.20397415713520828):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.20397415713520828):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_880",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.6385029667855386):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.6385029667855386):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_881",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.6601089324912901):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.6601089324912901):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_882",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.16635980453776655):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.16635980453776655):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_883",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.1327094033821241):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.1327094033821241):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_884",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.88860105850777):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.88860105850777):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_885",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.826061068398242):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.826061068398242):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_886",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.5290038094767787):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.5290038094767787):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_887",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.5488789281333686):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.5488789281333686):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_888",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.5590477413262248):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.5590477413262248):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_889",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.7047465015461241):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.7047465015461241):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_890",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.5289970046839858):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.5289970046839858):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_891",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.602278533321098):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.602278533321098):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_892",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.45179792103718674):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.45179792103718674):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_893",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.15114085493871388):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.15114085493871388):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_894",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.6344043386474002):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.6344043386474002):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_895",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.5194973682342393):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.5194973682342393):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_896",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.689205779006527):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.689205779006527):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_897",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.34432138852171956):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.34432138852171956):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_898",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.4195966154800995):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.4195966154800995):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_899",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.2418185534450641):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.2418185534450641):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_900",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.7493495476515512):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.7493495476515512):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_901",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.7256930277553435):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.7256930277553435):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_902",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.5597232697837391):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.5597232697837391):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_903",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.15476479287638345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.15476479287638345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_904",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.16380387953496):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.16380387953496):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_905",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.01980741392441565):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.01980741392441565):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_906",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.3432377291093751):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.3432377291093751):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_907",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.263146285827339):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.263146285827339):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_908",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.3761464868664387):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.3761464868664387):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_909",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.3673844427002345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.3673844427002345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_910",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.7926132587351999):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.7926132587351999):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_911",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.35125589205801544):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.35125589205801544):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_912",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.08270415844177337):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.08270415844177337):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_913",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.038578422704978244):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.038578422704978244):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_914",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.12833278687355387):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.12833278687355387):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_915",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.7136600845285364):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.7136600845285364):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_916",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.3753469854031679):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.3753469854031679):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_917",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.4061177847418309):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.4061177847418309):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_918",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.034663059769392324):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.034663059769392324):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_919",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.6088909662967308):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.6088909662967308):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_920",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.004467292955708024):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.004467292955708024):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_921",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.3347276930777784):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.3347276930777784):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_922",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.1095959930281194):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.1095959930281194):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_923",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.330050145541651):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.330050145541651):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_924",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.8069645949642219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.8069645949642219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_925",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.5423432778701078):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.5423432778701078):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_926",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.6882196154960231):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.6882196154960231):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_927",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.012266892158885878):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.012266892158885878):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_928",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.7273637201174951):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.7273637201174951):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_929",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.44043832780447345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.44043832780447345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_930",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.911691773669434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.911691773669434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_931",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.6734418062520752):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.6734418062520752):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_932",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.15079988097821329):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.15079988097821329):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_933",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.05514010002413472):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.05514010002413472):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_934",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.19230667686811964):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.19230667686811964):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_935",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.18481031153261562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.18481031153261562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_936",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.483405951109092):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.483405951109092):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_937",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.3705864335434498):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.3705864335434498):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_938",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.4792287622044662):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.4792287622044662):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_939",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.5790804347873092):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.5790804347873092):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_940",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.6876116974482577):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.6876116974482577):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_941",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.9298134611813718):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.9298134611813718):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_942",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.6731881565203125):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.6731881565203125):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_943",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.6694021826175216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.6694021826175216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_944",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.47066901205562905):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.47066901205562905):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_945",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.7578776737568136):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.7578776737568136):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_946",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.2135202762888807):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.2135202762888807):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_947",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.43010734936530026):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.43010734936530026):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_948",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.5952064538653435):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.5952064538653435):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_949",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.7649206155983188):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.7649206155983188):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_950",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.5891694152425211):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.5891694152425211):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_951",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.14943148118161775):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.14943148118161775):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_952",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.2484232337576291):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.2484232337576291):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_953",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.3634958425947685):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.3634958425947685):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_954",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.8989716468662694):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.8989716468662694):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_955",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.4429738526865332):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.4429738526865332):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_956",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.8001335231534945):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.8001335231534945):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_957",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.060207350901885226):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.060207350901885226):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_958",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.01237263694899493):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.01237263694899493):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_959",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.970093698757105):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.970093698757105):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_960",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.6610069898591846):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.6610069898591846):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_961",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.3845348364275042):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.3845348364275042):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_962",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.619525526060568):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.619525526060568):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_963",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.04225694659159207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.04225694659159207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_964",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.9357909886164143):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.9357909886164143):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_965",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7123785902952363):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7123785902952363):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_966",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.7121713190778416):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.7121713190778416):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_967",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.667408526359834):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.667408526359834):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_968",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.2738268643233869):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.2738268643233869):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_969",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.22461093008307087):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.22461093008307087):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_970",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.4715760291299097):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.4715760291299097):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_971",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.39644644460576495):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.39644644460576495):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_972",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.10848175740072852):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.10848175740072852):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_973",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.9018474491211034):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.9018474491211034):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_974",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.07714510391026352):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.07714510391026352):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_975",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.6302164683231306):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.6302164683231306):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_976",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.7640943337065456):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.7640943337065456):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_977",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.5615657459902311):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.5615657459902311):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_978",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.7515167806629302):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.7515167806629302):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_979",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.18360433957948674):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.18360433957948674):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_980",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.8924051044480084):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.8924051044480084):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_981",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.24726961132693515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.24726961132693515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_982",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.8544682435065711):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.8544682435065711):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_983",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.8623858101917815):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.8623858101917815):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_984",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.14293076434763918):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.14293076434763918):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_985",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.267181483163791):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.267181483163791):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_986",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.5507374278812168):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.5507374278812168):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_987",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.7932887597190734):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.7932887597190734):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_988",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.1728156229991955):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.1728156229991955):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_989",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.4772752254745487):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.4772752254745487):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_990",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.39094695152814174):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.39094695152814174):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_991",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.3868836635922195):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.3868836635922195):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_992",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.10582702695444979):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.10582702695444979):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_993",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.6820425705441292):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.6820425705441292):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_994",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.8969804067787115):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.8969804067787115):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_995",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.9199553662346226):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.9199553662346226):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_996",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.9474365596250105):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.9474365596250105):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_997",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.31439331870039455):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.31439331870039455):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_998",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.8848685118267593):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.8848685118267593):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_999",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.28109782177446774):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.28109782177446774):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  }
]