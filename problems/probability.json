[
  {
    "name": "BirthdayParadox_0",
    "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_1",
    "sat": "def sat(n: int, year_len: int=60182):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_2",
    "sat": "def sat(n: int, year_len: int=2):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_3",
    "sat": "def sat(n: int, year_len: int=3):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_4",
    "sat": "def sat(n: int, year_len: int=4):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_5",
    "sat": "def sat(n: int, year_len: int=5):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_6",
    "sat": "def sat(n: int, year_len: int=6):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_7",
    "sat": "def sat(n: int, year_len: int=7):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_8",
    "sat": "def sat(n: int, year_len: int=8):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_9",
    "sat": "def sat(n: int, year_len: int=9):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_10",
    "sat": "def sat(n: int, year_len: int=10):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=10):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_11",
    "sat": "def sat(n: int, year_len: int=11):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=11):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_12",
    "sat": "def sat(n: int, year_len: int=12):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=12):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_13",
    "sat": "def sat(n: int, year_len: int=13):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=13):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_14",
    "sat": "def sat(n: int, year_len: int=14):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=14):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_15",
    "sat": "def sat(n: int, year_len: int=15):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=15):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_16",
    "sat": "def sat(n: int, year_len: int=16):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=16):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_17",
    "sat": "def sat(n: int, year_len: int=17):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=17):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_18",
    "sat": "def sat(n: int, year_len: int=18):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=18):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_19",
    "sat": "def sat(n: int, year_len: int=19):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=19):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_20",
    "sat": "def sat(n: int, year_len: int=20):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=20):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_21",
    "sat": "def sat(n: int, year_len: int=21):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=21):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_22",
    "sat": "def sat(n: int, year_len: int=22):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=22):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_23",
    "sat": "def sat(n: int, year_len: int=23):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=23):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_24",
    "sat": "def sat(n: int, year_len: int=24):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=24):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_25",
    "sat": "def sat(n: int, year_len: int=25):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=25):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_26",
    "sat": "def sat(n: int, year_len: int=26):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=26):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_27",
    "sat": "def sat(n: int, year_len: int=27):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=27):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_28",
    "sat": "def sat(n: int, year_len: int=28):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=28):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_29",
    "sat": "def sat(n: int, year_len: int=29):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=29):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_30",
    "sat": "def sat(n: int, year_len: int=30):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=30):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_31",
    "sat": "def sat(n: int, year_len: int=31):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=31):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_32",
    "sat": "def sat(n: int, year_len: int=32):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=32):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_33",
    "sat": "def sat(n: int, year_len: int=33):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=33):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_34",
    "sat": "def sat(n: int, year_len: int=34):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=34):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_35",
    "sat": "def sat(n: int, year_len: int=35):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=35):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_36",
    "sat": "def sat(n: int, year_len: int=36):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=36):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_37",
    "sat": "def sat(n: int, year_len: int=37):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=37):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_38",
    "sat": "def sat(n: int, year_len: int=38):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=38):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_39",
    "sat": "def sat(n: int, year_len: int=39):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=39):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_40",
    "sat": "def sat(n: int, year_len: int=40):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=40):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_41",
    "sat": "def sat(n: int, year_len: int=41):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=41):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_42",
    "sat": "def sat(n: int, year_len: int=42):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=42):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_43",
    "sat": "def sat(n: int, year_len: int=43):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=43):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_44",
    "sat": "def sat(n: int, year_len: int=44):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=44):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_45",
    "sat": "def sat(n: int, year_len: int=45):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=45):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_46",
    "sat": "def sat(n: int, year_len: int=46):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=46):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_47",
    "sat": "def sat(n: int, year_len: int=47):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=47):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_48",
    "sat": "def sat(n: int, year_len: int=48):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=48):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_49",
    "sat": "def sat(n: int, year_len: int=49):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=49):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_50",
    "sat": "def sat(n: int, year_len: int=50):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=50):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_51",
    "sat": "def sat(n: int, year_len: int=51):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=51):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_52",
    "sat": "def sat(n: int, year_len: int=52):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=52):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_53",
    "sat": "def sat(n: int, year_len: int=53):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=53):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_54",
    "sat": "def sat(n: int, year_len: int=54):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=54):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_55",
    "sat": "def sat(n: int, year_len: int=55):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=55):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_56",
    "sat": "def sat(n: int, year_len: int=56):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=56):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_57",
    "sat": "def sat(n: int, year_len: int=57):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=57):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_58",
    "sat": "def sat(n: int, year_len: int=58):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=58):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_59",
    "sat": "def sat(n: int, year_len: int=59):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=59):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_60",
    "sat": "def sat(n: int, year_len: int=60):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=60):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_61",
    "sat": "def sat(n: int, year_len: int=61):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=61):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_62",
    "sat": "def sat(n: int, year_len: int=62):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=62):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_63",
    "sat": "def sat(n: int, year_len: int=63):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=63):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_64",
    "sat": "def sat(n: int, year_len: int=64):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=64):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_65",
    "sat": "def sat(n: int, year_len: int=65):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=65):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_66",
    "sat": "def sat(n: int, year_len: int=66):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=66):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_67",
    "sat": "def sat(n: int, year_len: int=67):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=67):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_68",
    "sat": "def sat(n: int, year_len: int=68):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=68):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_69",
    "sat": "def sat(n: int, year_len: int=69):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=69):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_70",
    "sat": "def sat(n: int, year_len: int=70):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=70):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_71",
    "sat": "def sat(n: int, year_len: int=71):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=71):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_72",
    "sat": "def sat(n: int, year_len: int=72):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=72):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_73",
    "sat": "def sat(n: int, year_len: int=73):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=73):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_74",
    "sat": "def sat(n: int, year_len: int=74):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=74):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_75",
    "sat": "def sat(n: int, year_len: int=75):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=75):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_76",
    "sat": "def sat(n: int, year_len: int=76):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=76):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_77",
    "sat": "def sat(n: int, year_len: int=77):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=77):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_78",
    "sat": "def sat(n: int, year_len: int=78):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=78):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_79",
    "sat": "def sat(n: int, year_len: int=79):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=79):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_80",
    "sat": "def sat(n: int, year_len: int=80):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=80):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_81",
    "sat": "def sat(n: int, year_len: int=81):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=81):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_82",
    "sat": "def sat(n: int, year_len: int=82):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=82):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_83",
    "sat": "def sat(n: int, year_len: int=83):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=83):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_84",
    "sat": "def sat(n: int, year_len: int=84):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=84):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_85",
    "sat": "def sat(n: int, year_len: int=85):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=85):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_86",
    "sat": "def sat(n: int, year_len: int=86):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=86):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_87",
    "sat": "def sat(n: int, year_len: int=87):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=87):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_88",
    "sat": "def sat(n: int, year_len: int=88):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=88):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_89",
    "sat": "def sat(n: int, year_len: int=89):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=89):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_90",
    "sat": "def sat(n: int, year_len: int=90):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=90):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_91",
    "sat": "def sat(n: int, year_len: int=91):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=91):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_92",
    "sat": "def sat(n: int, year_len: int=92):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=92):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_93",
    "sat": "def sat(n: int, year_len: int=93):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=93):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_94",
    "sat": "def sat(n: int, year_len: int=94):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=94):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_95",
    "sat": "def sat(n: int, year_len: int=95):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=95):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_96",
    "sat": "def sat(n: int, year_len: int=96):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=96):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_97",
    "sat": "def sat(n: int, year_len: int=97):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=97):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_98",
    "sat": "def sat(n: int, year_len: int=98):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=98):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_99",
    "sat": "def sat(n: int, year_len: int=99):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=99):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_100",
    "sat": "def sat(n: int, year_len: int=100):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=100):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_101",
    "sat": "def sat(n: int, year_len: int=101):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=101):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_102",
    "sat": "def sat(n: int, year_len: int=102):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=102):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_103",
    "sat": "def sat(n: int, year_len: int=103):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=103):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_104",
    "sat": "def sat(n: int, year_len: int=104):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=104):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_105",
    "sat": "def sat(n: int, year_len: int=105):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=105):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_106",
    "sat": "def sat(n: int, year_len: int=106):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=106):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_107",
    "sat": "def sat(n: int, year_len: int=107):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=107):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_108",
    "sat": "def sat(n: int, year_len: int=108):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=108):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_109",
    "sat": "def sat(n: int, year_len: int=109):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=109):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_110",
    "sat": "def sat(n: int, year_len: int=110):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=110):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_111",
    "sat": "def sat(n: int, year_len: int=111):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=111):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_112",
    "sat": "def sat(n: int, year_len: int=112):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=112):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_113",
    "sat": "def sat(n: int, year_len: int=113):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=113):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_114",
    "sat": "def sat(n: int, year_len: int=114):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=114):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_115",
    "sat": "def sat(n: int, year_len: int=115):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=115):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_116",
    "sat": "def sat(n: int, year_len: int=116):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=116):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_117",
    "sat": "def sat(n: int, year_len: int=117):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=117):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_118",
    "sat": "def sat(n: int, year_len: int=118):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=118):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_119",
    "sat": "def sat(n: int, year_len: int=119):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=119):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_120",
    "sat": "def sat(n: int, year_len: int=120):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=120):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_121",
    "sat": "def sat(n: int, year_len: int=121):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=121):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_122",
    "sat": "def sat(n: int, year_len: int=122):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=122):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_123",
    "sat": "def sat(n: int, year_len: int=123):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=123):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_124",
    "sat": "def sat(n: int, year_len: int=124):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=124):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_125",
    "sat": "def sat(n: int, year_len: int=125):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=125):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_126",
    "sat": "def sat(n: int, year_len: int=126):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=126):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_127",
    "sat": "def sat(n: int, year_len: int=127):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=127):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_128",
    "sat": "def sat(n: int, year_len: int=128):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=128):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_129",
    "sat": "def sat(n: int, year_len: int=129):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=129):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_130",
    "sat": "def sat(n: int, year_len: int=130):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=130):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_131",
    "sat": "def sat(n: int, year_len: int=131):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=131):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_132",
    "sat": "def sat(n: int, year_len: int=132):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=132):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_133",
    "sat": "def sat(n: int, year_len: int=133):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=133):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_134",
    "sat": "def sat(n: int, year_len: int=134):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=134):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_135",
    "sat": "def sat(n: int, year_len: int=135):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=135):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_136",
    "sat": "def sat(n: int, year_len: int=136):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=136):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_137",
    "sat": "def sat(n: int, year_len: int=137):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=137):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_138",
    "sat": "def sat(n: int, year_len: int=138):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=138):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_139",
    "sat": "def sat(n: int, year_len: int=139):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=139):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_140",
    "sat": "def sat(n: int, year_len: int=140):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=140):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_141",
    "sat": "def sat(n: int, year_len: int=141):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=141):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_142",
    "sat": "def sat(n: int, year_len: int=142):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=142):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_143",
    "sat": "def sat(n: int, year_len: int=143):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=143):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_144",
    "sat": "def sat(n: int, year_len: int=144):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=144):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_145",
    "sat": "def sat(n: int, year_len: int=145):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=145):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_146",
    "sat": "def sat(n: int, year_len: int=146):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=146):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_147",
    "sat": "def sat(n: int, year_len: int=147):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=147):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_148",
    "sat": "def sat(n: int, year_len: int=148):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=148):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_149",
    "sat": "def sat(n: int, year_len: int=149):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=149):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_150",
    "sat": "def sat(n: int, year_len: int=150):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=150):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_151",
    "sat": "def sat(n: int, year_len: int=151):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=151):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_152",
    "sat": "def sat(n: int, year_len: int=152):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=152):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_153",
    "sat": "def sat(n: int, year_len: int=153):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=153):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_154",
    "sat": "def sat(n: int, year_len: int=154):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=154):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_155",
    "sat": "def sat(n: int, year_len: int=155):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=155):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_156",
    "sat": "def sat(n: int, year_len: int=156):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=156):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_157",
    "sat": "def sat(n: int, year_len: int=157):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=157):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_158",
    "sat": "def sat(n: int, year_len: int=158):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=158):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_159",
    "sat": "def sat(n: int, year_len: int=159):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=159):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_160",
    "sat": "def sat(n: int, year_len: int=160):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=160):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_161",
    "sat": "def sat(n: int, year_len: int=161):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=161):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_162",
    "sat": "def sat(n: int, year_len: int=162):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=162):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_163",
    "sat": "def sat(n: int, year_len: int=163):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=163):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_164",
    "sat": "def sat(n: int, year_len: int=164):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=164):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_165",
    "sat": "def sat(n: int, year_len: int=165):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=165):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_166",
    "sat": "def sat(n: int, year_len: int=166):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=166):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_167",
    "sat": "def sat(n: int, year_len: int=167):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=167):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_168",
    "sat": "def sat(n: int, year_len: int=168):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=168):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_169",
    "sat": "def sat(n: int, year_len: int=169):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=169):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_170",
    "sat": "def sat(n: int, year_len: int=170):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=170):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_171",
    "sat": "def sat(n: int, year_len: int=171):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=171):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_172",
    "sat": "def sat(n: int, year_len: int=172):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=172):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_173",
    "sat": "def sat(n: int, year_len: int=173):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=173):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_174",
    "sat": "def sat(n: int, year_len: int=174):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=174):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_175",
    "sat": "def sat(n: int, year_len: int=175):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=175):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_176",
    "sat": "def sat(n: int, year_len: int=176):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=176):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_177",
    "sat": "def sat(n: int, year_len: int=177):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=177):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_178",
    "sat": "def sat(n: int, year_len: int=178):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=178):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_179",
    "sat": "def sat(n: int, year_len: int=179):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=179):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_180",
    "sat": "def sat(n: int, year_len: int=180):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=180):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_181",
    "sat": "def sat(n: int, year_len: int=181):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=181):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_182",
    "sat": "def sat(n: int, year_len: int=182):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_183",
    "sat": "def sat(n: int, year_len: int=183):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=183):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_184",
    "sat": "def sat(n: int, year_len: int=184):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=184):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_185",
    "sat": "def sat(n: int, year_len: int=185):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=185):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_186",
    "sat": "def sat(n: int, year_len: int=186):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=186):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_187",
    "sat": "def sat(n: int, year_len: int=187):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=187):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_188",
    "sat": "def sat(n: int, year_len: int=188):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=188):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_189",
    "sat": "def sat(n: int, year_len: int=189):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=189):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_190",
    "sat": "def sat(n: int, year_len: int=190):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=190):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_191",
    "sat": "def sat(n: int, year_len: int=191):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=191):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_192",
    "sat": "def sat(n: int, year_len: int=192):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=192):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_193",
    "sat": "def sat(n: int, year_len: int=193):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=193):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_194",
    "sat": "def sat(n: int, year_len: int=194):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=194):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_195",
    "sat": "def sat(n: int, year_len: int=195):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=195):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_196",
    "sat": "def sat(n: int, year_len: int=196):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=196):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_197",
    "sat": "def sat(n: int, year_len: int=197):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=197):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_198",
    "sat": "def sat(n: int, year_len: int=198):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=198):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_199",
    "sat": "def sat(n: int, year_len: int=199):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=199):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_200",
    "sat": "def sat(n: int, year_len: int=200):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=200):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_201",
    "sat": "def sat(n: int, year_len: int=201):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=201):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_202",
    "sat": "def sat(n: int, year_len: int=202):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=202):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_203",
    "sat": "def sat(n: int, year_len: int=203):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=203):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_204",
    "sat": "def sat(n: int, year_len: int=204):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=204):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_205",
    "sat": "def sat(n: int, year_len: int=205):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=205):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_206",
    "sat": "def sat(n: int, year_len: int=206):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=206):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_207",
    "sat": "def sat(n: int, year_len: int=207):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=207):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_208",
    "sat": "def sat(n: int, year_len: int=208):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=208):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_209",
    "sat": "def sat(n: int, year_len: int=209):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=209):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_210",
    "sat": "def sat(n: int, year_len: int=210):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=210):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_211",
    "sat": "def sat(n: int, year_len: int=211):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=211):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_212",
    "sat": "def sat(n: int, year_len: int=212):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=212):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_213",
    "sat": "def sat(n: int, year_len: int=213):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=213):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_214",
    "sat": "def sat(n: int, year_len: int=214):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=214):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_215",
    "sat": "def sat(n: int, year_len: int=215):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=215):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_216",
    "sat": "def sat(n: int, year_len: int=216):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=216):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_217",
    "sat": "def sat(n: int, year_len: int=217):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=217):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_218",
    "sat": "def sat(n: int, year_len: int=218):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=218):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_219",
    "sat": "def sat(n: int, year_len: int=219):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=219):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_220",
    "sat": "def sat(n: int, year_len: int=220):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=220):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_221",
    "sat": "def sat(n: int, year_len: int=221):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=221):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_222",
    "sat": "def sat(n: int, year_len: int=222):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=222):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_223",
    "sat": "def sat(n: int, year_len: int=223):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=223):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_224",
    "sat": "def sat(n: int, year_len: int=224):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=224):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_225",
    "sat": "def sat(n: int, year_len: int=225):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=225):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_226",
    "sat": "def sat(n: int, year_len: int=226):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=226):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_227",
    "sat": "def sat(n: int, year_len: int=227):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=227):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_228",
    "sat": "def sat(n: int, year_len: int=228):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=228):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_229",
    "sat": "def sat(n: int, year_len: int=229):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=229):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_230",
    "sat": "def sat(n: int, year_len: int=230):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=230):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_231",
    "sat": "def sat(n: int, year_len: int=231):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=231):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_232",
    "sat": "def sat(n: int, year_len: int=232):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=232):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_233",
    "sat": "def sat(n: int, year_len: int=233):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=233):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_234",
    "sat": "def sat(n: int, year_len: int=234):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=234):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_235",
    "sat": "def sat(n: int, year_len: int=235):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=235):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_236",
    "sat": "def sat(n: int, year_len: int=236):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=236):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_237",
    "sat": "def sat(n: int, year_len: int=237):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=237):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_238",
    "sat": "def sat(n: int, year_len: int=238):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=238):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_239",
    "sat": "def sat(n: int, year_len: int=239):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=239):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_240",
    "sat": "def sat(n: int, year_len: int=240):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=240):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_241",
    "sat": "def sat(n: int, year_len: int=241):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=241):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_242",
    "sat": "def sat(n: int, year_len: int=242):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=242):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_243",
    "sat": "def sat(n: int, year_len: int=243):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=243):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_244",
    "sat": "def sat(n: int, year_len: int=244):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=244):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_245",
    "sat": "def sat(n: int, year_len: int=245):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=245):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_246",
    "sat": "def sat(n: int, year_len: int=246):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=246):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_247",
    "sat": "def sat(n: int, year_len: int=247):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=247):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_248",
    "sat": "def sat(n: int, year_len: int=248):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=248):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_249",
    "sat": "def sat(n: int, year_len: int=249):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=249):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_250",
    "sat": "def sat(n: int, year_len: int=250):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=250):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_251",
    "sat": "def sat(n: int, year_len: int=251):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=251):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_252",
    "sat": "def sat(n: int, year_len: int=252):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=252):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_253",
    "sat": "def sat(n: int, year_len: int=253):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=253):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_254",
    "sat": "def sat(n: int, year_len: int=254):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=254):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_255",
    "sat": "def sat(n: int, year_len: int=255):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=255):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_256",
    "sat": "def sat(n: int, year_len: int=256):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=256):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_257",
    "sat": "def sat(n: int, year_len: int=257):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=257):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_258",
    "sat": "def sat(n: int, year_len: int=258):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=258):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_259",
    "sat": "def sat(n: int, year_len: int=259):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=259):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_260",
    "sat": "def sat(n: int, year_len: int=260):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=260):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_261",
    "sat": "def sat(n: int, year_len: int=261):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=261):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_262",
    "sat": "def sat(n: int, year_len: int=262):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=262):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_263",
    "sat": "def sat(n: int, year_len: int=263):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=263):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_264",
    "sat": "def sat(n: int, year_len: int=264):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=264):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_265",
    "sat": "def sat(n: int, year_len: int=265):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=265):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_266",
    "sat": "def sat(n: int, year_len: int=266):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=266):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_267",
    "sat": "def sat(n: int, year_len: int=267):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=267):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_268",
    "sat": "def sat(n: int, year_len: int=268):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=268):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_269",
    "sat": "def sat(n: int, year_len: int=269):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=269):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_270",
    "sat": "def sat(n: int, year_len: int=270):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=270):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_271",
    "sat": "def sat(n: int, year_len: int=271):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=271):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_272",
    "sat": "def sat(n: int, year_len: int=272):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=272):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_273",
    "sat": "def sat(n: int, year_len: int=273):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=273):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_274",
    "sat": "def sat(n: int, year_len: int=274):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=274):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_275",
    "sat": "def sat(n: int, year_len: int=275):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=275):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_276",
    "sat": "def sat(n: int, year_len: int=276):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=276):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_277",
    "sat": "def sat(n: int, year_len: int=277):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=277):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_278",
    "sat": "def sat(n: int, year_len: int=278):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=278):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_279",
    "sat": "def sat(n: int, year_len: int=279):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=279):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_280",
    "sat": "def sat(n: int, year_len: int=280):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=280):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_281",
    "sat": "def sat(n: int, year_len: int=281):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=281):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_282",
    "sat": "def sat(n: int, year_len: int=282):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=282):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_283",
    "sat": "def sat(n: int, year_len: int=283):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=283):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_284",
    "sat": "def sat(n: int, year_len: int=284):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=284):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_285",
    "sat": "def sat(n: int, year_len: int=285):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=285):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_286",
    "sat": "def sat(n: int, year_len: int=286):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=286):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_287",
    "sat": "def sat(n: int, year_len: int=287):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=287):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_288",
    "sat": "def sat(n: int, year_len: int=288):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=288):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_289",
    "sat": "def sat(n: int, year_len: int=289):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=289):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_290",
    "sat": "def sat(n: int, year_len: int=290):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=290):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_291",
    "sat": "def sat(n: int, year_len: int=291):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=291):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_292",
    "sat": "def sat(n: int, year_len: int=292):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=292):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_293",
    "sat": "def sat(n: int, year_len: int=293):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=293):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_294",
    "sat": "def sat(n: int, year_len: int=294):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=294):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_295",
    "sat": "def sat(n: int, year_len: int=295):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=295):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_296",
    "sat": "def sat(n: int, year_len: int=296):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=296):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_297",
    "sat": "def sat(n: int, year_len: int=297):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=297):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_298",
    "sat": "def sat(n: int, year_len: int=298):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=298):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_299",
    "sat": "def sat(n: int, year_len: int=299):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=299):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_300",
    "sat": "def sat(n: int, year_len: int=300):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=300):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_301",
    "sat": "def sat(n: int, year_len: int=301):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=301):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_302",
    "sat": "def sat(n: int, year_len: int=302):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=302):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_303",
    "sat": "def sat(n: int, year_len: int=303):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=303):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_304",
    "sat": "def sat(n: int, year_len: int=304):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=304):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_305",
    "sat": "def sat(n: int, year_len: int=305):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=305):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_306",
    "sat": "def sat(n: int, year_len: int=306):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=306):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_307",
    "sat": "def sat(n: int, year_len: int=307):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=307):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_308",
    "sat": "def sat(n: int, year_len: int=308):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=308):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_309",
    "sat": "def sat(n: int, year_len: int=309):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=309):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_310",
    "sat": "def sat(n: int, year_len: int=310):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=310):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_311",
    "sat": "def sat(n: int, year_len: int=311):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=311):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_312",
    "sat": "def sat(n: int, year_len: int=312):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=312):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_313",
    "sat": "def sat(n: int, year_len: int=313):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=313):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_314",
    "sat": "def sat(n: int, year_len: int=314):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=314):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_315",
    "sat": "def sat(n: int, year_len: int=315):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=315):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_316",
    "sat": "def sat(n: int, year_len: int=316):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=316):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_317",
    "sat": "def sat(n: int, year_len: int=317):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=317):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_318",
    "sat": "def sat(n: int, year_len: int=318):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=318):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_319",
    "sat": "def sat(n: int, year_len: int=319):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=319):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_320",
    "sat": "def sat(n: int, year_len: int=320):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=320):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_321",
    "sat": "def sat(n: int, year_len: int=321):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=321):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_322",
    "sat": "def sat(n: int, year_len: int=322):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=322):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_323",
    "sat": "def sat(n: int, year_len: int=323):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=323):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_324",
    "sat": "def sat(n: int, year_len: int=324):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=324):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_325",
    "sat": "def sat(n: int, year_len: int=325):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=325):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_326",
    "sat": "def sat(n: int, year_len: int=326):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=326):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_327",
    "sat": "def sat(n: int, year_len: int=327):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=327):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_328",
    "sat": "def sat(n: int, year_len: int=328):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=328):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_329",
    "sat": "def sat(n: int, year_len: int=329):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=329):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_330",
    "sat": "def sat(n: int, year_len: int=330):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=330):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_331",
    "sat": "def sat(n: int, year_len: int=331):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=331):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_332",
    "sat": "def sat(n: int, year_len: int=332):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=332):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_333",
    "sat": "def sat(n: int, year_len: int=333):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=333):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_334",
    "sat": "def sat(n: int, year_len: int=334):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=334):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_335",
    "sat": "def sat(n: int, year_len: int=335):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=335):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_336",
    "sat": "def sat(n: int, year_len: int=336):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=336):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_337",
    "sat": "def sat(n: int, year_len: int=337):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=337):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_338",
    "sat": "def sat(n: int, year_len: int=338):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=338):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_339",
    "sat": "def sat(n: int, year_len: int=339):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=339):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_340",
    "sat": "def sat(n: int, year_len: int=340):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=340):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_341",
    "sat": "def sat(n: int, year_len: int=341):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=341):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_342",
    "sat": "def sat(n: int, year_len: int=342):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=342):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_343",
    "sat": "def sat(n: int, year_len: int=343):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=343):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_344",
    "sat": "def sat(n: int, year_len: int=344):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=344):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_345",
    "sat": "def sat(n: int, year_len: int=345):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=345):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_346",
    "sat": "def sat(n: int, year_len: int=346):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=346):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_347",
    "sat": "def sat(n: int, year_len: int=347):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=347):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_348",
    "sat": "def sat(n: int, year_len: int=348):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=348):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_349",
    "sat": "def sat(n: int, year_len: int=349):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=349):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_350",
    "sat": "def sat(n: int, year_len: int=350):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=350):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_351",
    "sat": "def sat(n: int, year_len: int=351):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=351):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_352",
    "sat": "def sat(n: int, year_len: int=352):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=352):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_353",
    "sat": "def sat(n: int, year_len: int=353):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=353):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_354",
    "sat": "def sat(n: int, year_len: int=354):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=354):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_355",
    "sat": "def sat(n: int, year_len: int=355):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=355):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_356",
    "sat": "def sat(n: int, year_len: int=356):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=356):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_357",
    "sat": "def sat(n: int, year_len: int=357):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=357):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_358",
    "sat": "def sat(n: int, year_len: int=358):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=358):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_359",
    "sat": "def sat(n: int, year_len: int=359):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=359):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_360",
    "sat": "def sat(n: int, year_len: int=360):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=360):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_361",
    "sat": "def sat(n: int, year_len: int=361):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=361):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_362",
    "sat": "def sat(n: int, year_len: int=362):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=362):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_363",
    "sat": "def sat(n: int, year_len: int=363):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=363):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_364",
    "sat": "def sat(n: int, year_len: int=364):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=364):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_365",
    "sat": "def sat(n: int, year_len: int=366):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=366):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_366",
    "sat": "def sat(n: int, year_len: int=367):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=367):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_367",
    "sat": "def sat(n: int, year_len: int=368):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=368):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_368",
    "sat": "def sat(n: int, year_len: int=369):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=369):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_369",
    "sat": "def sat(n: int, year_len: int=370):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=370):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_370",
    "sat": "def sat(n: int, year_len: int=371):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=371):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_371",
    "sat": "def sat(n: int, year_len: int=372):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=372):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_372",
    "sat": "def sat(n: int, year_len: int=373):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=373):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_373",
    "sat": "def sat(n: int, year_len: int=374):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=374):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_374",
    "sat": "def sat(n: int, year_len: int=375):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=375):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_375",
    "sat": "def sat(n: int, year_len: int=376):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=376):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_376",
    "sat": "def sat(n: int, year_len: int=377):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=377):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_377",
    "sat": "def sat(n: int, year_len: int=378):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=378):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_378",
    "sat": "def sat(n: int, year_len: int=379):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=379):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_379",
    "sat": "def sat(n: int, year_len: int=380):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=380):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_380",
    "sat": "def sat(n: int, year_len: int=381):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=381):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_381",
    "sat": "def sat(n: int, year_len: int=382):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=382):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_382",
    "sat": "def sat(n: int, year_len: int=383):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=383):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_383",
    "sat": "def sat(n: int, year_len: int=384):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=384):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_384",
    "sat": "def sat(n: int, year_len: int=385):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=385):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_385",
    "sat": "def sat(n: int, year_len: int=386):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=386):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_386",
    "sat": "def sat(n: int, year_len: int=387):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=387):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_387",
    "sat": "def sat(n: int, year_len: int=388):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=388):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_388",
    "sat": "def sat(n: int, year_len: int=389):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=389):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_389",
    "sat": "def sat(n: int, year_len: int=390):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=390):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_390",
    "sat": "def sat(n: int, year_len: int=391):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=391):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_391",
    "sat": "def sat(n: int, year_len: int=392):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=392):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_392",
    "sat": "def sat(n: int, year_len: int=393):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=393):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_393",
    "sat": "def sat(n: int, year_len: int=394):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=394):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_394",
    "sat": "def sat(n: int, year_len: int=395):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=395):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_395",
    "sat": "def sat(n: int, year_len: int=396):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=396):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_396",
    "sat": "def sat(n: int, year_len: int=397):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=397):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_397",
    "sat": "def sat(n: int, year_len: int=398):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=398):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_398",
    "sat": "def sat(n: int, year_len: int=399):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=399):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_399",
    "sat": "def sat(n: int, year_len: int=400):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=400):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_400",
    "sat": "def sat(n: int, year_len: int=401):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=401):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_401",
    "sat": "def sat(n: int, year_len: int=402):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=402):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_402",
    "sat": "def sat(n: int, year_len: int=403):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=403):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_403",
    "sat": "def sat(n: int, year_len: int=404):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=404):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_404",
    "sat": "def sat(n: int, year_len: int=405):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=405):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_405",
    "sat": "def sat(n: int, year_len: int=406):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=406):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_406",
    "sat": "def sat(n: int, year_len: int=407):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=407):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_407",
    "sat": "def sat(n: int, year_len: int=408):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=408):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_408",
    "sat": "def sat(n: int, year_len: int=409):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=409):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_409",
    "sat": "def sat(n: int, year_len: int=410):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=410):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_410",
    "sat": "def sat(n: int, year_len: int=411):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=411):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_411",
    "sat": "def sat(n: int, year_len: int=412):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=412):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_412",
    "sat": "def sat(n: int, year_len: int=413):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=413):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_413",
    "sat": "def sat(n: int, year_len: int=414):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=414):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_414",
    "sat": "def sat(n: int, year_len: int=415):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=415):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_415",
    "sat": "def sat(n: int, year_len: int=416):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=416):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_416",
    "sat": "def sat(n: int, year_len: int=417):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=417):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_417",
    "sat": "def sat(n: int, year_len: int=418):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=418):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_418",
    "sat": "def sat(n: int, year_len: int=419):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=419):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_419",
    "sat": "def sat(n: int, year_len: int=420):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=420):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_420",
    "sat": "def sat(n: int, year_len: int=421):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=421):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_421",
    "sat": "def sat(n: int, year_len: int=422):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=422):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_422",
    "sat": "def sat(n: int, year_len: int=423):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=423):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_423",
    "sat": "def sat(n: int, year_len: int=424):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=424):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_424",
    "sat": "def sat(n: int, year_len: int=425):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=425):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_425",
    "sat": "def sat(n: int, year_len: int=426):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=426):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_426",
    "sat": "def sat(n: int, year_len: int=427):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=427):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_427",
    "sat": "def sat(n: int, year_len: int=428):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=428):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_428",
    "sat": "def sat(n: int, year_len: int=429):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=429):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_429",
    "sat": "def sat(n: int, year_len: int=430):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=430):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_430",
    "sat": "def sat(n: int, year_len: int=431):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=431):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_431",
    "sat": "def sat(n: int, year_len: int=432):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=432):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_432",
    "sat": "def sat(n: int, year_len: int=433):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=433):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_433",
    "sat": "def sat(n: int, year_len: int=434):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=434):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_434",
    "sat": "def sat(n: int, year_len: int=435):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=435):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_435",
    "sat": "def sat(n: int, year_len: int=436):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=436):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_436",
    "sat": "def sat(n: int, year_len: int=437):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=437):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_437",
    "sat": "def sat(n: int, year_len: int=438):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=438):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_438",
    "sat": "def sat(n: int, year_len: int=439):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=439):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_439",
    "sat": "def sat(n: int, year_len: int=440):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=440):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_440",
    "sat": "def sat(n: int, year_len: int=441):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=441):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_441",
    "sat": "def sat(n: int, year_len: int=442):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=442):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_442",
    "sat": "def sat(n: int, year_len: int=443):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=443):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_443",
    "sat": "def sat(n: int, year_len: int=444):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=444):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_444",
    "sat": "def sat(n: int, year_len: int=445):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=445):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_445",
    "sat": "def sat(n: int, year_len: int=446):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=446):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_446",
    "sat": "def sat(n: int, year_len: int=447):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=447):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_447",
    "sat": "def sat(n: int, year_len: int=448):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=448):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_448",
    "sat": "def sat(n: int, year_len: int=449):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=449):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_449",
    "sat": "def sat(n: int, year_len: int=450):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=450):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_450",
    "sat": "def sat(n: int, year_len: int=451):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=451):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_451",
    "sat": "def sat(n: int, year_len: int=452):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=452):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_452",
    "sat": "def sat(n: int, year_len: int=453):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=453):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_453",
    "sat": "def sat(n: int, year_len: int=454):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=454):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_454",
    "sat": "def sat(n: int, year_len: int=455):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=455):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_455",
    "sat": "def sat(n: int, year_len: int=456):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=456):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_456",
    "sat": "def sat(n: int, year_len: int=457):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=457):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_457",
    "sat": "def sat(n: int, year_len: int=458):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=458):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_458",
    "sat": "def sat(n: int, year_len: int=459):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=459):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_459",
    "sat": "def sat(n: int, year_len: int=460):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=460):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_460",
    "sat": "def sat(n: int, year_len: int=461):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=461):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_461",
    "sat": "def sat(n: int, year_len: int=462):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=462):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_462",
    "sat": "def sat(n: int, year_len: int=463):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=463):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_463",
    "sat": "def sat(n: int, year_len: int=464):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=464):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_464",
    "sat": "def sat(n: int, year_len: int=465):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=465):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_465",
    "sat": "def sat(n: int, year_len: int=466):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=466):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_466",
    "sat": "def sat(n: int, year_len: int=467):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=467):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_467",
    "sat": "def sat(n: int, year_len: int=468):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=468):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_468",
    "sat": "def sat(n: int, year_len: int=469):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=469):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_469",
    "sat": "def sat(n: int, year_len: int=470):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=470):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_470",
    "sat": "def sat(n: int, year_len: int=471):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=471):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_471",
    "sat": "def sat(n: int, year_len: int=472):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=472):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_472",
    "sat": "def sat(n: int, year_len: int=473):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=473):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_473",
    "sat": "def sat(n: int, year_len: int=474):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=474):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_474",
    "sat": "def sat(n: int, year_len: int=475):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=475):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_475",
    "sat": "def sat(n: int, year_len: int=476):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=476):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_476",
    "sat": "def sat(n: int, year_len: int=477):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=477):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_477",
    "sat": "def sat(n: int, year_len: int=478):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=478):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_478",
    "sat": "def sat(n: int, year_len: int=479):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=479):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_479",
    "sat": "def sat(n: int, year_len: int=480):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=480):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_480",
    "sat": "def sat(n: int, year_len: int=481):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=481):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_481",
    "sat": "def sat(n: int, year_len: int=482):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=482):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_482",
    "sat": "def sat(n: int, year_len: int=483):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=483):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_483",
    "sat": "def sat(n: int, year_len: int=484):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=484):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_484",
    "sat": "def sat(n: int, year_len: int=485):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=485):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_485",
    "sat": "def sat(n: int, year_len: int=486):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=486):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_486",
    "sat": "def sat(n: int, year_len: int=487):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=487):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_487",
    "sat": "def sat(n: int, year_len: int=488):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=488):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_488",
    "sat": "def sat(n: int, year_len: int=489):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=489):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_489",
    "sat": "def sat(n: int, year_len: int=490):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=490):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_490",
    "sat": "def sat(n: int, year_len: int=491):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=491):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_491",
    "sat": "def sat(n: int, year_len: int=492):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=492):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_492",
    "sat": "def sat(n: int, year_len: int=493):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=493):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_493",
    "sat": "def sat(n: int, year_len: int=494):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=494):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_494",
    "sat": "def sat(n: int, year_len: int=495):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=495):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_495",
    "sat": "def sat(n: int, year_len: int=496):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=496):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_496",
    "sat": "def sat(n: int, year_len: int=497):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=497):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_497",
    "sat": "def sat(n: int, year_len: int=498):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=498):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_498",
    "sat": "def sat(n: int, year_len: int=499):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=499):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_499",
    "sat": "def sat(n: int, year_len: int=500):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=500):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_500",
    "sat": "def sat(n: int, year_len: int=501):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=501):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_501",
    "sat": "def sat(n: int, year_len: int=502):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=502):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_502",
    "sat": "def sat(n: int, year_len: int=503):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=503):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_503",
    "sat": "def sat(n: int, year_len: int=504):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=504):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_504",
    "sat": "def sat(n: int, year_len: int=505):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=505):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_505",
    "sat": "def sat(n: int, year_len: int=506):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=506):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_506",
    "sat": "def sat(n: int, year_len: int=507):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=507):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_507",
    "sat": "def sat(n: int, year_len: int=508):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=508):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_508",
    "sat": "def sat(n: int, year_len: int=509):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=509):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_509",
    "sat": "def sat(n: int, year_len: int=510):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=510):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_510",
    "sat": "def sat(n: int, year_len: int=511):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=511):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_511",
    "sat": "def sat(n: int, year_len: int=512):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=512):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_512",
    "sat": "def sat(n: int, year_len: int=513):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=513):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_513",
    "sat": "def sat(n: int, year_len: int=514):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=514):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_514",
    "sat": "def sat(n: int, year_len: int=515):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=515):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_515",
    "sat": "def sat(n: int, year_len: int=516):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=516):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_516",
    "sat": "def sat(n: int, year_len: int=517):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=517):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_517",
    "sat": "def sat(n: int, year_len: int=518):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=518):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_518",
    "sat": "def sat(n: int, year_len: int=519):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=519):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_519",
    "sat": "def sat(n: int, year_len: int=520):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=520):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_520",
    "sat": "def sat(n: int, year_len: int=521):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=521):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_521",
    "sat": "def sat(n: int, year_len: int=522):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=522):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_522",
    "sat": "def sat(n: int, year_len: int=523):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=523):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_523",
    "sat": "def sat(n: int, year_len: int=524):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=524):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_524",
    "sat": "def sat(n: int, year_len: int=525):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=525):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_525",
    "sat": "def sat(n: int, year_len: int=526):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=526):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_526",
    "sat": "def sat(n: int, year_len: int=527):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=527):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_527",
    "sat": "def sat(n: int, year_len: int=528):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=528):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_528",
    "sat": "def sat(n: int, year_len: int=529):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=529):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_529",
    "sat": "def sat(n: int, year_len: int=530):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=530):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_530",
    "sat": "def sat(n: int, year_len: int=531):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=531):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_531",
    "sat": "def sat(n: int, year_len: int=532):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=532):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_532",
    "sat": "def sat(n: int, year_len: int=533):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=533):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_533",
    "sat": "def sat(n: int, year_len: int=534):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=534):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_534",
    "sat": "def sat(n: int, year_len: int=535):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=535):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_535",
    "sat": "def sat(n: int, year_len: int=536):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=536):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_536",
    "sat": "def sat(n: int, year_len: int=537):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=537):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_537",
    "sat": "def sat(n: int, year_len: int=538):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=538):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_538",
    "sat": "def sat(n: int, year_len: int=539):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=539):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_539",
    "sat": "def sat(n: int, year_len: int=540):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=540):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_540",
    "sat": "def sat(n: int, year_len: int=541):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=541):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_541",
    "sat": "def sat(n: int, year_len: int=542):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=542):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_542",
    "sat": "def sat(n: int, year_len: int=543):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=543):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_543",
    "sat": "def sat(n: int, year_len: int=544):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=544):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_544",
    "sat": "def sat(n: int, year_len: int=545):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=545):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_545",
    "sat": "def sat(n: int, year_len: int=546):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=546):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_546",
    "sat": "def sat(n: int, year_len: int=547):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=547):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_547",
    "sat": "def sat(n: int, year_len: int=548):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=548):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_548",
    "sat": "def sat(n: int, year_len: int=549):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=549):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_549",
    "sat": "def sat(n: int, year_len: int=550):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=550):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_550",
    "sat": "def sat(n: int, year_len: int=551):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=551):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_551",
    "sat": "def sat(n: int, year_len: int=552):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=552):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_552",
    "sat": "def sat(n: int, year_len: int=553):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=553):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_553",
    "sat": "def sat(n: int, year_len: int=554):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=554):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_554",
    "sat": "def sat(n: int, year_len: int=555):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=555):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_555",
    "sat": "def sat(n: int, year_len: int=556):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=556):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_556",
    "sat": "def sat(n: int, year_len: int=557):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=557):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_557",
    "sat": "def sat(n: int, year_len: int=558):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=558):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_558",
    "sat": "def sat(n: int, year_len: int=559):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=559):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_559",
    "sat": "def sat(n: int, year_len: int=560):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=560):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_560",
    "sat": "def sat(n: int, year_len: int=561):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=561):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_561",
    "sat": "def sat(n: int, year_len: int=562):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=562):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_562",
    "sat": "def sat(n: int, year_len: int=563):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=563):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_563",
    "sat": "def sat(n: int, year_len: int=564):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=564):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_564",
    "sat": "def sat(n: int, year_len: int=565):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=565):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_565",
    "sat": "def sat(n: int, year_len: int=566):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=566):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_566",
    "sat": "def sat(n: int, year_len: int=567):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=567):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_567",
    "sat": "def sat(n: int, year_len: int=568):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=568):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_568",
    "sat": "def sat(n: int, year_len: int=569):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=569):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_569",
    "sat": "def sat(n: int, year_len: int=570):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=570):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_570",
    "sat": "def sat(n: int, year_len: int=571):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=571):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_571",
    "sat": "def sat(n: int, year_len: int=572):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=572):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_572",
    "sat": "def sat(n: int, year_len: int=573):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=573):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_573",
    "sat": "def sat(n: int, year_len: int=574):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=574):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_574",
    "sat": "def sat(n: int, year_len: int=575):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=575):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_575",
    "sat": "def sat(n: int, year_len: int=576):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=576):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_576",
    "sat": "def sat(n: int, year_len: int=577):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=577):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_577",
    "sat": "def sat(n: int, year_len: int=578):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=578):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_578",
    "sat": "def sat(n: int, year_len: int=579):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=579):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_579",
    "sat": "def sat(n: int, year_len: int=580):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=580):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_580",
    "sat": "def sat(n: int, year_len: int=581):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=581):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_581",
    "sat": "def sat(n: int, year_len: int=582):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=582):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_582",
    "sat": "def sat(n: int, year_len: int=583):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=583):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_583",
    "sat": "def sat(n: int, year_len: int=584):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=584):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_584",
    "sat": "def sat(n: int, year_len: int=585):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=585):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_585",
    "sat": "def sat(n: int, year_len: int=586):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=586):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_586",
    "sat": "def sat(n: int, year_len: int=587):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=587):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_587",
    "sat": "def sat(n: int, year_len: int=588):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=588):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_588",
    "sat": "def sat(n: int, year_len: int=589):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=589):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_589",
    "sat": "def sat(n: int, year_len: int=590):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=590):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_590",
    "sat": "def sat(n: int, year_len: int=591):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=591):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_591",
    "sat": "def sat(n: int, year_len: int=592):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=592):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_592",
    "sat": "def sat(n: int, year_len: int=593):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=593):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_593",
    "sat": "def sat(n: int, year_len: int=594):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=594):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_594",
    "sat": "def sat(n: int, year_len: int=595):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=595):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_595",
    "sat": "def sat(n: int, year_len: int=596):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=596):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_596",
    "sat": "def sat(n: int, year_len: int=597):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=597):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_597",
    "sat": "def sat(n: int, year_len: int=598):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=598):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_598",
    "sat": "def sat(n: int, year_len: int=599):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=599):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_599",
    "sat": "def sat(n: int, year_len: int=600):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=600):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_600",
    "sat": "def sat(n: int, year_len: int=601):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=601):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_601",
    "sat": "def sat(n: int, year_len: int=602):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=602):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_602",
    "sat": "def sat(n: int, year_len: int=603):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=603):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_603",
    "sat": "def sat(n: int, year_len: int=604):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=604):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_604",
    "sat": "def sat(n: int, year_len: int=605):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=605):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_605",
    "sat": "def sat(n: int, year_len: int=606):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=606):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_606",
    "sat": "def sat(n: int, year_len: int=607):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=607):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_607",
    "sat": "def sat(n: int, year_len: int=608):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=608):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_608",
    "sat": "def sat(n: int, year_len: int=609):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=609):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_609",
    "sat": "def sat(n: int, year_len: int=610):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=610):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_610",
    "sat": "def sat(n: int, year_len: int=611):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=611):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_611",
    "sat": "def sat(n: int, year_len: int=612):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=612):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_612",
    "sat": "def sat(n: int, year_len: int=613):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=613):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_613",
    "sat": "def sat(n: int, year_len: int=614):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=614):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_614",
    "sat": "def sat(n: int, year_len: int=615):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=615):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_615",
    "sat": "def sat(n: int, year_len: int=616):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=616):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_616",
    "sat": "def sat(n: int, year_len: int=617):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=617):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_617",
    "sat": "def sat(n: int, year_len: int=618):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=618):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_618",
    "sat": "def sat(n: int, year_len: int=619):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=619):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_619",
    "sat": "def sat(n: int, year_len: int=620):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=620):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_620",
    "sat": "def sat(n: int, year_len: int=621):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=621):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_621",
    "sat": "def sat(n: int, year_len: int=622):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=622):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_622",
    "sat": "def sat(n: int, year_len: int=623):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=623):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_623",
    "sat": "def sat(n: int, year_len: int=624):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=624):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_624",
    "sat": "def sat(n: int, year_len: int=625):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=625):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_625",
    "sat": "def sat(n: int, year_len: int=626):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=626):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_626",
    "sat": "def sat(n: int, year_len: int=627):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=627):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_627",
    "sat": "def sat(n: int, year_len: int=628):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=628):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_628",
    "sat": "def sat(n: int, year_len: int=629):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=629):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_629",
    "sat": "def sat(n: int, year_len: int=630):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=630):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_630",
    "sat": "def sat(n: int, year_len: int=631):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=631):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_631",
    "sat": "def sat(n: int, year_len: int=632):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=632):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_632",
    "sat": "def sat(n: int, year_len: int=633):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=633):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_633",
    "sat": "def sat(n: int, year_len: int=634):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=634):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_634",
    "sat": "def sat(n: int, year_len: int=635):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=635):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_635",
    "sat": "def sat(n: int, year_len: int=636):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=636):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_636",
    "sat": "def sat(n: int, year_len: int=637):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=637):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_637",
    "sat": "def sat(n: int, year_len: int=638):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=638):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_638",
    "sat": "def sat(n: int, year_len: int=639):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=639):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_639",
    "sat": "def sat(n: int, year_len: int=640):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=640):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_640",
    "sat": "def sat(n: int, year_len: int=641):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=641):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_641",
    "sat": "def sat(n: int, year_len: int=642):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=642):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_642",
    "sat": "def sat(n: int, year_len: int=643):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=643):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_643",
    "sat": "def sat(n: int, year_len: int=644):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=644):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_644",
    "sat": "def sat(n: int, year_len: int=645):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=645):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_645",
    "sat": "def sat(n: int, year_len: int=646):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=646):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_646",
    "sat": "def sat(n: int, year_len: int=647):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=647):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_647",
    "sat": "def sat(n: int, year_len: int=648):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=648):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_648",
    "sat": "def sat(n: int, year_len: int=649):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=649):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_649",
    "sat": "def sat(n: int, year_len: int=650):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=650):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_650",
    "sat": "def sat(n: int, year_len: int=651):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=651):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_651",
    "sat": "def sat(n: int, year_len: int=652):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=652):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_652",
    "sat": "def sat(n: int, year_len: int=653):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=653):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_653",
    "sat": "def sat(n: int, year_len: int=654):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=654):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_654",
    "sat": "def sat(n: int, year_len: int=655):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=655):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_655",
    "sat": "def sat(n: int, year_len: int=656):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=656):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_656",
    "sat": "def sat(n: int, year_len: int=657):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=657):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_657",
    "sat": "def sat(n: int, year_len: int=658):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=658):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_658",
    "sat": "def sat(n: int, year_len: int=659):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=659):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_659",
    "sat": "def sat(n: int, year_len: int=660):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=660):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_660",
    "sat": "def sat(n: int, year_len: int=661):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=661):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_661",
    "sat": "def sat(n: int, year_len: int=662):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=662):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_662",
    "sat": "def sat(n: int, year_len: int=663):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=663):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_663",
    "sat": "def sat(n: int, year_len: int=664):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=664):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_664",
    "sat": "def sat(n: int, year_len: int=665):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=665):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_665",
    "sat": "def sat(n: int, year_len: int=666):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=666):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_666",
    "sat": "def sat(n: int, year_len: int=667):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=667):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_667",
    "sat": "def sat(n: int, year_len: int=668):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=668):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_668",
    "sat": "def sat(n: int, year_len: int=669):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=669):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_669",
    "sat": "def sat(n: int, year_len: int=670):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=670):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_670",
    "sat": "def sat(n: int, year_len: int=671):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=671):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_671",
    "sat": "def sat(n: int, year_len: int=672):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=672):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_672",
    "sat": "def sat(n: int, year_len: int=673):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=673):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_673",
    "sat": "def sat(n: int, year_len: int=674):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=674):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_674",
    "sat": "def sat(n: int, year_len: int=675):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=675):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_675",
    "sat": "def sat(n: int, year_len: int=676):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=676):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_676",
    "sat": "def sat(n: int, year_len: int=677):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=677):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_677",
    "sat": "def sat(n: int, year_len: int=678):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=678):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_678",
    "sat": "def sat(n: int, year_len: int=679):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=679):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_679",
    "sat": "def sat(n: int, year_len: int=680):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=680):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_680",
    "sat": "def sat(n: int, year_len: int=681):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=681):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_681",
    "sat": "def sat(n: int, year_len: int=682):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=682):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_682",
    "sat": "def sat(n: int, year_len: int=683):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=683):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_683",
    "sat": "def sat(n: int, year_len: int=684):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=684):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_684",
    "sat": "def sat(n: int, year_len: int=685):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=685):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_685",
    "sat": "def sat(n: int, year_len: int=686):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=686):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_686",
    "sat": "def sat(n: int, year_len: int=687):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=687):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_687",
    "sat": "def sat(n: int, year_len: int=688):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=688):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_688",
    "sat": "def sat(n: int, year_len: int=689):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=689):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_689",
    "sat": "def sat(n: int, year_len: int=690):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=690):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_690",
    "sat": "def sat(n: int, year_len: int=691):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=691):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_691",
    "sat": "def sat(n: int, year_len: int=692):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=692):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_692",
    "sat": "def sat(n: int, year_len: int=693):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=693):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_693",
    "sat": "def sat(n: int, year_len: int=694):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=694):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_694",
    "sat": "def sat(n: int, year_len: int=695):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=695):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_695",
    "sat": "def sat(n: int, year_len: int=696):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=696):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_696",
    "sat": "def sat(n: int, year_len: int=697):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=697):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_697",
    "sat": "def sat(n: int, year_len: int=698):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=698):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_698",
    "sat": "def sat(n: int, year_len: int=699):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=699):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_699",
    "sat": "def sat(n: int, year_len: int=700):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=700):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_700",
    "sat": "def sat(n: int, year_len: int=701):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=701):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_701",
    "sat": "def sat(n: int, year_len: int=702):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=702):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_702",
    "sat": "def sat(n: int, year_len: int=703):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=703):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_703",
    "sat": "def sat(n: int, year_len: int=704):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=704):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_704",
    "sat": "def sat(n: int, year_len: int=705):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=705):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_705",
    "sat": "def sat(n: int, year_len: int=706):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=706):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_706",
    "sat": "def sat(n: int, year_len: int=707):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=707):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_707",
    "sat": "def sat(n: int, year_len: int=708):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=708):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_708",
    "sat": "def sat(n: int, year_len: int=709):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=709):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_709",
    "sat": "def sat(n: int, year_len: int=710):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=710):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_710",
    "sat": "def sat(n: int, year_len: int=711):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=711):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_711",
    "sat": "def sat(n: int, year_len: int=712):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=712):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_712",
    "sat": "def sat(n: int, year_len: int=713):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=713):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_713",
    "sat": "def sat(n: int, year_len: int=714):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=714):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_714",
    "sat": "def sat(n: int, year_len: int=715):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=715):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_715",
    "sat": "def sat(n: int, year_len: int=716):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=716):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_716",
    "sat": "def sat(n: int, year_len: int=717):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=717):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_717",
    "sat": "def sat(n: int, year_len: int=718):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=718):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_718",
    "sat": "def sat(n: int, year_len: int=719):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=719):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_719",
    "sat": "def sat(n: int, year_len: int=720):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=720):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_720",
    "sat": "def sat(n: int, year_len: int=721):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=721):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_721",
    "sat": "def sat(n: int, year_len: int=722):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=722):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_722",
    "sat": "def sat(n: int, year_len: int=723):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=723):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_723",
    "sat": "def sat(n: int, year_len: int=724):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=724):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_724",
    "sat": "def sat(n: int, year_len: int=725):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=725):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_725",
    "sat": "def sat(n: int, year_len: int=726):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=726):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_726",
    "sat": "def sat(n: int, year_len: int=727):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=727):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_727",
    "sat": "def sat(n: int, year_len: int=728):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=728):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_728",
    "sat": "def sat(n: int, year_len: int=729):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=729):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_729",
    "sat": "def sat(n: int, year_len: int=730):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=730):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_730",
    "sat": "def sat(n: int, year_len: int=731):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=731):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_731",
    "sat": "def sat(n: int, year_len: int=732):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=732):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_732",
    "sat": "def sat(n: int, year_len: int=733):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=733):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_733",
    "sat": "def sat(n: int, year_len: int=734):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=734):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_734",
    "sat": "def sat(n: int, year_len: int=735):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=735):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_735",
    "sat": "def sat(n: int, year_len: int=736):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=736):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_736",
    "sat": "def sat(n: int, year_len: int=737):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=737):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_737",
    "sat": "def sat(n: int, year_len: int=738):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=738):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_738",
    "sat": "def sat(n: int, year_len: int=739):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=739):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_739",
    "sat": "def sat(n: int, year_len: int=740):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=740):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_740",
    "sat": "def sat(n: int, year_len: int=741):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=741):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_741",
    "sat": "def sat(n: int, year_len: int=742):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=742):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_742",
    "sat": "def sat(n: int, year_len: int=743):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=743):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_743",
    "sat": "def sat(n: int, year_len: int=744):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=744):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_744",
    "sat": "def sat(n: int, year_len: int=745):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=745):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_745",
    "sat": "def sat(n: int, year_len: int=746):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=746):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_746",
    "sat": "def sat(n: int, year_len: int=747):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=747):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_747",
    "sat": "def sat(n: int, year_len: int=748):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=748):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_748",
    "sat": "def sat(n: int, year_len: int=749):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=749):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_749",
    "sat": "def sat(n: int, year_len: int=750):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=750):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_750",
    "sat": "def sat(n: int, year_len: int=751):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=751):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_751",
    "sat": "def sat(n: int, year_len: int=752):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=752):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_752",
    "sat": "def sat(n: int, year_len: int=753):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=753):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_753",
    "sat": "def sat(n: int, year_len: int=754):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=754):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_754",
    "sat": "def sat(n: int, year_len: int=755):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=755):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_755",
    "sat": "def sat(n: int, year_len: int=756):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=756):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_756",
    "sat": "def sat(n: int, year_len: int=757):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=757):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_757",
    "sat": "def sat(n: int, year_len: int=758):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=758):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_758",
    "sat": "def sat(n: int, year_len: int=759):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=759):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_759",
    "sat": "def sat(n: int, year_len: int=760):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=760):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_760",
    "sat": "def sat(n: int, year_len: int=761):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=761):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_761",
    "sat": "def sat(n: int, year_len: int=762):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=762):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_762",
    "sat": "def sat(n: int, year_len: int=763):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=763):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_763",
    "sat": "def sat(n: int, year_len: int=764):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=764):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_764",
    "sat": "def sat(n: int, year_len: int=765):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=765):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_765",
    "sat": "def sat(n: int, year_len: int=766):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=766):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_766",
    "sat": "def sat(n: int, year_len: int=767):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=767):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_767",
    "sat": "def sat(n: int, year_len: int=768):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=768):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_768",
    "sat": "def sat(n: int, year_len: int=769):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=769):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_769",
    "sat": "def sat(n: int, year_len: int=770):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=770):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_770",
    "sat": "def sat(n: int, year_len: int=771):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=771):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_771",
    "sat": "def sat(n: int, year_len: int=772):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=772):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_772",
    "sat": "def sat(n: int, year_len: int=773):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=773):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_773",
    "sat": "def sat(n: int, year_len: int=774):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=774):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_774",
    "sat": "def sat(n: int, year_len: int=775):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=775):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_775",
    "sat": "def sat(n: int, year_len: int=776):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=776):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_776",
    "sat": "def sat(n: int, year_len: int=777):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=777):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_777",
    "sat": "def sat(n: int, year_len: int=778):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=778):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_778",
    "sat": "def sat(n: int, year_len: int=779):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=779):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_779",
    "sat": "def sat(n: int, year_len: int=780):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=780):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_780",
    "sat": "def sat(n: int, year_len: int=781):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=781):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_781",
    "sat": "def sat(n: int, year_len: int=782):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=782):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_782",
    "sat": "def sat(n: int, year_len: int=783):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=783):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_783",
    "sat": "def sat(n: int, year_len: int=784):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=784):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_784",
    "sat": "def sat(n: int, year_len: int=785):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=785):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_785",
    "sat": "def sat(n: int, year_len: int=786):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=786):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_786",
    "sat": "def sat(n: int, year_len: int=787):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=787):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_787",
    "sat": "def sat(n: int, year_len: int=788):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=788):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_788",
    "sat": "def sat(n: int, year_len: int=789):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=789):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_789",
    "sat": "def sat(n: int, year_len: int=790):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=790):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_790",
    "sat": "def sat(n: int, year_len: int=791):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=791):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_791",
    "sat": "def sat(n: int, year_len: int=792):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=792):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_792",
    "sat": "def sat(n: int, year_len: int=793):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=793):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_793",
    "sat": "def sat(n: int, year_len: int=794):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=794):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_794",
    "sat": "def sat(n: int, year_len: int=795):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=795):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_795",
    "sat": "def sat(n: int, year_len: int=796):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=796):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_796",
    "sat": "def sat(n: int, year_len: int=797):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=797):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_797",
    "sat": "def sat(n: int, year_len: int=798):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=798):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_798",
    "sat": "def sat(n: int, year_len: int=799):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=799):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_799",
    "sat": "def sat(n: int, year_len: int=800):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=800):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_800",
    "sat": "def sat(n: int, year_len: int=801):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=801):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_801",
    "sat": "def sat(n: int, year_len: int=802):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=802):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_802",
    "sat": "def sat(n: int, year_len: int=803):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=803):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_803",
    "sat": "def sat(n: int, year_len: int=804):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=804):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_804",
    "sat": "def sat(n: int, year_len: int=805):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=805):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_805",
    "sat": "def sat(n: int, year_len: int=806):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=806):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_806",
    "sat": "def sat(n: int, year_len: int=807):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=807):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_807",
    "sat": "def sat(n: int, year_len: int=808):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=808):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_808",
    "sat": "def sat(n: int, year_len: int=809):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=809):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_809",
    "sat": "def sat(n: int, year_len: int=810):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=810):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_810",
    "sat": "def sat(n: int, year_len: int=811):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=811):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_811",
    "sat": "def sat(n: int, year_len: int=812):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=812):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_812",
    "sat": "def sat(n: int, year_len: int=813):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=813):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_813",
    "sat": "def sat(n: int, year_len: int=814):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=814):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_814",
    "sat": "def sat(n: int, year_len: int=815):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=815):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_815",
    "sat": "def sat(n: int, year_len: int=816):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=816):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_816",
    "sat": "def sat(n: int, year_len: int=817):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=817):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_817",
    "sat": "def sat(n: int, year_len: int=818):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=818):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_818",
    "sat": "def sat(n: int, year_len: int=819):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=819):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_819",
    "sat": "def sat(n: int, year_len: int=820):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=820):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_820",
    "sat": "def sat(n: int, year_len: int=821):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=821):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_821",
    "sat": "def sat(n: int, year_len: int=822):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=822):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_822",
    "sat": "def sat(n: int, year_len: int=823):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=823):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_823",
    "sat": "def sat(n: int, year_len: int=824):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=824):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_824",
    "sat": "def sat(n: int, year_len: int=825):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=825):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_825",
    "sat": "def sat(n: int, year_len: int=826):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=826):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_826",
    "sat": "def sat(n: int, year_len: int=827):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=827):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_827",
    "sat": "def sat(n: int, year_len: int=828):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=828):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_828",
    "sat": "def sat(n: int, year_len: int=829):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=829):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_829",
    "sat": "def sat(n: int, year_len: int=830):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=830):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_830",
    "sat": "def sat(n: int, year_len: int=831):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=831):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_831",
    "sat": "def sat(n: int, year_len: int=832):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=832):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_832",
    "sat": "def sat(n: int, year_len: int=833):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=833):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_833",
    "sat": "def sat(n: int, year_len: int=834):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=834):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_834",
    "sat": "def sat(n: int, year_len: int=835):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=835):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_835",
    "sat": "def sat(n: int, year_len: int=836):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=836):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_836",
    "sat": "def sat(n: int, year_len: int=837):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=837):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_837",
    "sat": "def sat(n: int, year_len: int=838):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=838):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_838",
    "sat": "def sat(n: int, year_len: int=839):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=839):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_839",
    "sat": "def sat(n: int, year_len: int=840):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=840):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_840",
    "sat": "def sat(n: int, year_len: int=841):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=841):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_841",
    "sat": "def sat(n: int, year_len: int=842):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=842):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_842",
    "sat": "def sat(n: int, year_len: int=843):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=843):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_843",
    "sat": "def sat(n: int, year_len: int=844):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=844):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_844",
    "sat": "def sat(n: int, year_len: int=845):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=845):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_845",
    "sat": "def sat(n: int, year_len: int=846):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=846):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_846",
    "sat": "def sat(n: int, year_len: int=847):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=847):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_847",
    "sat": "def sat(n: int, year_len: int=848):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=848):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_848",
    "sat": "def sat(n: int, year_len: int=849):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=849):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_849",
    "sat": "def sat(n: int, year_len: int=850):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=850):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_850",
    "sat": "def sat(n: int, year_len: int=851):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=851):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_851",
    "sat": "def sat(n: int, year_len: int=852):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=852):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_852",
    "sat": "def sat(n: int, year_len: int=853):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=853):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_853",
    "sat": "def sat(n: int, year_len: int=854):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=854):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_854",
    "sat": "def sat(n: int, year_len: int=855):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=855):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_855",
    "sat": "def sat(n: int, year_len: int=856):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=856):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_856",
    "sat": "def sat(n: int, year_len: int=857):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=857):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_857",
    "sat": "def sat(n: int, year_len: int=858):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=858):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_858",
    "sat": "def sat(n: int, year_len: int=859):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=859):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_859",
    "sat": "def sat(n: int, year_len: int=860):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=860):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_860",
    "sat": "def sat(n: int, year_len: int=861):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=861):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_861",
    "sat": "def sat(n: int, year_len: int=862):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=862):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_862",
    "sat": "def sat(n: int, year_len: int=863):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=863):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_863",
    "sat": "def sat(n: int, year_len: int=864):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=864):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_864",
    "sat": "def sat(n: int, year_len: int=865):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=865):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_865",
    "sat": "def sat(n: int, year_len: int=866):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=866):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_866",
    "sat": "def sat(n: int, year_len: int=867):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=867):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_867",
    "sat": "def sat(n: int, year_len: int=868):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=868):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_868",
    "sat": "def sat(n: int, year_len: int=869):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=869):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_869",
    "sat": "def sat(n: int, year_len: int=870):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=870):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_870",
    "sat": "def sat(n: int, year_len: int=871):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=871):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_871",
    "sat": "def sat(n: int, year_len: int=872):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=872):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_872",
    "sat": "def sat(n: int, year_len: int=873):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=873):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_873",
    "sat": "def sat(n: int, year_len: int=874):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=874):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_874",
    "sat": "def sat(n: int, year_len: int=875):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=875):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_875",
    "sat": "def sat(n: int, year_len: int=876):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=876):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_876",
    "sat": "def sat(n: int, year_len: int=877):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=877):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_877",
    "sat": "def sat(n: int, year_len: int=878):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=878):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_878",
    "sat": "def sat(n: int, year_len: int=879):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=879):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_879",
    "sat": "def sat(n: int, year_len: int=880):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=880):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_880",
    "sat": "def sat(n: int, year_len: int=881):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=881):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_881",
    "sat": "def sat(n: int, year_len: int=882):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=882):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_882",
    "sat": "def sat(n: int, year_len: int=883):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=883):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_883",
    "sat": "def sat(n: int, year_len: int=884):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=884):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_884",
    "sat": "def sat(n: int, year_len: int=885):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=885):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_885",
    "sat": "def sat(n: int, year_len: int=886):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=886):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_886",
    "sat": "def sat(n: int, year_len: int=887):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=887):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_887",
    "sat": "def sat(n: int, year_len: int=888):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=888):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_888",
    "sat": "def sat(n: int, year_len: int=889):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=889):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_889",
    "sat": "def sat(n: int, year_len: int=890):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=890):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_890",
    "sat": "def sat(n: int, year_len: int=891):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=891):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_891",
    "sat": "def sat(n: int, year_len: int=892):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=892):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_892",
    "sat": "def sat(n: int, year_len: int=893):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=893):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_893",
    "sat": "def sat(n: int, year_len: int=894):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=894):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_894",
    "sat": "def sat(n: int, year_len: int=895):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=895):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_895",
    "sat": "def sat(n: int, year_len: int=896):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=896):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_896",
    "sat": "def sat(n: int, year_len: int=897):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=897):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_897",
    "sat": "def sat(n: int, year_len: int=898):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=898):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_898",
    "sat": "def sat(n: int, year_len: int=899):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=899):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_899",
    "sat": "def sat(n: int, year_len: int=900):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=900):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_900",
    "sat": "def sat(n: int, year_len: int=901):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=901):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_901",
    "sat": "def sat(n: int, year_len: int=902):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=902):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_902",
    "sat": "def sat(n: int, year_len: int=903):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=903):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_903",
    "sat": "def sat(n: int, year_len: int=904):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=904):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_904",
    "sat": "def sat(n: int, year_len: int=905):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=905):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_905",
    "sat": "def sat(n: int, year_len: int=906):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=906):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_906",
    "sat": "def sat(n: int, year_len: int=907):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=907):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_907",
    "sat": "def sat(n: int, year_len: int=908):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=908):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_908",
    "sat": "def sat(n: int, year_len: int=909):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=909):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_909",
    "sat": "def sat(n: int, year_len: int=910):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=910):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_910",
    "sat": "def sat(n: int, year_len: int=911):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=911):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_911",
    "sat": "def sat(n: int, year_len: int=912):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=912):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_912",
    "sat": "def sat(n: int, year_len: int=913):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=913):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_913",
    "sat": "def sat(n: int, year_len: int=914):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=914):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_914",
    "sat": "def sat(n: int, year_len: int=915):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=915):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_915",
    "sat": "def sat(n: int, year_len: int=916):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=916):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_916",
    "sat": "def sat(n: int, year_len: int=917):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=917):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_917",
    "sat": "def sat(n: int, year_len: int=918):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=918):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_918",
    "sat": "def sat(n: int, year_len: int=919):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=919):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_919",
    "sat": "def sat(n: int, year_len: int=920):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=920):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_920",
    "sat": "def sat(n: int, year_len: int=921):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=921):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_921",
    "sat": "def sat(n: int, year_len: int=922):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=922):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_922",
    "sat": "def sat(n: int, year_len: int=923):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=923):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_923",
    "sat": "def sat(n: int, year_len: int=924):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=924):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_924",
    "sat": "def sat(n: int, year_len: int=925):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=925):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_925",
    "sat": "def sat(n: int, year_len: int=926):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=926):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_926",
    "sat": "def sat(n: int, year_len: int=927):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=927):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_927",
    "sat": "def sat(n: int, year_len: int=928):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=928):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_928",
    "sat": "def sat(n: int, year_len: int=929):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=929):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_929",
    "sat": "def sat(n: int, year_len: int=930):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=930):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_930",
    "sat": "def sat(n: int, year_len: int=931):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=931):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_931",
    "sat": "def sat(n: int, year_len: int=932):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=932):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_932",
    "sat": "def sat(n: int, year_len: int=933):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=933):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_933",
    "sat": "def sat(n: int, year_len: int=934):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=934):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_934",
    "sat": "def sat(n: int, year_len: int=935):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=935):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_935",
    "sat": "def sat(n: int, year_len: int=936):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=936):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_936",
    "sat": "def sat(n: int, year_len: int=937):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=937):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_937",
    "sat": "def sat(n: int, year_len: int=938):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=938):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_938",
    "sat": "def sat(n: int, year_len: int=939):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=939):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_939",
    "sat": "def sat(n: int, year_len: int=940):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=940):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_940",
    "sat": "def sat(n: int, year_len: int=941):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=941):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_941",
    "sat": "def sat(n: int, year_len: int=942):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=942):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_942",
    "sat": "def sat(n: int, year_len: int=943):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=943):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_943",
    "sat": "def sat(n: int, year_len: int=944):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=944):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_944",
    "sat": "def sat(n: int, year_len: int=945):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=945):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_945",
    "sat": "def sat(n: int, year_len: int=946):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=946):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_946",
    "sat": "def sat(n: int, year_len: int=947):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=947):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_947",
    "sat": "def sat(n: int, year_len: int=948):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=948):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_948",
    "sat": "def sat(n: int, year_len: int=949):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=949):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_949",
    "sat": "def sat(n: int, year_len: int=950):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=950):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_950",
    "sat": "def sat(n: int, year_len: int=951):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=951):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_951",
    "sat": "def sat(n: int, year_len: int=952):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=952):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_952",
    "sat": "def sat(n: int, year_len: int=953):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=953):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_953",
    "sat": "def sat(n: int, year_len: int=954):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=954):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_954",
    "sat": "def sat(n: int, year_len: int=955):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=955):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_955",
    "sat": "def sat(n: int, year_len: int=956):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=956):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_956",
    "sat": "def sat(n: int, year_len: int=957):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=957):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_957",
    "sat": "def sat(n: int, year_len: int=958):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=958):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_958",
    "sat": "def sat(n: int, year_len: int=959):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=959):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_959",
    "sat": "def sat(n: int, year_len: int=960):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=960):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_960",
    "sat": "def sat(n: int, year_len: int=961):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=961):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_961",
    "sat": "def sat(n: int, year_len: int=962):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=962):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_962",
    "sat": "def sat(n: int, year_len: int=963):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=963):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_963",
    "sat": "def sat(n: int, year_len: int=964):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=964):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_964",
    "sat": "def sat(n: int, year_len: int=965):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=965):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_965",
    "sat": "def sat(n: int, year_len: int=966):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=966):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_966",
    "sat": "def sat(n: int, year_len: int=967):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=967):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_967",
    "sat": "def sat(n: int, year_len: int=968):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=968):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_968",
    "sat": "def sat(n: int, year_len: int=969):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=969):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_969",
    "sat": "def sat(n: int, year_len: int=970):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=970):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_970",
    "sat": "def sat(n: int, year_len: int=971):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=971):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_971",
    "sat": "def sat(n: int, year_len: int=972):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=972):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_972",
    "sat": "def sat(n: int, year_len: int=973):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=973):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_973",
    "sat": "def sat(n: int, year_len: int=974):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=974):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_974",
    "sat": "def sat(n: int, year_len: int=975):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=975):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_975",
    "sat": "def sat(n: int, year_len: int=976):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=976):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_976",
    "sat": "def sat(n: int, year_len: int=977):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=977):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_977",
    "sat": "def sat(n: int, year_len: int=978):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=978):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_978",
    "sat": "def sat(n: int, year_len: int=979):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=979):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_979",
    "sat": "def sat(n: int, year_len: int=980):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=980):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_980",
    "sat": "def sat(n: int, year_len: int=981):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=981):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_981",
    "sat": "def sat(n: int, year_len: int=982):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=982):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_982",
    "sat": "def sat(n: int, year_len: int=983):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=983):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_983",
    "sat": "def sat(n: int, year_len: int=984):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=984):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_984",
    "sat": "def sat(n: int, year_len: int=985):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=985):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_985",
    "sat": "def sat(n: int, year_len: int=986):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=986):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_986",
    "sat": "def sat(n: int, year_len: int=987):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=987):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_987",
    "sat": "def sat(n: int, year_len: int=988):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=988):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_988",
    "sat": "def sat(n: int, year_len: int=989):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=989):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_989",
    "sat": "def sat(n: int, year_len: int=990):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=990):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_990",
    "sat": "def sat(n: int, year_len: int=991):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=991):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_991",
    "sat": "def sat(n: int, year_len: int=992):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=992):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_992",
    "sat": "def sat(n: int, year_len: int=993):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=993):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_993",
    "sat": "def sat(n: int, year_len: int=994):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=994):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_994",
    "sat": "def sat(n: int, year_len: int=995):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=995):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_995",
    "sat": "def sat(n: int, year_len: int=996):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=996):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_996",
    "sat": "def sat(n: int, year_len: int=997):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=997):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_997",
    "sat": "def sat(n: int, year_len: int=998):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=998):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_998",
    "sat": "def sat(n: int, year_len: int=999):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=999):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadox_999",
    "sat": "def sat(n: int, year_len: int=1000):\n    assert type(n) is int, 'n must be of type int'\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "sols": [
      "def sol(year_len=1000):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_0",
    "sat": "def sat(n: int, year_len: int=365):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_1",
    "sat": "def sat(n: int, year_len: int=60182):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_2",
    "sat": "def sat(n: int, year_len: int=2):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_3",
    "sat": "def sat(n: int, year_len: int=3):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_4",
    "sat": "def sat(n: int, year_len: int=4):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=4):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_5",
    "sat": "def sat(n: int, year_len: int=5):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=5):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_6",
    "sat": "def sat(n: int, year_len: int=6):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=6):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_7",
    "sat": "def sat(n: int, year_len: int=7):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=7):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_8",
    "sat": "def sat(n: int, year_len: int=8):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=8):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_9",
    "sat": "def sat(n: int, year_len: int=9):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=9):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_10",
    "sat": "def sat(n: int, year_len: int=10):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=10):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_11",
    "sat": "def sat(n: int, year_len: int=11):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=11):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_12",
    "sat": "def sat(n: int, year_len: int=12):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=12):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_13",
    "sat": "def sat(n: int, year_len: int=13):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=13):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_14",
    "sat": "def sat(n: int, year_len: int=14):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=14):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_15",
    "sat": "def sat(n: int, year_len: int=15):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=15):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_16",
    "sat": "def sat(n: int, year_len: int=16):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=16):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_17",
    "sat": "def sat(n: int, year_len: int=17):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=17):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_18",
    "sat": "def sat(n: int, year_len: int=18):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=18):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_19",
    "sat": "def sat(n: int, year_len: int=19):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=19):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_20",
    "sat": "def sat(n: int, year_len: int=20):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=20):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_21",
    "sat": "def sat(n: int, year_len: int=21):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=21):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_22",
    "sat": "def sat(n: int, year_len: int=22):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=22):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_23",
    "sat": "def sat(n: int, year_len: int=23):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=23):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_24",
    "sat": "def sat(n: int, year_len: int=24):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=24):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_25",
    "sat": "def sat(n: int, year_len: int=25):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=25):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_26",
    "sat": "def sat(n: int, year_len: int=26):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=26):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_27",
    "sat": "def sat(n: int, year_len: int=27):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=27):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_28",
    "sat": "def sat(n: int, year_len: int=28):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=28):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_29",
    "sat": "def sat(n: int, year_len: int=29):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=29):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_30",
    "sat": "def sat(n: int, year_len: int=30):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=30):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_31",
    "sat": "def sat(n: int, year_len: int=31):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=31):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_32",
    "sat": "def sat(n: int, year_len: int=32):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=32):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_33",
    "sat": "def sat(n: int, year_len: int=33):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=33):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_34",
    "sat": "def sat(n: int, year_len: int=34):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=34):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_35",
    "sat": "def sat(n: int, year_len: int=35):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=35):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_36",
    "sat": "def sat(n: int, year_len: int=36):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=36):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_37",
    "sat": "def sat(n: int, year_len: int=37):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=37):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_38",
    "sat": "def sat(n: int, year_len: int=38):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=38):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_39",
    "sat": "def sat(n: int, year_len: int=39):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=39):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_40",
    "sat": "def sat(n: int, year_len: int=40):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=40):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_41",
    "sat": "def sat(n: int, year_len: int=41):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=41):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_42",
    "sat": "def sat(n: int, year_len: int=42):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=42):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_43",
    "sat": "def sat(n: int, year_len: int=43):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=43):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_44",
    "sat": "def sat(n: int, year_len: int=44):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=44):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_45",
    "sat": "def sat(n: int, year_len: int=45):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=45):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_46",
    "sat": "def sat(n: int, year_len: int=46):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=46):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_47",
    "sat": "def sat(n: int, year_len: int=47):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=47):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_48",
    "sat": "def sat(n: int, year_len: int=48):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=48):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_49",
    "sat": "def sat(n: int, year_len: int=49):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=49):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_50",
    "sat": "def sat(n: int, year_len: int=50):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=50):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_51",
    "sat": "def sat(n: int, year_len: int=51):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=51):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_52",
    "sat": "def sat(n: int, year_len: int=52):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=52):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_53",
    "sat": "def sat(n: int, year_len: int=53):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=53):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_54",
    "sat": "def sat(n: int, year_len: int=54):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=54):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_55",
    "sat": "def sat(n: int, year_len: int=55):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=55):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_56",
    "sat": "def sat(n: int, year_len: int=56):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=56):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_57",
    "sat": "def sat(n: int, year_len: int=57):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=57):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_58",
    "sat": "def sat(n: int, year_len: int=58):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=58):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_59",
    "sat": "def sat(n: int, year_len: int=59):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=59):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_60",
    "sat": "def sat(n: int, year_len: int=60):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=60):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_61",
    "sat": "def sat(n: int, year_len: int=61):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=61):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_62",
    "sat": "def sat(n: int, year_len: int=62):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=62):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_63",
    "sat": "def sat(n: int, year_len: int=63):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=63):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_64",
    "sat": "def sat(n: int, year_len: int=64):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=64):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_65",
    "sat": "def sat(n: int, year_len: int=65):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=65):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_66",
    "sat": "def sat(n: int, year_len: int=66):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=66):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_67",
    "sat": "def sat(n: int, year_len: int=67):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=67):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_68",
    "sat": "def sat(n: int, year_len: int=68):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=68):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_69",
    "sat": "def sat(n: int, year_len: int=69):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=69):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_70",
    "sat": "def sat(n: int, year_len: int=70):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=70):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_71",
    "sat": "def sat(n: int, year_len: int=71):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=71):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_72",
    "sat": "def sat(n: int, year_len: int=72):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=72):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_73",
    "sat": "def sat(n: int, year_len: int=73):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=73):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_74",
    "sat": "def sat(n: int, year_len: int=74):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=74):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_75",
    "sat": "def sat(n: int, year_len: int=75):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=75):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_76",
    "sat": "def sat(n: int, year_len: int=76):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=76):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_77",
    "sat": "def sat(n: int, year_len: int=77):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=77):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_78",
    "sat": "def sat(n: int, year_len: int=78):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=78):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_79",
    "sat": "def sat(n: int, year_len: int=79):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=79):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_80",
    "sat": "def sat(n: int, year_len: int=80):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=80):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_81",
    "sat": "def sat(n: int, year_len: int=81):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=81):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_82",
    "sat": "def sat(n: int, year_len: int=82):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=82):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_83",
    "sat": "def sat(n: int, year_len: int=83):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=83):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_84",
    "sat": "def sat(n: int, year_len: int=84):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=84):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_85",
    "sat": "def sat(n: int, year_len: int=85):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=85):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_86",
    "sat": "def sat(n: int, year_len: int=86):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=86):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_87",
    "sat": "def sat(n: int, year_len: int=87):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=87):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_88",
    "sat": "def sat(n: int, year_len: int=88):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=88):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_89",
    "sat": "def sat(n: int, year_len: int=89):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=89):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_90",
    "sat": "def sat(n: int, year_len: int=90):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=90):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_91",
    "sat": "def sat(n: int, year_len: int=91):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=91):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_92",
    "sat": "def sat(n: int, year_len: int=92):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=92):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_93",
    "sat": "def sat(n: int, year_len: int=93):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=93):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_94",
    "sat": "def sat(n: int, year_len: int=94):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=94):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_95",
    "sat": "def sat(n: int, year_len: int=95):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=95):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_96",
    "sat": "def sat(n: int, year_len: int=96):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=96):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_97",
    "sat": "def sat(n: int, year_len: int=97):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=97):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_98",
    "sat": "def sat(n: int, year_len: int=98):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=98):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_99",
    "sat": "def sat(n: int, year_len: int=99):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=99):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_100",
    "sat": "def sat(n: int, year_len: int=100):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=100):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_101",
    "sat": "def sat(n: int, year_len: int=101):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=101):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_102",
    "sat": "def sat(n: int, year_len: int=102):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=102):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_103",
    "sat": "def sat(n: int, year_len: int=103):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=103):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_104",
    "sat": "def sat(n: int, year_len: int=104):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=104):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_105",
    "sat": "def sat(n: int, year_len: int=105):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=105):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_106",
    "sat": "def sat(n: int, year_len: int=106):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=106):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_107",
    "sat": "def sat(n: int, year_len: int=107):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=107):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_108",
    "sat": "def sat(n: int, year_len: int=108):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=108):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_109",
    "sat": "def sat(n: int, year_len: int=109):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=109):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_110",
    "sat": "def sat(n: int, year_len: int=110):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=110):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_111",
    "sat": "def sat(n: int, year_len: int=111):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=111):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_112",
    "sat": "def sat(n: int, year_len: int=112):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=112):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_113",
    "sat": "def sat(n: int, year_len: int=113):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=113):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_114",
    "sat": "def sat(n: int, year_len: int=114):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=114):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_115",
    "sat": "def sat(n: int, year_len: int=115):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=115):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_116",
    "sat": "def sat(n: int, year_len: int=116):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=116):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_117",
    "sat": "def sat(n: int, year_len: int=117):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=117):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_118",
    "sat": "def sat(n: int, year_len: int=118):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=118):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_119",
    "sat": "def sat(n: int, year_len: int=119):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=119):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_120",
    "sat": "def sat(n: int, year_len: int=120):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=120):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_121",
    "sat": "def sat(n: int, year_len: int=121):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=121):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_122",
    "sat": "def sat(n: int, year_len: int=122):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=122):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_123",
    "sat": "def sat(n: int, year_len: int=123):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=123):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_124",
    "sat": "def sat(n: int, year_len: int=124):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=124):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_125",
    "sat": "def sat(n: int, year_len: int=125):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=125):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_126",
    "sat": "def sat(n: int, year_len: int=126):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=126):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_127",
    "sat": "def sat(n: int, year_len: int=127):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=127):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_128",
    "sat": "def sat(n: int, year_len: int=128):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=128):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_129",
    "sat": "def sat(n: int, year_len: int=129):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=129):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_130",
    "sat": "def sat(n: int, year_len: int=130):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=130):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_131",
    "sat": "def sat(n: int, year_len: int=131):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=131):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_132",
    "sat": "def sat(n: int, year_len: int=132):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=132):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_133",
    "sat": "def sat(n: int, year_len: int=133):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=133):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_134",
    "sat": "def sat(n: int, year_len: int=134):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=134):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_135",
    "sat": "def sat(n: int, year_len: int=135):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=135):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_136",
    "sat": "def sat(n: int, year_len: int=136):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=136):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_137",
    "sat": "def sat(n: int, year_len: int=137):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=137):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_138",
    "sat": "def sat(n: int, year_len: int=138):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=138):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_139",
    "sat": "def sat(n: int, year_len: int=139):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=139):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_140",
    "sat": "def sat(n: int, year_len: int=140):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=140):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_141",
    "sat": "def sat(n: int, year_len: int=141):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=141):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_142",
    "sat": "def sat(n: int, year_len: int=142):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=142):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_143",
    "sat": "def sat(n: int, year_len: int=143):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=143):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_144",
    "sat": "def sat(n: int, year_len: int=144):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=144):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_145",
    "sat": "def sat(n: int, year_len: int=145):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=145):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_146",
    "sat": "def sat(n: int, year_len: int=146):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=146):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_147",
    "sat": "def sat(n: int, year_len: int=147):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=147):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_148",
    "sat": "def sat(n: int, year_len: int=148):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=148):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_149",
    "sat": "def sat(n: int, year_len: int=149):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=149):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_150",
    "sat": "def sat(n: int, year_len: int=150):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=150):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_151",
    "sat": "def sat(n: int, year_len: int=151):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=151):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_152",
    "sat": "def sat(n: int, year_len: int=152):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=152):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_153",
    "sat": "def sat(n: int, year_len: int=153):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=153):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_154",
    "sat": "def sat(n: int, year_len: int=154):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=154):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_155",
    "sat": "def sat(n: int, year_len: int=155):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=155):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_156",
    "sat": "def sat(n: int, year_len: int=156):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=156):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_157",
    "sat": "def sat(n: int, year_len: int=157):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=157):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_158",
    "sat": "def sat(n: int, year_len: int=158):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=158):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_159",
    "sat": "def sat(n: int, year_len: int=159):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=159):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_160",
    "sat": "def sat(n: int, year_len: int=160):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=160):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_161",
    "sat": "def sat(n: int, year_len: int=161):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=161):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_162",
    "sat": "def sat(n: int, year_len: int=162):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=162):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_163",
    "sat": "def sat(n: int, year_len: int=163):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=163):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_164",
    "sat": "def sat(n: int, year_len: int=164):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=164):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_165",
    "sat": "def sat(n: int, year_len: int=165):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=165):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_166",
    "sat": "def sat(n: int, year_len: int=166):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=166):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_167",
    "sat": "def sat(n: int, year_len: int=167):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=167):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_168",
    "sat": "def sat(n: int, year_len: int=168):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=168):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_169",
    "sat": "def sat(n: int, year_len: int=169):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=169):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_170",
    "sat": "def sat(n: int, year_len: int=170):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=170):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_171",
    "sat": "def sat(n: int, year_len: int=171):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=171):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_172",
    "sat": "def sat(n: int, year_len: int=172):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=172):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_173",
    "sat": "def sat(n: int, year_len: int=173):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=173):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_174",
    "sat": "def sat(n: int, year_len: int=174):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=174):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_175",
    "sat": "def sat(n: int, year_len: int=175):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=175):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_176",
    "sat": "def sat(n: int, year_len: int=176):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=176):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_177",
    "sat": "def sat(n: int, year_len: int=177):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=177):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_178",
    "sat": "def sat(n: int, year_len: int=178):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=178):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_179",
    "sat": "def sat(n: int, year_len: int=179):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=179):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_180",
    "sat": "def sat(n: int, year_len: int=180):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=180):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_181",
    "sat": "def sat(n: int, year_len: int=181):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=181):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_182",
    "sat": "def sat(n: int, year_len: int=182):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_183",
    "sat": "def sat(n: int, year_len: int=183):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=183):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_184",
    "sat": "def sat(n: int, year_len: int=184):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=184):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_185",
    "sat": "def sat(n: int, year_len: int=185):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=185):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_186",
    "sat": "def sat(n: int, year_len: int=186):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=186):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_187",
    "sat": "def sat(n: int, year_len: int=187):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=187):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_188",
    "sat": "def sat(n: int, year_len: int=188):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=188):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_189",
    "sat": "def sat(n: int, year_len: int=189):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=189):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_190",
    "sat": "def sat(n: int, year_len: int=190):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=190):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_191",
    "sat": "def sat(n: int, year_len: int=191):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=191):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_192",
    "sat": "def sat(n: int, year_len: int=192):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=192):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_193",
    "sat": "def sat(n: int, year_len: int=193):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=193):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_194",
    "sat": "def sat(n: int, year_len: int=194):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=194):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_195",
    "sat": "def sat(n: int, year_len: int=195):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=195):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_196",
    "sat": "def sat(n: int, year_len: int=196):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=196):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_197",
    "sat": "def sat(n: int, year_len: int=197):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=197):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_198",
    "sat": "def sat(n: int, year_len: int=198):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=198):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_199",
    "sat": "def sat(n: int, year_len: int=199):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=199):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_200",
    "sat": "def sat(n: int, year_len: int=200):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=200):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_201",
    "sat": "def sat(n: int, year_len: int=201):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=201):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_202",
    "sat": "def sat(n: int, year_len: int=202):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=202):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_203",
    "sat": "def sat(n: int, year_len: int=203):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=203):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_204",
    "sat": "def sat(n: int, year_len: int=204):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=204):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_205",
    "sat": "def sat(n: int, year_len: int=205):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=205):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_206",
    "sat": "def sat(n: int, year_len: int=206):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=206):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_207",
    "sat": "def sat(n: int, year_len: int=207):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=207):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_208",
    "sat": "def sat(n: int, year_len: int=208):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=208):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_209",
    "sat": "def sat(n: int, year_len: int=209):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=209):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_210",
    "sat": "def sat(n: int, year_len: int=210):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=210):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_211",
    "sat": "def sat(n: int, year_len: int=211):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=211):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_212",
    "sat": "def sat(n: int, year_len: int=212):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=212):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_213",
    "sat": "def sat(n: int, year_len: int=213):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=213):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_214",
    "sat": "def sat(n: int, year_len: int=214):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=214):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_215",
    "sat": "def sat(n: int, year_len: int=215):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=215):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_216",
    "sat": "def sat(n: int, year_len: int=216):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=216):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_217",
    "sat": "def sat(n: int, year_len: int=217):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=217):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_218",
    "sat": "def sat(n: int, year_len: int=218):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=218):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_219",
    "sat": "def sat(n: int, year_len: int=219):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=219):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_220",
    "sat": "def sat(n: int, year_len: int=220):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=220):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_221",
    "sat": "def sat(n: int, year_len: int=221):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=221):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_222",
    "sat": "def sat(n: int, year_len: int=222):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=222):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_223",
    "sat": "def sat(n: int, year_len: int=223):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=223):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_224",
    "sat": "def sat(n: int, year_len: int=224):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=224):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_225",
    "sat": "def sat(n: int, year_len: int=225):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=225):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_226",
    "sat": "def sat(n: int, year_len: int=226):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=226):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_227",
    "sat": "def sat(n: int, year_len: int=227):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=227):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_228",
    "sat": "def sat(n: int, year_len: int=228):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=228):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_229",
    "sat": "def sat(n: int, year_len: int=229):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=229):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_230",
    "sat": "def sat(n: int, year_len: int=230):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=230):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_231",
    "sat": "def sat(n: int, year_len: int=231):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=231):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_232",
    "sat": "def sat(n: int, year_len: int=232):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=232):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_233",
    "sat": "def sat(n: int, year_len: int=233):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=233):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_234",
    "sat": "def sat(n: int, year_len: int=234):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=234):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_235",
    "sat": "def sat(n: int, year_len: int=235):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=235):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_236",
    "sat": "def sat(n: int, year_len: int=236):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=236):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_237",
    "sat": "def sat(n: int, year_len: int=237):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=237):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_238",
    "sat": "def sat(n: int, year_len: int=238):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=238):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_239",
    "sat": "def sat(n: int, year_len: int=239):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=239):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_240",
    "sat": "def sat(n: int, year_len: int=240):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=240):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_241",
    "sat": "def sat(n: int, year_len: int=241):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=241):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_242",
    "sat": "def sat(n: int, year_len: int=242):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=242):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_243",
    "sat": "def sat(n: int, year_len: int=243):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=243):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_244",
    "sat": "def sat(n: int, year_len: int=244):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=244):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_245",
    "sat": "def sat(n: int, year_len: int=245):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=245):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_246",
    "sat": "def sat(n: int, year_len: int=246):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=246):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_247",
    "sat": "def sat(n: int, year_len: int=247):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=247):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_248",
    "sat": "def sat(n: int, year_len: int=248):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=248):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_249",
    "sat": "def sat(n: int, year_len: int=249):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=249):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_250",
    "sat": "def sat(n: int, year_len: int=250):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=250):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_251",
    "sat": "def sat(n: int, year_len: int=251):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=251):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_252",
    "sat": "def sat(n: int, year_len: int=252):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=252):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_253",
    "sat": "def sat(n: int, year_len: int=253):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=253):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_254",
    "sat": "def sat(n: int, year_len: int=254):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=254):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_255",
    "sat": "def sat(n: int, year_len: int=255):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=255):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_256",
    "sat": "def sat(n: int, year_len: int=256):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=256):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_257",
    "sat": "def sat(n: int, year_len: int=257):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=257):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_258",
    "sat": "def sat(n: int, year_len: int=258):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=258):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_259",
    "sat": "def sat(n: int, year_len: int=259):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=259):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_260",
    "sat": "def sat(n: int, year_len: int=260):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=260):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_261",
    "sat": "def sat(n: int, year_len: int=261):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=261):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_262",
    "sat": "def sat(n: int, year_len: int=262):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=262):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_263",
    "sat": "def sat(n: int, year_len: int=263):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=263):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_264",
    "sat": "def sat(n: int, year_len: int=264):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=264):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_265",
    "sat": "def sat(n: int, year_len: int=265):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=265):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_266",
    "sat": "def sat(n: int, year_len: int=266):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=266):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_267",
    "sat": "def sat(n: int, year_len: int=267):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=267):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_268",
    "sat": "def sat(n: int, year_len: int=268):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=268):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_269",
    "sat": "def sat(n: int, year_len: int=269):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=269):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_270",
    "sat": "def sat(n: int, year_len: int=270):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=270):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_271",
    "sat": "def sat(n: int, year_len: int=271):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=271):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_272",
    "sat": "def sat(n: int, year_len: int=272):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=272):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_273",
    "sat": "def sat(n: int, year_len: int=273):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=273):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_274",
    "sat": "def sat(n: int, year_len: int=274):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=274):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_275",
    "sat": "def sat(n: int, year_len: int=275):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=275):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_276",
    "sat": "def sat(n: int, year_len: int=276):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=276):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_277",
    "sat": "def sat(n: int, year_len: int=277):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=277):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_278",
    "sat": "def sat(n: int, year_len: int=278):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=278):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_279",
    "sat": "def sat(n: int, year_len: int=279):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=279):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_280",
    "sat": "def sat(n: int, year_len: int=280):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=280):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_281",
    "sat": "def sat(n: int, year_len: int=281):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=281):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_282",
    "sat": "def sat(n: int, year_len: int=282):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=282):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_283",
    "sat": "def sat(n: int, year_len: int=283):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=283):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_284",
    "sat": "def sat(n: int, year_len: int=284):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=284):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_285",
    "sat": "def sat(n: int, year_len: int=285):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=285):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_286",
    "sat": "def sat(n: int, year_len: int=286):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=286):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_287",
    "sat": "def sat(n: int, year_len: int=287):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=287):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_288",
    "sat": "def sat(n: int, year_len: int=288):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=288):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_289",
    "sat": "def sat(n: int, year_len: int=289):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=289):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_290",
    "sat": "def sat(n: int, year_len: int=290):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=290):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_291",
    "sat": "def sat(n: int, year_len: int=291):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=291):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_292",
    "sat": "def sat(n: int, year_len: int=292):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=292):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_293",
    "sat": "def sat(n: int, year_len: int=293):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=293):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_294",
    "sat": "def sat(n: int, year_len: int=294):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=294):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_295",
    "sat": "def sat(n: int, year_len: int=295):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=295):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_296",
    "sat": "def sat(n: int, year_len: int=296):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=296):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_297",
    "sat": "def sat(n: int, year_len: int=297):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=297):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_298",
    "sat": "def sat(n: int, year_len: int=298):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=298):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_299",
    "sat": "def sat(n: int, year_len: int=299):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=299):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_300",
    "sat": "def sat(n: int, year_len: int=300):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=300):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_301",
    "sat": "def sat(n: int, year_len: int=301):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=301):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_302",
    "sat": "def sat(n: int, year_len: int=302):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=302):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_303",
    "sat": "def sat(n: int, year_len: int=303):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=303):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_304",
    "sat": "def sat(n: int, year_len: int=304):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=304):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_305",
    "sat": "def sat(n: int, year_len: int=305):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=305):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_306",
    "sat": "def sat(n: int, year_len: int=306):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=306):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_307",
    "sat": "def sat(n: int, year_len: int=307):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=307):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_308",
    "sat": "def sat(n: int, year_len: int=308):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=308):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_309",
    "sat": "def sat(n: int, year_len: int=309):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=309):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_310",
    "sat": "def sat(n: int, year_len: int=310):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=310):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_311",
    "sat": "def sat(n: int, year_len: int=311):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=311):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_312",
    "sat": "def sat(n: int, year_len: int=312):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=312):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_313",
    "sat": "def sat(n: int, year_len: int=313):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=313):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_314",
    "sat": "def sat(n: int, year_len: int=314):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=314):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_315",
    "sat": "def sat(n: int, year_len: int=315):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=315):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_316",
    "sat": "def sat(n: int, year_len: int=316):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=316):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_317",
    "sat": "def sat(n: int, year_len: int=317):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=317):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_318",
    "sat": "def sat(n: int, year_len: int=318):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=318):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_319",
    "sat": "def sat(n: int, year_len: int=319):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=319):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_320",
    "sat": "def sat(n: int, year_len: int=320):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=320):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_321",
    "sat": "def sat(n: int, year_len: int=321):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=321):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_322",
    "sat": "def sat(n: int, year_len: int=322):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=322):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_323",
    "sat": "def sat(n: int, year_len: int=323):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=323):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_324",
    "sat": "def sat(n: int, year_len: int=324):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=324):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_325",
    "sat": "def sat(n: int, year_len: int=325):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=325):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_326",
    "sat": "def sat(n: int, year_len: int=326):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=326):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_327",
    "sat": "def sat(n: int, year_len: int=327):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=327):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_328",
    "sat": "def sat(n: int, year_len: int=328):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=328):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_329",
    "sat": "def sat(n: int, year_len: int=329):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=329):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_330",
    "sat": "def sat(n: int, year_len: int=330):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=330):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_331",
    "sat": "def sat(n: int, year_len: int=331):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=331):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_332",
    "sat": "def sat(n: int, year_len: int=332):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=332):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_333",
    "sat": "def sat(n: int, year_len: int=333):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=333):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_334",
    "sat": "def sat(n: int, year_len: int=334):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=334):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_335",
    "sat": "def sat(n: int, year_len: int=335):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=335):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_336",
    "sat": "def sat(n: int, year_len: int=336):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=336):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_337",
    "sat": "def sat(n: int, year_len: int=337):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=337):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_338",
    "sat": "def sat(n: int, year_len: int=338):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=338):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_339",
    "sat": "def sat(n: int, year_len: int=339):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=339):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_340",
    "sat": "def sat(n: int, year_len: int=340):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=340):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_341",
    "sat": "def sat(n: int, year_len: int=341):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=341):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_342",
    "sat": "def sat(n: int, year_len: int=342):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=342):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_343",
    "sat": "def sat(n: int, year_len: int=343):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=343):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_344",
    "sat": "def sat(n: int, year_len: int=344):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=344):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_345",
    "sat": "def sat(n: int, year_len: int=345):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=345):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_346",
    "sat": "def sat(n: int, year_len: int=346):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=346):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_347",
    "sat": "def sat(n: int, year_len: int=347):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=347):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_348",
    "sat": "def sat(n: int, year_len: int=348):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=348):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_349",
    "sat": "def sat(n: int, year_len: int=349):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=349):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_350",
    "sat": "def sat(n: int, year_len: int=350):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=350):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_351",
    "sat": "def sat(n: int, year_len: int=351):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=351):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_352",
    "sat": "def sat(n: int, year_len: int=352):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=352):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_353",
    "sat": "def sat(n: int, year_len: int=353):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=353):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_354",
    "sat": "def sat(n: int, year_len: int=354):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=354):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_355",
    "sat": "def sat(n: int, year_len: int=355):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=355):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_356",
    "sat": "def sat(n: int, year_len: int=356):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=356):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_357",
    "sat": "def sat(n: int, year_len: int=357):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=357):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_358",
    "sat": "def sat(n: int, year_len: int=358):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=358):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_359",
    "sat": "def sat(n: int, year_len: int=359):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=359):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_360",
    "sat": "def sat(n: int, year_len: int=360):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=360):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_361",
    "sat": "def sat(n: int, year_len: int=361):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=361):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_362",
    "sat": "def sat(n: int, year_len: int=362):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=362):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_363",
    "sat": "def sat(n: int, year_len: int=363):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=363):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_364",
    "sat": "def sat(n: int, year_len: int=364):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=364):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_365",
    "sat": "def sat(n: int, year_len: int=366):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=366):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_366",
    "sat": "def sat(n: int, year_len: int=367):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=367):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_367",
    "sat": "def sat(n: int, year_len: int=368):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=368):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_368",
    "sat": "def sat(n: int, year_len: int=369):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=369):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_369",
    "sat": "def sat(n: int, year_len: int=370):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=370):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_370",
    "sat": "def sat(n: int, year_len: int=371):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=371):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_371",
    "sat": "def sat(n: int, year_len: int=372):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=372):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_372",
    "sat": "def sat(n: int, year_len: int=373):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=373):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_373",
    "sat": "def sat(n: int, year_len: int=374):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=374):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_374",
    "sat": "def sat(n: int, year_len: int=375):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=375):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_375",
    "sat": "def sat(n: int, year_len: int=376):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=376):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_376",
    "sat": "def sat(n: int, year_len: int=377):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=377):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_377",
    "sat": "def sat(n: int, year_len: int=378):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=378):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_378",
    "sat": "def sat(n: int, year_len: int=379):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=379):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_379",
    "sat": "def sat(n: int, year_len: int=380):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=380):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_380",
    "sat": "def sat(n: int, year_len: int=381):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=381):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_381",
    "sat": "def sat(n: int, year_len: int=382):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=382):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_382",
    "sat": "def sat(n: int, year_len: int=383):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=383):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_383",
    "sat": "def sat(n: int, year_len: int=384):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=384):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_384",
    "sat": "def sat(n: int, year_len: int=385):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=385):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_385",
    "sat": "def sat(n: int, year_len: int=386):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=386):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_386",
    "sat": "def sat(n: int, year_len: int=387):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=387):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_387",
    "sat": "def sat(n: int, year_len: int=388):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=388):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_388",
    "sat": "def sat(n: int, year_len: int=389):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=389):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_389",
    "sat": "def sat(n: int, year_len: int=390):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=390):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_390",
    "sat": "def sat(n: int, year_len: int=391):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=391):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_391",
    "sat": "def sat(n: int, year_len: int=392):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=392):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_392",
    "sat": "def sat(n: int, year_len: int=393):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=393):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_393",
    "sat": "def sat(n: int, year_len: int=394):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=394):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_394",
    "sat": "def sat(n: int, year_len: int=395):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=395):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_395",
    "sat": "def sat(n: int, year_len: int=396):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=396):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_396",
    "sat": "def sat(n: int, year_len: int=397):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=397):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_397",
    "sat": "def sat(n: int, year_len: int=398):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=398):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_398",
    "sat": "def sat(n: int, year_len: int=399):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=399):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_399",
    "sat": "def sat(n: int, year_len: int=400):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=400):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_400",
    "sat": "def sat(n: int, year_len: int=401):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=401):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_401",
    "sat": "def sat(n: int, year_len: int=402):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=402):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_402",
    "sat": "def sat(n: int, year_len: int=403):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=403):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_403",
    "sat": "def sat(n: int, year_len: int=404):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=404):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_404",
    "sat": "def sat(n: int, year_len: int=405):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=405):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_405",
    "sat": "def sat(n: int, year_len: int=406):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=406):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_406",
    "sat": "def sat(n: int, year_len: int=407):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=407):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_407",
    "sat": "def sat(n: int, year_len: int=408):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=408):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_408",
    "sat": "def sat(n: int, year_len: int=409):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=409):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_409",
    "sat": "def sat(n: int, year_len: int=410):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=410):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_410",
    "sat": "def sat(n: int, year_len: int=411):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=411):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_411",
    "sat": "def sat(n: int, year_len: int=412):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=412):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_412",
    "sat": "def sat(n: int, year_len: int=413):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=413):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_413",
    "sat": "def sat(n: int, year_len: int=414):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=414):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_414",
    "sat": "def sat(n: int, year_len: int=415):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=415):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_415",
    "sat": "def sat(n: int, year_len: int=416):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=416):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_416",
    "sat": "def sat(n: int, year_len: int=417):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=417):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_417",
    "sat": "def sat(n: int, year_len: int=418):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=418):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_418",
    "sat": "def sat(n: int, year_len: int=419):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=419):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_419",
    "sat": "def sat(n: int, year_len: int=420):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=420):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_420",
    "sat": "def sat(n: int, year_len: int=421):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=421):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_421",
    "sat": "def sat(n: int, year_len: int=422):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=422):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_422",
    "sat": "def sat(n: int, year_len: int=423):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=423):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_423",
    "sat": "def sat(n: int, year_len: int=424):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=424):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_424",
    "sat": "def sat(n: int, year_len: int=425):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=425):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_425",
    "sat": "def sat(n: int, year_len: int=426):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=426):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_426",
    "sat": "def sat(n: int, year_len: int=427):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=427):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_427",
    "sat": "def sat(n: int, year_len: int=428):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=428):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_428",
    "sat": "def sat(n: int, year_len: int=429):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=429):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_429",
    "sat": "def sat(n: int, year_len: int=430):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=430):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_430",
    "sat": "def sat(n: int, year_len: int=431):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=431):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_431",
    "sat": "def sat(n: int, year_len: int=432):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=432):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_432",
    "sat": "def sat(n: int, year_len: int=433):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=433):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_433",
    "sat": "def sat(n: int, year_len: int=434):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=434):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_434",
    "sat": "def sat(n: int, year_len: int=435):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=435):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_435",
    "sat": "def sat(n: int, year_len: int=436):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=436):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_436",
    "sat": "def sat(n: int, year_len: int=437):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=437):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_437",
    "sat": "def sat(n: int, year_len: int=438):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=438):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_438",
    "sat": "def sat(n: int, year_len: int=439):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=439):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_439",
    "sat": "def sat(n: int, year_len: int=440):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=440):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_440",
    "sat": "def sat(n: int, year_len: int=441):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=441):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_441",
    "sat": "def sat(n: int, year_len: int=442):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=442):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_442",
    "sat": "def sat(n: int, year_len: int=443):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=443):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_443",
    "sat": "def sat(n: int, year_len: int=444):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=444):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_444",
    "sat": "def sat(n: int, year_len: int=445):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=445):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_445",
    "sat": "def sat(n: int, year_len: int=446):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=446):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_446",
    "sat": "def sat(n: int, year_len: int=447):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=447):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_447",
    "sat": "def sat(n: int, year_len: int=448):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=448):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_448",
    "sat": "def sat(n: int, year_len: int=449):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=449):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_449",
    "sat": "def sat(n: int, year_len: int=450):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=450):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_450",
    "sat": "def sat(n: int, year_len: int=451):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=451):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_451",
    "sat": "def sat(n: int, year_len: int=452):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=452):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_452",
    "sat": "def sat(n: int, year_len: int=453):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=453):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_453",
    "sat": "def sat(n: int, year_len: int=454):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=454):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_454",
    "sat": "def sat(n: int, year_len: int=455):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=455):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_455",
    "sat": "def sat(n: int, year_len: int=456):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=456):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_456",
    "sat": "def sat(n: int, year_len: int=457):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=457):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_457",
    "sat": "def sat(n: int, year_len: int=458):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=458):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_458",
    "sat": "def sat(n: int, year_len: int=459):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=459):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_459",
    "sat": "def sat(n: int, year_len: int=460):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=460):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_460",
    "sat": "def sat(n: int, year_len: int=461):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=461):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_461",
    "sat": "def sat(n: int, year_len: int=462):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=462):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_462",
    "sat": "def sat(n: int, year_len: int=463):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=463):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_463",
    "sat": "def sat(n: int, year_len: int=464):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=464):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_464",
    "sat": "def sat(n: int, year_len: int=465):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=465):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_465",
    "sat": "def sat(n: int, year_len: int=466):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=466):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_466",
    "sat": "def sat(n: int, year_len: int=467):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=467):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_467",
    "sat": "def sat(n: int, year_len: int=468):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=468):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_468",
    "sat": "def sat(n: int, year_len: int=469):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=469):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_469",
    "sat": "def sat(n: int, year_len: int=470):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=470):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_470",
    "sat": "def sat(n: int, year_len: int=471):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=471):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_471",
    "sat": "def sat(n: int, year_len: int=472):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=472):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_472",
    "sat": "def sat(n: int, year_len: int=473):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=473):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_473",
    "sat": "def sat(n: int, year_len: int=474):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=474):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_474",
    "sat": "def sat(n: int, year_len: int=475):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=475):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_475",
    "sat": "def sat(n: int, year_len: int=476):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=476):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_476",
    "sat": "def sat(n: int, year_len: int=477):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=477):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_477",
    "sat": "def sat(n: int, year_len: int=478):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=478):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_478",
    "sat": "def sat(n: int, year_len: int=479):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=479):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_479",
    "sat": "def sat(n: int, year_len: int=480):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=480):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_480",
    "sat": "def sat(n: int, year_len: int=481):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=481):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_481",
    "sat": "def sat(n: int, year_len: int=482):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=482):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_482",
    "sat": "def sat(n: int, year_len: int=483):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=483):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_483",
    "sat": "def sat(n: int, year_len: int=484):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=484):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_484",
    "sat": "def sat(n: int, year_len: int=485):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=485):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_485",
    "sat": "def sat(n: int, year_len: int=486):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=486):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_486",
    "sat": "def sat(n: int, year_len: int=487):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=487):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_487",
    "sat": "def sat(n: int, year_len: int=488):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=488):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_488",
    "sat": "def sat(n: int, year_len: int=489):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=489):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_489",
    "sat": "def sat(n: int, year_len: int=490):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=490):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_490",
    "sat": "def sat(n: int, year_len: int=491):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=491):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_491",
    "sat": "def sat(n: int, year_len: int=492):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=492):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_492",
    "sat": "def sat(n: int, year_len: int=493):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=493):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_493",
    "sat": "def sat(n: int, year_len: int=494):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=494):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_494",
    "sat": "def sat(n: int, year_len: int=495):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=495):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_495",
    "sat": "def sat(n: int, year_len: int=496):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=496):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_496",
    "sat": "def sat(n: int, year_len: int=497):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=497):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_497",
    "sat": "def sat(n: int, year_len: int=498):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=498):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_498",
    "sat": "def sat(n: int, year_len: int=499):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=499):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_499",
    "sat": "def sat(n: int, year_len: int=500):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=500):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_500",
    "sat": "def sat(n: int, year_len: int=501):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=501):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_501",
    "sat": "def sat(n: int, year_len: int=502):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=502):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_502",
    "sat": "def sat(n: int, year_len: int=503):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=503):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_503",
    "sat": "def sat(n: int, year_len: int=504):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=504):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_504",
    "sat": "def sat(n: int, year_len: int=505):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=505):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_505",
    "sat": "def sat(n: int, year_len: int=506):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=506):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_506",
    "sat": "def sat(n: int, year_len: int=507):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=507):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_507",
    "sat": "def sat(n: int, year_len: int=508):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=508):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_508",
    "sat": "def sat(n: int, year_len: int=509):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=509):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_509",
    "sat": "def sat(n: int, year_len: int=510):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=510):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_510",
    "sat": "def sat(n: int, year_len: int=511):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=511):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_511",
    "sat": "def sat(n: int, year_len: int=512):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=512):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_512",
    "sat": "def sat(n: int, year_len: int=513):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=513):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_513",
    "sat": "def sat(n: int, year_len: int=514):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=514):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_514",
    "sat": "def sat(n: int, year_len: int=515):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=515):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_515",
    "sat": "def sat(n: int, year_len: int=516):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=516):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_516",
    "sat": "def sat(n: int, year_len: int=517):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=517):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_517",
    "sat": "def sat(n: int, year_len: int=518):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=518):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_518",
    "sat": "def sat(n: int, year_len: int=519):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=519):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_519",
    "sat": "def sat(n: int, year_len: int=520):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=520):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_520",
    "sat": "def sat(n: int, year_len: int=521):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=521):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_521",
    "sat": "def sat(n: int, year_len: int=522):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=522):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_522",
    "sat": "def sat(n: int, year_len: int=523):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=523):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_523",
    "sat": "def sat(n: int, year_len: int=524):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=524):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_524",
    "sat": "def sat(n: int, year_len: int=525):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=525):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_525",
    "sat": "def sat(n: int, year_len: int=526):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=526):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_526",
    "sat": "def sat(n: int, year_len: int=527):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=527):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_527",
    "sat": "def sat(n: int, year_len: int=528):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=528):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_528",
    "sat": "def sat(n: int, year_len: int=529):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=529):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_529",
    "sat": "def sat(n: int, year_len: int=530):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=530):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_530",
    "sat": "def sat(n: int, year_len: int=531):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=531):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_531",
    "sat": "def sat(n: int, year_len: int=532):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=532):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_532",
    "sat": "def sat(n: int, year_len: int=533):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=533):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_533",
    "sat": "def sat(n: int, year_len: int=534):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=534):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_534",
    "sat": "def sat(n: int, year_len: int=535):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=535):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_535",
    "sat": "def sat(n: int, year_len: int=536):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=536):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_536",
    "sat": "def sat(n: int, year_len: int=537):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=537):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_537",
    "sat": "def sat(n: int, year_len: int=538):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=538):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_538",
    "sat": "def sat(n: int, year_len: int=539):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=539):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_539",
    "sat": "def sat(n: int, year_len: int=540):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=540):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_540",
    "sat": "def sat(n: int, year_len: int=541):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=541):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_541",
    "sat": "def sat(n: int, year_len: int=542):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=542):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_542",
    "sat": "def sat(n: int, year_len: int=543):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=543):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_543",
    "sat": "def sat(n: int, year_len: int=544):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=544):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_544",
    "sat": "def sat(n: int, year_len: int=545):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=545):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_545",
    "sat": "def sat(n: int, year_len: int=546):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=546):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_546",
    "sat": "def sat(n: int, year_len: int=547):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=547):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_547",
    "sat": "def sat(n: int, year_len: int=548):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=548):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_548",
    "sat": "def sat(n: int, year_len: int=549):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=549):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_549",
    "sat": "def sat(n: int, year_len: int=550):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=550):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_550",
    "sat": "def sat(n: int, year_len: int=551):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=551):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_551",
    "sat": "def sat(n: int, year_len: int=552):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=552):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_552",
    "sat": "def sat(n: int, year_len: int=553):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=553):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_553",
    "sat": "def sat(n: int, year_len: int=554):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=554):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_554",
    "sat": "def sat(n: int, year_len: int=555):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=555):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_555",
    "sat": "def sat(n: int, year_len: int=556):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=556):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_556",
    "sat": "def sat(n: int, year_len: int=557):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=557):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_557",
    "sat": "def sat(n: int, year_len: int=558):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=558):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_558",
    "sat": "def sat(n: int, year_len: int=559):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=559):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_559",
    "sat": "def sat(n: int, year_len: int=560):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=560):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_560",
    "sat": "def sat(n: int, year_len: int=561):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=561):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_561",
    "sat": "def sat(n: int, year_len: int=562):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=562):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_562",
    "sat": "def sat(n: int, year_len: int=563):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=563):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_563",
    "sat": "def sat(n: int, year_len: int=564):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=564):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_564",
    "sat": "def sat(n: int, year_len: int=565):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=565):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_565",
    "sat": "def sat(n: int, year_len: int=566):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=566):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_566",
    "sat": "def sat(n: int, year_len: int=567):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=567):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_567",
    "sat": "def sat(n: int, year_len: int=568):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=568):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_568",
    "sat": "def sat(n: int, year_len: int=569):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=569):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_569",
    "sat": "def sat(n: int, year_len: int=570):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=570):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_570",
    "sat": "def sat(n: int, year_len: int=571):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=571):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_571",
    "sat": "def sat(n: int, year_len: int=572):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=572):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_572",
    "sat": "def sat(n: int, year_len: int=573):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=573):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_573",
    "sat": "def sat(n: int, year_len: int=574):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=574):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_574",
    "sat": "def sat(n: int, year_len: int=575):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=575):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_575",
    "sat": "def sat(n: int, year_len: int=576):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=576):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_576",
    "sat": "def sat(n: int, year_len: int=577):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=577):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_577",
    "sat": "def sat(n: int, year_len: int=578):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=578):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_578",
    "sat": "def sat(n: int, year_len: int=579):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=579):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_579",
    "sat": "def sat(n: int, year_len: int=580):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=580):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_580",
    "sat": "def sat(n: int, year_len: int=581):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=581):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_581",
    "sat": "def sat(n: int, year_len: int=582):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=582):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_582",
    "sat": "def sat(n: int, year_len: int=583):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=583):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_583",
    "sat": "def sat(n: int, year_len: int=584):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=584):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_584",
    "sat": "def sat(n: int, year_len: int=585):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=585):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_585",
    "sat": "def sat(n: int, year_len: int=586):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=586):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_586",
    "sat": "def sat(n: int, year_len: int=587):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=587):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_587",
    "sat": "def sat(n: int, year_len: int=588):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=588):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_588",
    "sat": "def sat(n: int, year_len: int=589):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=589):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_589",
    "sat": "def sat(n: int, year_len: int=590):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=590):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_590",
    "sat": "def sat(n: int, year_len: int=591):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=591):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_591",
    "sat": "def sat(n: int, year_len: int=592):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=592):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_592",
    "sat": "def sat(n: int, year_len: int=593):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=593):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_593",
    "sat": "def sat(n: int, year_len: int=594):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=594):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_594",
    "sat": "def sat(n: int, year_len: int=595):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=595):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_595",
    "sat": "def sat(n: int, year_len: int=596):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=596):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_596",
    "sat": "def sat(n: int, year_len: int=597):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=597):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_597",
    "sat": "def sat(n: int, year_len: int=598):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=598):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_598",
    "sat": "def sat(n: int, year_len: int=599):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=599):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_599",
    "sat": "def sat(n: int, year_len: int=600):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=600):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_600",
    "sat": "def sat(n: int, year_len: int=601):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=601):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_601",
    "sat": "def sat(n: int, year_len: int=602):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=602):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_602",
    "sat": "def sat(n: int, year_len: int=603):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=603):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_603",
    "sat": "def sat(n: int, year_len: int=604):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=604):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_604",
    "sat": "def sat(n: int, year_len: int=605):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=605):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_605",
    "sat": "def sat(n: int, year_len: int=606):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=606):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_606",
    "sat": "def sat(n: int, year_len: int=607):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=607):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_607",
    "sat": "def sat(n: int, year_len: int=608):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=608):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_608",
    "sat": "def sat(n: int, year_len: int=609):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=609):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_609",
    "sat": "def sat(n: int, year_len: int=610):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=610):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_610",
    "sat": "def sat(n: int, year_len: int=611):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=611):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_611",
    "sat": "def sat(n: int, year_len: int=612):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=612):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_612",
    "sat": "def sat(n: int, year_len: int=613):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=613):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_613",
    "sat": "def sat(n: int, year_len: int=614):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=614):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_614",
    "sat": "def sat(n: int, year_len: int=615):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=615):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_615",
    "sat": "def sat(n: int, year_len: int=616):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=616):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_616",
    "sat": "def sat(n: int, year_len: int=617):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=617):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_617",
    "sat": "def sat(n: int, year_len: int=618):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=618):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_618",
    "sat": "def sat(n: int, year_len: int=619):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=619):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_619",
    "sat": "def sat(n: int, year_len: int=620):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=620):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_620",
    "sat": "def sat(n: int, year_len: int=621):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=621):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_621",
    "sat": "def sat(n: int, year_len: int=622):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=622):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_622",
    "sat": "def sat(n: int, year_len: int=623):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=623):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_623",
    "sat": "def sat(n: int, year_len: int=624):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=624):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_624",
    "sat": "def sat(n: int, year_len: int=625):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=625):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_625",
    "sat": "def sat(n: int, year_len: int=626):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=626):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_626",
    "sat": "def sat(n: int, year_len: int=627):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=627):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_627",
    "sat": "def sat(n: int, year_len: int=628):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=628):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_628",
    "sat": "def sat(n: int, year_len: int=629):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=629):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_629",
    "sat": "def sat(n: int, year_len: int=630):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=630):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_630",
    "sat": "def sat(n: int, year_len: int=631):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=631):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_631",
    "sat": "def sat(n: int, year_len: int=632):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=632):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_632",
    "sat": "def sat(n: int, year_len: int=633):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=633):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_633",
    "sat": "def sat(n: int, year_len: int=634):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=634):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_634",
    "sat": "def sat(n: int, year_len: int=635):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=635):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_635",
    "sat": "def sat(n: int, year_len: int=636):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=636):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_636",
    "sat": "def sat(n: int, year_len: int=637):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=637):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_637",
    "sat": "def sat(n: int, year_len: int=638):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=638):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_638",
    "sat": "def sat(n: int, year_len: int=639):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=639):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_639",
    "sat": "def sat(n: int, year_len: int=640):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=640):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_640",
    "sat": "def sat(n: int, year_len: int=641):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=641):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_641",
    "sat": "def sat(n: int, year_len: int=642):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=642):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_642",
    "sat": "def sat(n: int, year_len: int=643):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=643):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_643",
    "sat": "def sat(n: int, year_len: int=644):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=644):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_644",
    "sat": "def sat(n: int, year_len: int=645):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=645):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_645",
    "sat": "def sat(n: int, year_len: int=646):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=646):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_646",
    "sat": "def sat(n: int, year_len: int=647):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=647):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_647",
    "sat": "def sat(n: int, year_len: int=648):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=648):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_648",
    "sat": "def sat(n: int, year_len: int=649):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=649):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_649",
    "sat": "def sat(n: int, year_len: int=650):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=650):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_650",
    "sat": "def sat(n: int, year_len: int=651):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=651):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_651",
    "sat": "def sat(n: int, year_len: int=652):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=652):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_652",
    "sat": "def sat(n: int, year_len: int=653):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=653):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_653",
    "sat": "def sat(n: int, year_len: int=654):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=654):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_654",
    "sat": "def sat(n: int, year_len: int=655):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=655):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_655",
    "sat": "def sat(n: int, year_len: int=656):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=656):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_656",
    "sat": "def sat(n: int, year_len: int=657):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=657):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_657",
    "sat": "def sat(n: int, year_len: int=658):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=658):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_658",
    "sat": "def sat(n: int, year_len: int=659):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=659):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_659",
    "sat": "def sat(n: int, year_len: int=660):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=660):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_660",
    "sat": "def sat(n: int, year_len: int=661):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=661):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_661",
    "sat": "def sat(n: int, year_len: int=662):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=662):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_662",
    "sat": "def sat(n: int, year_len: int=663):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=663):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_663",
    "sat": "def sat(n: int, year_len: int=664):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=664):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_664",
    "sat": "def sat(n: int, year_len: int=665):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=665):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_665",
    "sat": "def sat(n: int, year_len: int=666):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=666):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_666",
    "sat": "def sat(n: int, year_len: int=667):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=667):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_667",
    "sat": "def sat(n: int, year_len: int=668):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=668):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_668",
    "sat": "def sat(n: int, year_len: int=669):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=669):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_669",
    "sat": "def sat(n: int, year_len: int=670):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=670):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_670",
    "sat": "def sat(n: int, year_len: int=671):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=671):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_671",
    "sat": "def sat(n: int, year_len: int=672):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=672):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_672",
    "sat": "def sat(n: int, year_len: int=673):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=673):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_673",
    "sat": "def sat(n: int, year_len: int=674):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=674):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_674",
    "sat": "def sat(n: int, year_len: int=675):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=675):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_675",
    "sat": "def sat(n: int, year_len: int=676):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=676):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_676",
    "sat": "def sat(n: int, year_len: int=677):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=677):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_677",
    "sat": "def sat(n: int, year_len: int=678):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=678):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_678",
    "sat": "def sat(n: int, year_len: int=679):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=679):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_679",
    "sat": "def sat(n: int, year_len: int=680):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=680):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_680",
    "sat": "def sat(n: int, year_len: int=681):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=681):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_681",
    "sat": "def sat(n: int, year_len: int=682):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=682):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_682",
    "sat": "def sat(n: int, year_len: int=683):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=683):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_683",
    "sat": "def sat(n: int, year_len: int=684):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=684):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_684",
    "sat": "def sat(n: int, year_len: int=685):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=685):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_685",
    "sat": "def sat(n: int, year_len: int=686):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=686):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_686",
    "sat": "def sat(n: int, year_len: int=687):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=687):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_687",
    "sat": "def sat(n: int, year_len: int=688):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=688):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_688",
    "sat": "def sat(n: int, year_len: int=689):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=689):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_689",
    "sat": "def sat(n: int, year_len: int=690):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=690):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_690",
    "sat": "def sat(n: int, year_len: int=691):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=691):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_691",
    "sat": "def sat(n: int, year_len: int=692):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=692):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_692",
    "sat": "def sat(n: int, year_len: int=693):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=693):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_693",
    "sat": "def sat(n: int, year_len: int=694):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=694):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_694",
    "sat": "def sat(n: int, year_len: int=695):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=695):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_695",
    "sat": "def sat(n: int, year_len: int=696):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=696):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_696",
    "sat": "def sat(n: int, year_len: int=697):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=697):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_697",
    "sat": "def sat(n: int, year_len: int=698):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=698):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_698",
    "sat": "def sat(n: int, year_len: int=699):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=699):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_699",
    "sat": "def sat(n: int, year_len: int=700):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=700):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_700",
    "sat": "def sat(n: int, year_len: int=701):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=701):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_701",
    "sat": "def sat(n: int, year_len: int=702):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=702):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_702",
    "sat": "def sat(n: int, year_len: int=703):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=703):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_703",
    "sat": "def sat(n: int, year_len: int=704):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=704):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_704",
    "sat": "def sat(n: int, year_len: int=705):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=705):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_705",
    "sat": "def sat(n: int, year_len: int=706):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=706):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_706",
    "sat": "def sat(n: int, year_len: int=707):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=707):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_707",
    "sat": "def sat(n: int, year_len: int=708):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=708):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_708",
    "sat": "def sat(n: int, year_len: int=709):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=709):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_709",
    "sat": "def sat(n: int, year_len: int=710):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=710):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_710",
    "sat": "def sat(n: int, year_len: int=711):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=711):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_711",
    "sat": "def sat(n: int, year_len: int=712):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=712):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_712",
    "sat": "def sat(n: int, year_len: int=713):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=713):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_713",
    "sat": "def sat(n: int, year_len: int=714):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=714):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_714",
    "sat": "def sat(n: int, year_len: int=715):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=715):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_715",
    "sat": "def sat(n: int, year_len: int=716):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=716):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_716",
    "sat": "def sat(n: int, year_len: int=717):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=717):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_717",
    "sat": "def sat(n: int, year_len: int=718):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=718):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_718",
    "sat": "def sat(n: int, year_len: int=719):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=719):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_719",
    "sat": "def sat(n: int, year_len: int=720):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=720):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_720",
    "sat": "def sat(n: int, year_len: int=721):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=721):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_721",
    "sat": "def sat(n: int, year_len: int=722):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=722):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_722",
    "sat": "def sat(n: int, year_len: int=723):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=723):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_723",
    "sat": "def sat(n: int, year_len: int=724):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=724):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_724",
    "sat": "def sat(n: int, year_len: int=725):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=725):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_725",
    "sat": "def sat(n: int, year_len: int=726):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=726):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_726",
    "sat": "def sat(n: int, year_len: int=727):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=727):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_727",
    "sat": "def sat(n: int, year_len: int=728):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=728):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_728",
    "sat": "def sat(n: int, year_len: int=729):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=729):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_729",
    "sat": "def sat(n: int, year_len: int=730):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=730):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_730",
    "sat": "def sat(n: int, year_len: int=731):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=731):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_731",
    "sat": "def sat(n: int, year_len: int=732):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=732):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_732",
    "sat": "def sat(n: int, year_len: int=733):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=733):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_733",
    "sat": "def sat(n: int, year_len: int=734):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=734):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_734",
    "sat": "def sat(n: int, year_len: int=735):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=735):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_735",
    "sat": "def sat(n: int, year_len: int=736):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=736):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_736",
    "sat": "def sat(n: int, year_len: int=737):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=737):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_737",
    "sat": "def sat(n: int, year_len: int=738):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=738):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_738",
    "sat": "def sat(n: int, year_len: int=739):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=739):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_739",
    "sat": "def sat(n: int, year_len: int=740):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=740):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_740",
    "sat": "def sat(n: int, year_len: int=741):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=741):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_741",
    "sat": "def sat(n: int, year_len: int=742):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=742):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_742",
    "sat": "def sat(n: int, year_len: int=743):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=743):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_743",
    "sat": "def sat(n: int, year_len: int=744):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=744):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_744",
    "sat": "def sat(n: int, year_len: int=745):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=745):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_745",
    "sat": "def sat(n: int, year_len: int=746):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=746):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_746",
    "sat": "def sat(n: int, year_len: int=747):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=747):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_747",
    "sat": "def sat(n: int, year_len: int=748):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=748):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_748",
    "sat": "def sat(n: int, year_len: int=749):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=749):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_749",
    "sat": "def sat(n: int, year_len: int=750):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=750):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_750",
    "sat": "def sat(n: int, year_len: int=751):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=751):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_751",
    "sat": "def sat(n: int, year_len: int=752):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=752):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_752",
    "sat": "def sat(n: int, year_len: int=753):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=753):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_753",
    "sat": "def sat(n: int, year_len: int=754):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=754):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_754",
    "sat": "def sat(n: int, year_len: int=755):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=755):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_755",
    "sat": "def sat(n: int, year_len: int=756):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=756):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_756",
    "sat": "def sat(n: int, year_len: int=757):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=757):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_757",
    "sat": "def sat(n: int, year_len: int=758):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=758):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_758",
    "sat": "def sat(n: int, year_len: int=759):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=759):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_759",
    "sat": "def sat(n: int, year_len: int=760):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=760):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_760",
    "sat": "def sat(n: int, year_len: int=761):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=761):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_761",
    "sat": "def sat(n: int, year_len: int=762):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=762):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_762",
    "sat": "def sat(n: int, year_len: int=763):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=763):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_763",
    "sat": "def sat(n: int, year_len: int=764):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=764):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_764",
    "sat": "def sat(n: int, year_len: int=765):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=765):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_765",
    "sat": "def sat(n: int, year_len: int=766):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=766):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_766",
    "sat": "def sat(n: int, year_len: int=767):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=767):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_767",
    "sat": "def sat(n: int, year_len: int=768):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=768):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_768",
    "sat": "def sat(n: int, year_len: int=769):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=769):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_769",
    "sat": "def sat(n: int, year_len: int=770):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=770):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_770",
    "sat": "def sat(n: int, year_len: int=771):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=771):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_771",
    "sat": "def sat(n: int, year_len: int=772):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=772):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_772",
    "sat": "def sat(n: int, year_len: int=773):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=773):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_773",
    "sat": "def sat(n: int, year_len: int=774):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=774):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_774",
    "sat": "def sat(n: int, year_len: int=775):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=775):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_775",
    "sat": "def sat(n: int, year_len: int=776):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=776):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_776",
    "sat": "def sat(n: int, year_len: int=777):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=777):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_777",
    "sat": "def sat(n: int, year_len: int=778):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=778):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_778",
    "sat": "def sat(n: int, year_len: int=779):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=779):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_779",
    "sat": "def sat(n: int, year_len: int=780):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=780):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_780",
    "sat": "def sat(n: int, year_len: int=781):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=781):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_781",
    "sat": "def sat(n: int, year_len: int=782):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=782):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_782",
    "sat": "def sat(n: int, year_len: int=783):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=783):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_783",
    "sat": "def sat(n: int, year_len: int=784):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=784):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_784",
    "sat": "def sat(n: int, year_len: int=785):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=785):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_785",
    "sat": "def sat(n: int, year_len: int=786):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=786):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_786",
    "sat": "def sat(n: int, year_len: int=787):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=787):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_787",
    "sat": "def sat(n: int, year_len: int=788):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=788):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_788",
    "sat": "def sat(n: int, year_len: int=789):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=789):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_789",
    "sat": "def sat(n: int, year_len: int=790):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=790):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_790",
    "sat": "def sat(n: int, year_len: int=791):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=791):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_791",
    "sat": "def sat(n: int, year_len: int=792):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=792):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_792",
    "sat": "def sat(n: int, year_len: int=793):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=793):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_793",
    "sat": "def sat(n: int, year_len: int=794):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=794):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_794",
    "sat": "def sat(n: int, year_len: int=795):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=795):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_795",
    "sat": "def sat(n: int, year_len: int=796):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=796):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_796",
    "sat": "def sat(n: int, year_len: int=797):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=797):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_797",
    "sat": "def sat(n: int, year_len: int=798):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=798):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_798",
    "sat": "def sat(n: int, year_len: int=799):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=799):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_799",
    "sat": "def sat(n: int, year_len: int=800):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=800):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_800",
    "sat": "def sat(n: int, year_len: int=801):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=801):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_801",
    "sat": "def sat(n: int, year_len: int=802):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=802):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_802",
    "sat": "def sat(n: int, year_len: int=803):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=803):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_803",
    "sat": "def sat(n: int, year_len: int=804):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=804):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_804",
    "sat": "def sat(n: int, year_len: int=805):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=805):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_805",
    "sat": "def sat(n: int, year_len: int=806):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=806):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_806",
    "sat": "def sat(n: int, year_len: int=807):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=807):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_807",
    "sat": "def sat(n: int, year_len: int=808):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=808):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_808",
    "sat": "def sat(n: int, year_len: int=809):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=809):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_809",
    "sat": "def sat(n: int, year_len: int=810):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=810):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_810",
    "sat": "def sat(n: int, year_len: int=811):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=811):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_811",
    "sat": "def sat(n: int, year_len: int=812):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=812):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_812",
    "sat": "def sat(n: int, year_len: int=813):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=813):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_813",
    "sat": "def sat(n: int, year_len: int=814):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=814):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_814",
    "sat": "def sat(n: int, year_len: int=815):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=815):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_815",
    "sat": "def sat(n: int, year_len: int=816):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=816):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_816",
    "sat": "def sat(n: int, year_len: int=817):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=817):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_817",
    "sat": "def sat(n: int, year_len: int=818):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=818):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_818",
    "sat": "def sat(n: int, year_len: int=819):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=819):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_819",
    "sat": "def sat(n: int, year_len: int=820):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=820):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_820",
    "sat": "def sat(n: int, year_len: int=821):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=821):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_821",
    "sat": "def sat(n: int, year_len: int=822):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=822):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_822",
    "sat": "def sat(n: int, year_len: int=823):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=823):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_823",
    "sat": "def sat(n: int, year_len: int=824):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=824):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_824",
    "sat": "def sat(n: int, year_len: int=825):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=825):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_825",
    "sat": "def sat(n: int, year_len: int=826):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=826):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_826",
    "sat": "def sat(n: int, year_len: int=827):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=827):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_827",
    "sat": "def sat(n: int, year_len: int=828):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=828):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_828",
    "sat": "def sat(n: int, year_len: int=829):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=829):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_829",
    "sat": "def sat(n: int, year_len: int=830):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=830):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_830",
    "sat": "def sat(n: int, year_len: int=831):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=831):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_831",
    "sat": "def sat(n: int, year_len: int=832):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=832):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_832",
    "sat": "def sat(n: int, year_len: int=833):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=833):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_833",
    "sat": "def sat(n: int, year_len: int=834):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=834):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_834",
    "sat": "def sat(n: int, year_len: int=835):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=835):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_835",
    "sat": "def sat(n: int, year_len: int=836):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=836):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_836",
    "sat": "def sat(n: int, year_len: int=837):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=837):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_837",
    "sat": "def sat(n: int, year_len: int=838):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=838):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_838",
    "sat": "def sat(n: int, year_len: int=839):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=839):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_839",
    "sat": "def sat(n: int, year_len: int=840):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=840):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_840",
    "sat": "def sat(n: int, year_len: int=841):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=841):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_841",
    "sat": "def sat(n: int, year_len: int=842):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=842):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_842",
    "sat": "def sat(n: int, year_len: int=843):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=843):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_843",
    "sat": "def sat(n: int, year_len: int=844):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=844):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_844",
    "sat": "def sat(n: int, year_len: int=845):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=845):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_845",
    "sat": "def sat(n: int, year_len: int=846):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=846):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_846",
    "sat": "def sat(n: int, year_len: int=847):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=847):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_847",
    "sat": "def sat(n: int, year_len: int=848):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=848):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_848",
    "sat": "def sat(n: int, year_len: int=849):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=849):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_849",
    "sat": "def sat(n: int, year_len: int=850):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=850):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_850",
    "sat": "def sat(n: int, year_len: int=851):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=851):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_851",
    "sat": "def sat(n: int, year_len: int=852):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=852):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_852",
    "sat": "def sat(n: int, year_len: int=853):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=853):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_853",
    "sat": "def sat(n: int, year_len: int=854):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=854):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_854",
    "sat": "def sat(n: int, year_len: int=855):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=855):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_855",
    "sat": "def sat(n: int, year_len: int=856):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=856):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_856",
    "sat": "def sat(n: int, year_len: int=857):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=857):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_857",
    "sat": "def sat(n: int, year_len: int=858):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=858):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_858",
    "sat": "def sat(n: int, year_len: int=859):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=859):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_859",
    "sat": "def sat(n: int, year_len: int=860):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=860):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_860",
    "sat": "def sat(n: int, year_len: int=861):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=861):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_861",
    "sat": "def sat(n: int, year_len: int=862):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=862):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_862",
    "sat": "def sat(n: int, year_len: int=863):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=863):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_863",
    "sat": "def sat(n: int, year_len: int=864):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=864):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_864",
    "sat": "def sat(n: int, year_len: int=865):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=865):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_865",
    "sat": "def sat(n: int, year_len: int=866):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=866):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_866",
    "sat": "def sat(n: int, year_len: int=867):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=867):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_867",
    "sat": "def sat(n: int, year_len: int=868):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=868):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_868",
    "sat": "def sat(n: int, year_len: int=869):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=869):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_869",
    "sat": "def sat(n: int, year_len: int=870):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=870):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_870",
    "sat": "def sat(n: int, year_len: int=871):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=871):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_871",
    "sat": "def sat(n: int, year_len: int=872):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=872):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_872",
    "sat": "def sat(n: int, year_len: int=873):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=873):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_873",
    "sat": "def sat(n: int, year_len: int=874):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=874):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_874",
    "sat": "def sat(n: int, year_len: int=875):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=875):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_875",
    "sat": "def sat(n: int, year_len: int=876):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=876):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_876",
    "sat": "def sat(n: int, year_len: int=877):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=877):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_877",
    "sat": "def sat(n: int, year_len: int=878):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=878):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_878",
    "sat": "def sat(n: int, year_len: int=879):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=879):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_879",
    "sat": "def sat(n: int, year_len: int=880):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=880):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_880",
    "sat": "def sat(n: int, year_len: int=881):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=881):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_881",
    "sat": "def sat(n: int, year_len: int=882):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=882):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_882",
    "sat": "def sat(n: int, year_len: int=883):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=883):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_883",
    "sat": "def sat(n: int, year_len: int=884):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=884):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_884",
    "sat": "def sat(n: int, year_len: int=885):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=885):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_885",
    "sat": "def sat(n: int, year_len: int=886):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=886):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_886",
    "sat": "def sat(n: int, year_len: int=887):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=887):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_887",
    "sat": "def sat(n: int, year_len: int=888):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=888):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_888",
    "sat": "def sat(n: int, year_len: int=889):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=889):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_889",
    "sat": "def sat(n: int, year_len: int=890):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=890):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_890",
    "sat": "def sat(n: int, year_len: int=891):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=891):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_891",
    "sat": "def sat(n: int, year_len: int=892):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=892):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_892",
    "sat": "def sat(n: int, year_len: int=893):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=893):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_893",
    "sat": "def sat(n: int, year_len: int=894):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=894):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_894",
    "sat": "def sat(n: int, year_len: int=895):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=895):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_895",
    "sat": "def sat(n: int, year_len: int=896):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=896):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_896",
    "sat": "def sat(n: int, year_len: int=897):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=897):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_897",
    "sat": "def sat(n: int, year_len: int=898):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=898):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_898",
    "sat": "def sat(n: int, year_len: int=899):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=899):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_899",
    "sat": "def sat(n: int, year_len: int=900):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=900):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_900",
    "sat": "def sat(n: int, year_len: int=901):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=901):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_901",
    "sat": "def sat(n: int, year_len: int=902):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=902):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_902",
    "sat": "def sat(n: int, year_len: int=903):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=903):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_903",
    "sat": "def sat(n: int, year_len: int=904):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=904):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_904",
    "sat": "def sat(n: int, year_len: int=905):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=905):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_905",
    "sat": "def sat(n: int, year_len: int=906):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=906):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_906",
    "sat": "def sat(n: int, year_len: int=907):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=907):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_907",
    "sat": "def sat(n: int, year_len: int=908):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=908):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_908",
    "sat": "def sat(n: int, year_len: int=909):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=909):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_909",
    "sat": "def sat(n: int, year_len: int=910):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=910):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_910",
    "sat": "def sat(n: int, year_len: int=911):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=911):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_911",
    "sat": "def sat(n: int, year_len: int=912):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=912):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_912",
    "sat": "def sat(n: int, year_len: int=913):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=913):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_913",
    "sat": "def sat(n: int, year_len: int=914):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=914):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_914",
    "sat": "def sat(n: int, year_len: int=915):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=915):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_915",
    "sat": "def sat(n: int, year_len: int=916):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=916):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_916",
    "sat": "def sat(n: int, year_len: int=917):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=917):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_917",
    "sat": "def sat(n: int, year_len: int=918):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=918):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_918",
    "sat": "def sat(n: int, year_len: int=919):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=919):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_919",
    "sat": "def sat(n: int, year_len: int=920):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=920):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_920",
    "sat": "def sat(n: int, year_len: int=921):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=921):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_921",
    "sat": "def sat(n: int, year_len: int=922):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=922):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_922",
    "sat": "def sat(n: int, year_len: int=923):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=923):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_923",
    "sat": "def sat(n: int, year_len: int=924):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=924):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_924",
    "sat": "def sat(n: int, year_len: int=925):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=925):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_925",
    "sat": "def sat(n: int, year_len: int=926):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=926):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_926",
    "sat": "def sat(n: int, year_len: int=927):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=927):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_927",
    "sat": "def sat(n: int, year_len: int=928):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=928):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_928",
    "sat": "def sat(n: int, year_len: int=929):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=929):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_929",
    "sat": "def sat(n: int, year_len: int=930):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=930):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_930",
    "sat": "def sat(n: int, year_len: int=931):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=931):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_931",
    "sat": "def sat(n: int, year_len: int=932):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=932):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_932",
    "sat": "def sat(n: int, year_len: int=933):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=933):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_933",
    "sat": "def sat(n: int, year_len: int=934):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=934):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_934",
    "sat": "def sat(n: int, year_len: int=935):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=935):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_935",
    "sat": "def sat(n: int, year_len: int=936):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=936):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_936",
    "sat": "def sat(n: int, year_len: int=937):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=937):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_937",
    "sat": "def sat(n: int, year_len: int=938):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=938):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_938",
    "sat": "def sat(n: int, year_len: int=939):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=939):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_939",
    "sat": "def sat(n: int, year_len: int=940):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=940):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_940",
    "sat": "def sat(n: int, year_len: int=941):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=941):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_941",
    "sat": "def sat(n: int, year_len: int=942):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=942):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_942",
    "sat": "def sat(n: int, year_len: int=943):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=943):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_943",
    "sat": "def sat(n: int, year_len: int=944):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=944):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_944",
    "sat": "def sat(n: int, year_len: int=945):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=945):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_945",
    "sat": "def sat(n: int, year_len: int=946):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=946):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_946",
    "sat": "def sat(n: int, year_len: int=947):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=947):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_947",
    "sat": "def sat(n: int, year_len: int=948):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=948):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_948",
    "sat": "def sat(n: int, year_len: int=949):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=949):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_949",
    "sat": "def sat(n: int, year_len: int=950):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=950):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_950",
    "sat": "def sat(n: int, year_len: int=951):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=951):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_951",
    "sat": "def sat(n: int, year_len: int=952):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=952):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_952",
    "sat": "def sat(n: int, year_len: int=953):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=953):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_953",
    "sat": "def sat(n: int, year_len: int=954):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=954):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_954",
    "sat": "def sat(n: int, year_len: int=955):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=955):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_955",
    "sat": "def sat(n: int, year_len: int=956):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=956):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_956",
    "sat": "def sat(n: int, year_len: int=957):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=957):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_957",
    "sat": "def sat(n: int, year_len: int=958):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=958):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_958",
    "sat": "def sat(n: int, year_len: int=959):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=959):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_959",
    "sat": "def sat(n: int, year_len: int=960):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=960):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_960",
    "sat": "def sat(n: int, year_len: int=961):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=961):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_961",
    "sat": "def sat(n: int, year_len: int=962):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=962):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_962",
    "sat": "def sat(n: int, year_len: int=963):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=963):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_963",
    "sat": "def sat(n: int, year_len: int=964):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=964):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_964",
    "sat": "def sat(n: int, year_len: int=965):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=965):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_965",
    "sat": "def sat(n: int, year_len: int=966):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=966):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_966",
    "sat": "def sat(n: int, year_len: int=967):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=967):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_967",
    "sat": "def sat(n: int, year_len: int=968):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=968):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_968",
    "sat": "def sat(n: int, year_len: int=969):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=969):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_969",
    "sat": "def sat(n: int, year_len: int=970):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=970):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_970",
    "sat": "def sat(n: int, year_len: int=971):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=971):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_971",
    "sat": "def sat(n: int, year_len: int=972):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=972):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_972",
    "sat": "def sat(n: int, year_len: int=973):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=973):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_973",
    "sat": "def sat(n: int, year_len: int=974):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=974):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_974",
    "sat": "def sat(n: int, year_len: int=975):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=975):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_975",
    "sat": "def sat(n: int, year_len: int=976):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=976):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_976",
    "sat": "def sat(n: int, year_len: int=977):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=977):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_977",
    "sat": "def sat(n: int, year_len: int=978):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=978):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_978",
    "sat": "def sat(n: int, year_len: int=979):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=979):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_979",
    "sat": "def sat(n: int, year_len: int=980):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=980):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_980",
    "sat": "def sat(n: int, year_len: int=981):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=981):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_981",
    "sat": "def sat(n: int, year_len: int=982):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=982):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_982",
    "sat": "def sat(n: int, year_len: int=983):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=983):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_983",
    "sat": "def sat(n: int, year_len: int=984):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=984):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_984",
    "sat": "def sat(n: int, year_len: int=985):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=985):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_985",
    "sat": "def sat(n: int, year_len: int=986):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=986):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_986",
    "sat": "def sat(n: int, year_len: int=987):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=987):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_987",
    "sat": "def sat(n: int, year_len: int=988):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=988):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_988",
    "sat": "def sat(n: int, year_len: int=989):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=989):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_989",
    "sat": "def sat(n: int, year_len: int=990):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=990):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_990",
    "sat": "def sat(n: int, year_len: int=991):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=991):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_991",
    "sat": "def sat(n: int, year_len: int=992):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=992):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_992",
    "sat": "def sat(n: int, year_len: int=993):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=993):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_993",
    "sat": "def sat(n: int, year_len: int=994):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=994):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_994",
    "sat": "def sat(n: int, year_len: int=995):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=995):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_995",
    "sat": "def sat(n: int, year_len: int=996):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=996):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_996",
    "sat": "def sat(n: int, year_len: int=997):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=997):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_997",
    "sat": "def sat(n: int, year_len: int=998):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=998):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_998",
    "sat": "def sat(n: int, year_len: int=999):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=999):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BirthdayParadoxMonteCarlo_999",
    "sat": "def sat(n: int, year_len: int=1000):\n    assert type(n) is int, 'n must be of type int'\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "sols": [
      "def sol(year_len=1000):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ]
  },
  {
    "name": "BallotProblem_0",
    "sat": "def sat(counts: List[int], target_prob: float=0.5):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_1",
    "sat": "def sat(counts: List[int], target_prob: float=0.2):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_2",
    "sat": "def sat(counts: List[int], target_prob: float=0.0):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_3",
    "sat": "def sat(counts: List[int], target_prob: float=0.4731182795698925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4731182795698925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_4",
    "sat": "def sat(counts: List[int], target_prob: float=0.7370030581039755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7370030581039755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_5",
    "sat": "def sat(counts: List[int], target_prob: float=0.4):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_6",
    "sat": "def sat(counts: List[int], target_prob: float=0.7702702702702703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7702702702702703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_7",
    "sat": "def sat(counts: List[int], target_prob: float=0.13953488372093023):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13953488372093023):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_8",
    "sat": "def sat(counts: List[int], target_prob: float=0.30275229357798167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30275229357798167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_9",
    "sat": "def sat(counts: List[int], target_prob: float=0.5136612021857924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5136612021857924):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_10",
    "sat": "def sat(counts: List[int], target_prob: float=0.34210526315789475):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34210526315789475):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_11",
    "sat": "def sat(counts: List[int], target_prob: float=0.323943661971831):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.323943661971831):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_12",
    "sat": "def sat(counts: List[int], target_prob: float=0.20048309178743962):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20048309178743962):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_13",
    "sat": "def sat(counts: List[int], target_prob: float=0.9726027397260274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9726027397260274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_14",
    "sat": "def sat(counts: List[int], target_prob: float=0.5555555555555556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5555555555555556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_15",
    "sat": "def sat(counts: List[int], target_prob: float=0.039603960396039604):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.039603960396039604):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_16",
    "sat": "def sat(counts: List[int], target_prob: float=0.875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_17",
    "sat": "def sat(counts: List[int], target_prob: float=0.23707664884135474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23707664884135474):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_18",
    "sat": "def sat(counts: List[int], target_prob: float=0.09293680297397769):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09293680297397769):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_19",
    "sat": "def sat(counts: List[int], target_prob: float=0.8):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_20",
    "sat": "def sat(counts: List[int], target_prob: float=0.07832009080590238):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07832009080590238):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_21",
    "sat": "def sat(counts: List[int], target_prob: float=0.116751269035533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.116751269035533):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_22",
    "sat": "def sat(counts: List[int], target_prob: float=0.17575757575757575):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17575757575757575):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_23",
    "sat": "def sat(counts: List[int], target_prob: float=0.07027027027027027):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07027027027027027):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_24",
    "sat": "def sat(counts: List[int], target_prob: float=0.21153846153846154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21153846153846154):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_25",
    "sat": "def sat(counts: List[int], target_prob: float=0.8757062146892656):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8757062146892656):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_26",
    "sat": "def sat(counts: List[int], target_prob: float=0.2562814070351759):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2562814070351759):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_27",
    "sat": "def sat(counts: List[int], target_prob: float=0.15):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_28",
    "sat": "def sat(counts: List[int], target_prob: float=0.043478260869565216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.043478260869565216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_29",
    "sat": "def sat(counts: List[int], target_prob: float=0.3276595744680851):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3276595744680851):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_30",
    "sat": "def sat(counts: List[int], target_prob: float=0.10469314079422383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10469314079422383):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_31",
    "sat": "def sat(counts: List[int], target_prob: float=0.2235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_32",
    "sat": "def sat(counts: List[int], target_prob: float=0.0510783200908059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0510783200908059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_33",
    "sat": "def sat(counts: List[int], target_prob: float=0.3162393162393162):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3162393162393162):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_34",
    "sat": "def sat(counts: List[int], target_prob: float=0.8823529411764706):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8823529411764706):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_35",
    "sat": "def sat(counts: List[int], target_prob: float=0.22362869198312235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22362869198312235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_36",
    "sat": "def sat(counts: List[int], target_prob: float=0.3673469387755102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3673469387755102):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_37",
    "sat": "def sat(counts: List[int], target_prob: float=0.36585365853658536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36585365853658536):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_38",
    "sat": "def sat(counts: List[int], target_prob: float=0.9138755980861244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9138755980861244):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_39",
    "sat": "def sat(counts: List[int], target_prob: float=0.21621621621621623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21621621621621623):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_40",
    "sat": "def sat(counts: List[int], target_prob: float=0.2896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2896):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_41",
    "sat": "def sat(counts: List[int], target_prob: float=0.5333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_42",
    "sat": "def sat(counts: List[int], target_prob: float=0.015915119363395226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.015915119363395226):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_43",
    "sat": "def sat(counts: List[int], target_prob: float=0.14285714285714285):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14285714285714285):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_44",
    "sat": "def sat(counts: List[int], target_prob: float=0.16271186440677965):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16271186440677965):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_45",
    "sat": "def sat(counts: List[int], target_prob: float=0.5323383084577115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5323383084577115):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_46",
    "sat": "def sat(counts: List[int], target_prob: float=0.23381294964028776):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23381294964028776):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_47",
    "sat": "def sat(counts: List[int], target_prob: float=0.4918032786885246):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4918032786885246):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_48",
    "sat": "def sat(counts: List[int], target_prob: float=0.7180952380952381):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7180952380952381):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_49",
    "sat": "def sat(counts: List[int], target_prob: float=0.014492753623188406):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.014492753623188406):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_50",
    "sat": "def sat(counts: List[int], target_prob: float=0.8285714285714286):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8285714285714286):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_51",
    "sat": "def sat(counts: List[int], target_prob: float=0.3333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_52",
    "sat": "def sat(counts: List[int], target_prob: float=0.45454545454545453):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45454545454545453):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_53",
    "sat": "def sat(counts: List[int], target_prob: float=0.6363636363636364):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6363636363636364):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_54",
    "sat": "def sat(counts: List[int], target_prob: float=0.6):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_55",
    "sat": "def sat(counts: List[int], target_prob: float=0.18333333333333332):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18333333333333332):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_56",
    "sat": "def sat(counts: List[int], target_prob: float=0.6226415094339622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6226415094339622):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_57",
    "sat": "def sat(counts: List[int], target_prob: float=0.7142857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_58",
    "sat": "def sat(counts: List[int], target_prob: float=0.07936507936507936):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07936507936507936):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_59",
    "sat": "def sat(counts: List[int], target_prob: float=0.23958333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23958333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_60",
    "sat": "def sat(counts: List[int], target_prob: float=0.3464566929133858):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3464566929133858):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_61",
    "sat": "def sat(counts: List[int], target_prob: float=0.48717948717948717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48717948717948717):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_62",
    "sat": "def sat(counts: List[int], target_prob: float=0.2696629213483146):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2696629213483146):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_63",
    "sat": "def sat(counts: List[int], target_prob: float=0.7261410788381742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7261410788381742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_64",
    "sat": "def sat(counts: List[int], target_prob: float=0.4676258992805755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4676258992805755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_65",
    "sat": "def sat(counts: List[int], target_prob: float=0.058823529411764705):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.058823529411764705):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_66",
    "sat": "def sat(counts: List[int], target_prob: float=0.1353135313531353):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1353135313531353):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_67",
    "sat": "def sat(counts: List[int], target_prob: float=0.366120218579235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.366120218579235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_68",
    "sat": "def sat(counts: List[int], target_prob: float=0.3469387755102041):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3469387755102041):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_69",
    "sat": "def sat(counts: List[int], target_prob: float=0.5384615384615384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5384615384615384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_70",
    "sat": "def sat(counts: List[int], target_prob: float=0.48148148148148145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48148148148148145):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_71",
    "sat": "def sat(counts: List[int], target_prob: float=0.28205128205128205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28205128205128205):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_72",
    "sat": "def sat(counts: List[int], target_prob: float=0.45263157894736844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45263157894736844):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_73",
    "sat": "def sat(counts: List[int], target_prob: float=0.44649446494464945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44649446494464945):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_74",
    "sat": "def sat(counts: List[int], target_prob: float=0.43952802359882004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43952802359882004):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_75",
    "sat": "def sat(counts: List[int], target_prob: float=0.384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_76",
    "sat": "def sat(counts: List[int], target_prob: float=0.15151515151515152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15151515151515152):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_77",
    "sat": "def sat(counts: List[int], target_prob: float=0.27413127413127414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27413127413127414):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_78",
    "sat": "def sat(counts: List[int], target_prob: float=0.4788732394366197):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4788732394366197):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_79",
    "sat": "def sat(counts: List[int], target_prob: float=0.2894736842105263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2894736842105263):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_80",
    "sat": "def sat(counts: List[int], target_prob: float=0.017341040462427744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.017341040462427744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_81",
    "sat": "def sat(counts: List[int], target_prob: float=0.10787172011661808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10787172011661808):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_82",
    "sat": "def sat(counts: List[int], target_prob: float=0.19126637554585152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19126637554585152):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_83",
    "sat": "def sat(counts: List[int], target_prob: float=0.29357798165137616):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29357798165137616):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_84",
    "sat": "def sat(counts: List[int], target_prob: float=0.32212885154061627):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32212885154061627):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_85",
    "sat": "def sat(counts: List[int], target_prob: float=0.36510376633358954):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36510376633358954):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_86",
    "sat": "def sat(counts: List[int], target_prob: float=0.6344086021505376):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6344086021505376):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_87",
    "sat": "def sat(counts: List[int], target_prob: float=0.28870292887029286):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28870292887029286):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_88",
    "sat": "def sat(counts: List[int], target_prob: float=0.9439775910364145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9439775910364145):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_89",
    "sat": "def sat(counts: List[int], target_prob: float=0.2537313432835821):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2537313432835821):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_90",
    "sat": "def sat(counts: List[int], target_prob: float=0.7049180327868853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7049180327868853):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_91",
    "sat": "def sat(counts: List[int], target_prob: float=0.2808988764044944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2808988764044944):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_92",
    "sat": "def sat(counts: List[int], target_prob: float=0.813953488372093):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.813953488372093):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_93",
    "sat": "def sat(counts: List[int], target_prob: float=0.09714285714285714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09714285714285714):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_94",
    "sat": "def sat(counts: List[int], target_prob: float=0.5876288659793815):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5876288659793815):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_95",
    "sat": "def sat(counts: List[int], target_prob: float=0.42857142857142855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42857142857142855):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_96",
    "sat": "def sat(counts: List[int], target_prob: float=0.6153846153846154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6153846153846154):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_97",
    "sat": "def sat(counts: List[int], target_prob: float=0.5291666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5291666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_98",
    "sat": "def sat(counts: List[int], target_prob: float=0.6536082474226804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6536082474226804):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_99",
    "sat": "def sat(counts: List[int], target_prob: float=0.037037037037037035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.037037037037037035):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_100",
    "sat": "def sat(counts: List[int], target_prob: float=0.4411764705882353):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4411764705882353):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_101",
    "sat": "def sat(counts: List[int], target_prob: float=0.4166666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4166666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_102",
    "sat": "def sat(counts: List[int], target_prob: float=0.7326086956521739):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7326086956521739):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_103",
    "sat": "def sat(counts: List[int], target_prob: float=0.5824175824175825):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5824175824175825):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_104",
    "sat": "def sat(counts: List[int], target_prob: float=0.21703296703296704):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21703296703296704):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_105",
    "sat": "def sat(counts: List[int], target_prob: float=0.3493150684931507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3493150684931507):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_106",
    "sat": "def sat(counts: List[int], target_prob: float=0.2293144208037825):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2293144208037825):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_107",
    "sat": "def sat(counts: List[int], target_prob: float=0.12043795620437957):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12043795620437957):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_108",
    "sat": "def sat(counts: List[int], target_prob: float=0.31386861313868614):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31386861313868614):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_109",
    "sat": "def sat(counts: List[int], target_prob: float=0.5757575757575758):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5757575757575758):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_110",
    "sat": "def sat(counts: List[int], target_prob: float=0.2283464566929134):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2283464566929134):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_111",
    "sat": "def sat(counts: List[int], target_prob: float=0.3825503355704698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3825503355704698):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_112",
    "sat": "def sat(counts: List[int], target_prob: float=0.46788990825688076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46788990825688076):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_113",
    "sat": "def sat(counts: List[int], target_prob: float=0.9859649122807017):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9859649122807017):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_114",
    "sat": "def sat(counts: List[int], target_prob: float=0.4312796208530806):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4312796208530806):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_115",
    "sat": "def sat(counts: List[int], target_prob: float=0.4744525547445255):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4744525547445255):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_116",
    "sat": "def sat(counts: List[int], target_prob: float=0.8923076923076924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8923076923076924):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_117",
    "sat": "def sat(counts: List[int], target_prob: float=0.7697841726618705):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7697841726618705):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_118",
    "sat": "def sat(counts: List[int], target_prob: float=0.4576271186440678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4576271186440678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_119",
    "sat": "def sat(counts: List[int], target_prob: float=0.08665749656121045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08665749656121045):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_120",
    "sat": "def sat(counts: List[int], target_prob: float=0.75):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.75):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_121",
    "sat": "def sat(counts: List[int], target_prob: float=0.022222222222222223):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.022222222222222223):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_122",
    "sat": "def sat(counts: List[int], target_prob: float=0.040238450074515646):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.040238450074515646):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_123",
    "sat": "def sat(counts: List[int], target_prob: float=0.06666666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06666666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_124",
    "sat": "def sat(counts: List[int], target_prob: float=0.04956268221574344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04956268221574344):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_125",
    "sat": "def sat(counts: List[int], target_prob: float=0.3094170403587444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3094170403587444):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_126",
    "sat": "def sat(counts: List[int], target_prob: float=0.5409836065573771):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5409836065573771):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_127",
    "sat": "def sat(counts: List[int], target_prob: float=0.048):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.048):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_128",
    "sat": "def sat(counts: List[int], target_prob: float=0.13978494623655913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13978494623655913):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_129",
    "sat": "def sat(counts: List[int], target_prob: float=0.11411411411411411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11411411411411411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_130",
    "sat": "def sat(counts: List[int], target_prob: float=0.7777777777777778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7777777777777778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_131",
    "sat": "def sat(counts: List[int], target_prob: float=0.7799043062200957):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7799043062200957):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_132",
    "sat": "def sat(counts: List[int], target_prob: float=0.7021276595744681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7021276595744681):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_133",
    "sat": "def sat(counts: List[int], target_prob: float=0.23076923076923078):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23076923076923078):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_134",
    "sat": "def sat(counts: List[int], target_prob: float=0.393526405451448):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.393526405451448):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_135",
    "sat": "def sat(counts: List[int], target_prob: float=0.28227571115973743):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28227571115973743):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_136",
    "sat": "def sat(counts: List[int], target_prob: float=0.4583333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4583333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_137",
    "sat": "def sat(counts: List[int], target_prob: float=0.008403361344537815):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.008403361344537815):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_138",
    "sat": "def sat(counts: List[int], target_prob: float=0.6666666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6666666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_139",
    "sat": "def sat(counts: List[int], target_prob: float=0.004347826086956522):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.004347826086956522):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_140",
    "sat": "def sat(counts: List[int], target_prob: float=0.05228758169934641):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05228758169934641):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_141",
    "sat": "def sat(counts: List[int], target_prob: float=0.659963436928702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.659963436928702):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_142",
    "sat": "def sat(counts: List[int], target_prob: float=0.10476190476190476):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10476190476190476):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_143",
    "sat": "def sat(counts: List[int], target_prob: float=0.03261734287987271):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03261734287987271):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_144",
    "sat": "def sat(counts: List[int], target_prob: float=0.20465434633812457):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20465434633812457):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_145",
    "sat": "def sat(counts: List[int], target_prob: float=0.35251798561151076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35251798561151076):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_146",
    "sat": "def sat(counts: List[int], target_prob: float=0.06382978723404255):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06382978723404255):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_147",
    "sat": "def sat(counts: List[int], target_prob: float=0.8037037037037037):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8037037037037037):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_148",
    "sat": "def sat(counts: List[int], target_prob: float=0.13725490196078433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13725490196078433):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_149",
    "sat": "def sat(counts: List[int], target_prob: float=0.9541108986615678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9541108986615678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_150",
    "sat": "def sat(counts: List[int], target_prob: float=0.2682926829268293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2682926829268293):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_151",
    "sat": "def sat(counts: List[int], target_prob: float=0.2383177570093458):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2383177570093458):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_152",
    "sat": "def sat(counts: List[int], target_prob: float=0.11499540018399264):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11499540018399264):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_153",
    "sat": "def sat(counts: List[int], target_prob: float=0.43424317617866004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43424317617866004):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_154",
    "sat": "def sat(counts: List[int], target_prob: float=0.2210144927536232):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2210144927536232):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_155",
    "sat": "def sat(counts: List[int], target_prob: float=0.8808864265927978):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8808864265927978):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_156",
    "sat": "def sat(counts: List[int], target_prob: float=0.22679580306698952):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22679580306698952):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_157",
    "sat": "def sat(counts: List[int], target_prob: float=0.31976744186046513):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31976744186046513):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_158",
    "sat": "def sat(counts: List[int], target_prob: float=0.34037367993501216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34037367993501216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_159",
    "sat": "def sat(counts: List[int], target_prob: float=0.7547169811320755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7547169811320755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_160",
    "sat": "def sat(counts: List[int], target_prob: float=0.01639344262295082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01639344262295082):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_161",
    "sat": "def sat(counts: List[int], target_prob: float=0.12190650779101742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12190650779101742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_162",
    "sat": "def sat(counts: List[int], target_prob: float=0.772189349112426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.772189349112426):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_163",
    "sat": "def sat(counts: List[int], target_prob: float=0.40384615384615385):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40384615384615385):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_164",
    "sat": "def sat(counts: List[int], target_prob: float=0.20588235294117646):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20588235294117646):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_165",
    "sat": "def sat(counts: List[int], target_prob: float=0.3904761904761905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3904761904761905):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_166",
    "sat": "def sat(counts: List[int], target_prob: float=0.1625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_167",
    "sat": "def sat(counts: List[int], target_prob: float=0.41839762611275966):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41839762611275966):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_168",
    "sat": "def sat(counts: List[int], target_prob: float=0.22033898305084745):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22033898305084745):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_169",
    "sat": "def sat(counts: List[int], target_prob: float=0.10813823857302118):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10813823857302118):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_170",
    "sat": "def sat(counts: List[int], target_prob: float=0.20175438596491227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20175438596491227):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_171",
    "sat": "def sat(counts: List[int], target_prob: float=0.25059665871121717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25059665871121717):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_172",
    "sat": "def sat(counts: List[int], target_prob: float=0.4185022026431718):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4185022026431718):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_173",
    "sat": "def sat(counts: List[int], target_prob: float=0.14935064935064934):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14935064935064934):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_174",
    "sat": "def sat(counts: List[int], target_prob: float=0.15789473684210525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15789473684210525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_175",
    "sat": "def sat(counts: List[int], target_prob: float=0.43636363636363634):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43636363636363634):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_176",
    "sat": "def sat(counts: List[int], target_prob: float=0.01675977653631285):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01675977653631285):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_177",
    "sat": "def sat(counts: List[int], target_prob: float=0.25539568345323743):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25539568345323743):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_178",
    "sat": "def sat(counts: List[int], target_prob: float=0.7280701754385965):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7280701754385965):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_179",
    "sat": "def sat(counts: List[int], target_prob: float=0.2231404958677686):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2231404958677686):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_180",
    "sat": "def sat(counts: List[int], target_prob: float=0.6702127659574468):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6702127659574468):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_181",
    "sat": "def sat(counts: List[int], target_prob: float=0.36507936507936506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36507936507936506):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_182",
    "sat": "def sat(counts: List[int], target_prob: float=0.8053097345132744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8053097345132744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_183",
    "sat": "def sat(counts: List[int], target_prob: float=0.1659625829812915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1659625829812915):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_184",
    "sat": "def sat(counts: List[int], target_prob: float=0.24770642201834864):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24770642201834864):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_185",
    "sat": "def sat(counts: List[int], target_prob: float=0.23529411764705882):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23529411764705882):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_186",
    "sat": "def sat(counts: List[int], target_prob: float=0.7878787878787878):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7878787878787878):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_187",
    "sat": "def sat(counts: List[int], target_prob: float=0.16521739130434782):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16521739130434782):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_188",
    "sat": "def sat(counts: List[int], target_prob: float=0.5789473684210527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5789473684210527):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_189",
    "sat": "def sat(counts: List[int], target_prob: float=0.6869565217391305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6869565217391305):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_190",
    "sat": "def sat(counts: List[int], target_prob: float=0.008902077151335312):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.008902077151335312):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_191",
    "sat": "def sat(counts: List[int], target_prob: float=0.5402298850574713):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5402298850574713):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_192",
    "sat": "def sat(counts: List[int], target_prob: float=0.2669683257918552):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2669683257918552):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_193",
    "sat": "def sat(counts: List[int], target_prob: float=0.2459016393442623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2459016393442623):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_194",
    "sat": "def sat(counts: List[int], target_prob: float=0.0446927374301676):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0446927374301676):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_195",
    "sat": "def sat(counts: List[int], target_prob: float=0.25835866261398177):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25835866261398177):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_196",
    "sat": "def sat(counts: List[int], target_prob: float=0.7377777777777778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7377777777777778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_197",
    "sat": "def sat(counts: List[int], target_prob: float=0.5329341317365269):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5329341317365269):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_198",
    "sat": "def sat(counts: List[int], target_prob: float=0.7245508982035929):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7245508982035929):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_199",
    "sat": "def sat(counts: List[int], target_prob: float=0.169002473206925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.169002473206925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_200",
    "sat": "def sat(counts: List[int], target_prob: float=0.09090909090909091):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09090909090909091):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_201",
    "sat": "def sat(counts: List[int], target_prob: float=0.6376306620209059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6376306620209059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_202",
    "sat": "def sat(counts: List[int], target_prob: float=0.4434389140271493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4434389140271493):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_203",
    "sat": "def sat(counts: List[int], target_prob: float=0.1111111111111111):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1111111111111111):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_204",
    "sat": "def sat(counts: List[int], target_prob: float=0.18726591760299627):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18726591760299627):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_205",
    "sat": "def sat(counts: List[int], target_prob: float=0.24475524475524477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24475524475524477):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_206",
    "sat": "def sat(counts: List[int], target_prob: float=0.6433566433566433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6433566433566433):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_207",
    "sat": "def sat(counts: List[int], target_prob: float=0.088):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.088):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_208",
    "sat": "def sat(counts: List[int], target_prob: float=0.32323232323232326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32323232323232326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_209",
    "sat": "def sat(counts: List[int], target_prob: float=0.5276190476190477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5276190476190477):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_210",
    "sat": "def sat(counts: List[int], target_prob: float=0.215210355987055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.215210355987055):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_211",
    "sat": "def sat(counts: List[int], target_prob: float=0.12138728323699421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12138728323699421):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_212",
    "sat": "def sat(counts: List[int], target_prob: float=0.12933753943217666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12933753943217666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_213",
    "sat": "def sat(counts: List[int], target_prob: float=0.7244094488188977):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7244094488188977):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_214",
    "sat": "def sat(counts: List[int], target_prob: float=0.39901477832512317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39901477832512317):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_215",
    "sat": "def sat(counts: List[int], target_prob: float=0.0019193857965451055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0019193857965451055):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_216",
    "sat": "def sat(counts: List[int], target_prob: float=0.010752688172043012):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.010752688172043012):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_217",
    "sat": "def sat(counts: List[int], target_prob: float=0.2857142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2857142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_218",
    "sat": "def sat(counts: List[int], target_prob: float=0.35802469135802467):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35802469135802467):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_219",
    "sat": "def sat(counts: List[int], target_prob: float=0.3466424682395644):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3466424682395644):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_220",
    "sat": "def sat(counts: List[int], target_prob: float=0.31645569620253167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31645569620253167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_221",
    "sat": "def sat(counts: List[int], target_prob: float=0.826865671641791):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.826865671641791):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_222",
    "sat": "def sat(counts: List[int], target_prob: float=0.47019867549668876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47019867549668876):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_223",
    "sat": "def sat(counts: List[int], target_prob: float=0.5405405405405406):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5405405405405406):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_224",
    "sat": "def sat(counts: List[int], target_prob: float=0.9446640316205533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9446640316205533):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_225",
    "sat": "def sat(counts: List[int], target_prob: float=0.2708688245315162):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2708688245315162):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_226",
    "sat": "def sat(counts: List[int], target_prob: float=0.8181818181818182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8181818181818182):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_227",
    "sat": "def sat(counts: List[int], target_prob: float=0.07894736842105263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07894736842105263):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_228",
    "sat": "def sat(counts: List[int], target_prob: float=0.26406926406926406):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26406926406926406):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_229",
    "sat": "def sat(counts: List[int], target_prob: float=0.6432432432432432):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6432432432432432):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_230",
    "sat": "def sat(counts: List[int], target_prob: float=0.22026431718061673):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22026431718061673):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_231",
    "sat": "def sat(counts: List[int], target_prob: float=0.5730994152046783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5730994152046783):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_232",
    "sat": "def sat(counts: List[int], target_prob: float=0.2399193548387097):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2399193548387097):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_233",
    "sat": "def sat(counts: List[int], target_prob: float=0.025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.025):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_234",
    "sat": "def sat(counts: List[int], target_prob: float=0.3489278752436647):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3489278752436647):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_235",
    "sat": "def sat(counts: List[int], target_prob: float=0.5028901734104047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5028901734104047):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_236",
    "sat": "def sat(counts: List[int], target_prob: float=0.096045197740113):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.096045197740113):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_237",
    "sat": "def sat(counts: List[int], target_prob: float=0.48091603053435117):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48091603053435117):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_238",
    "sat": "def sat(counts: List[int], target_prob: float=0.2830188679245283):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2830188679245283):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_239",
    "sat": "def sat(counts: List[int], target_prob: float=0.6923076923076923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6923076923076923):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_240",
    "sat": "def sat(counts: List[int], target_prob: float=0.5229885057471264):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5229885057471264):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_241",
    "sat": "def sat(counts: List[int], target_prob: float=0.3584905660377358):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3584905660377358):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_242",
    "sat": "def sat(counts: List[int], target_prob: float=0.3029411764705882):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3029411764705882):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_243",
    "sat": "def sat(counts: List[int], target_prob: float=0.06428571428571428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06428571428571428):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_244",
    "sat": "def sat(counts: List[int], target_prob: float=0.023255813953488372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.023255813953488372):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_245",
    "sat": "def sat(counts: List[int], target_prob: float=0.30985915492957744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30985915492957744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_246",
    "sat": "def sat(counts: List[int], target_prob: float=0.41935483870967744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41935483870967744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_247",
    "sat": "def sat(counts: List[int], target_prob: float=0.018518518518518517):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.018518518518518517):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_248",
    "sat": "def sat(counts: List[int], target_prob: float=0.9848484848484849):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9848484848484849):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_249",
    "sat": "def sat(counts: List[int], target_prob: float=0.8778625954198473):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8778625954198473):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_250",
    "sat": "def sat(counts: List[int], target_prob: float=0.23243243243243245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23243243243243245):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_251",
    "sat": "def sat(counts: List[int], target_prob: float=0.04150943396226415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04150943396226415):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_252",
    "sat": "def sat(counts: List[int], target_prob: float=0.9333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_253",
    "sat": "def sat(counts: List[int], target_prob: float=0.0738255033557047):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0738255033557047):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_254",
    "sat": "def sat(counts: List[int], target_prob: float=0.2571428571428571):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2571428571428571):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_255",
    "sat": "def sat(counts: List[int], target_prob: float=0.03417533432392273):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03417533432392273):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_256",
    "sat": "def sat(counts: List[int], target_prob: float=0.9069767441860465):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9069767441860465):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_257",
    "sat": "def sat(counts: List[int], target_prob: float=0.6421052631578947):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6421052631578947):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_258",
    "sat": "def sat(counts: List[int], target_prob: float=0.9):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_259",
    "sat": "def sat(counts: List[int], target_prob: float=0.6025236593059937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6025236593059937):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_260",
    "sat": "def sat(counts: List[int], target_prob: float=0.11627906976744186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11627906976744186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_261",
    "sat": "def sat(counts: List[int], target_prob: float=0.0576271186440678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0576271186440678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_262",
    "sat": "def sat(counts: List[int], target_prob: float=0.8881118881118881):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8881118881118881):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_263",
    "sat": "def sat(counts: List[int], target_prob: float=0.6464646464646465):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6464646464646465):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_264",
    "sat": "def sat(counts: List[int], target_prob: float=0.19607843137254902):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19607843137254902):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_265",
    "sat": "def sat(counts: List[int], target_prob: float=0.5570469798657718):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5570469798657718):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_266",
    "sat": "def sat(counts: List[int], target_prob: float=0.27447833065810595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27447833065810595):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_267",
    "sat": "def sat(counts: List[int], target_prob: float=0.23742454728370221):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23742454728370221):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_268",
    "sat": "def sat(counts: List[int], target_prob: float=0.5357142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5357142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_269",
    "sat": "def sat(counts: List[int], target_prob: float=0.264):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.264):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_270",
    "sat": "def sat(counts: List[int], target_prob: float=0.025210084033613446):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.025210084033613446):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_271",
    "sat": "def sat(counts: List[int], target_prob: float=0.8611111111111112):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8611111111111112):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_272",
    "sat": "def sat(counts: List[int], target_prob: float=0.7169811320754716):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7169811320754716):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_273",
    "sat": "def sat(counts: List[int], target_prob: float=0.32142857142857145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32142857142857145):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_274",
    "sat": "def sat(counts: List[int], target_prob: float=0.24669909659485753):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24669909659485753):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_275",
    "sat": "def sat(counts: List[int], target_prob: float=0.026352288488210817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.026352288488210817):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_276",
    "sat": "def sat(counts: List[int], target_prob: float=0.8493150684931506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8493150684931506):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_277",
    "sat": "def sat(counts: List[int], target_prob: float=0.5294117647058824):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5294117647058824):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_278",
    "sat": "def sat(counts: List[int], target_prob: float=0.15501519756838905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15501519756838905):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_279",
    "sat": "def sat(counts: List[int], target_prob: float=0.7593360995850622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7593360995850622):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_280",
    "sat": "def sat(counts: List[int], target_prob: float=0.6831683168316832):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6831683168316832):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_281",
    "sat": "def sat(counts: List[int], target_prob: float=0.36180904522613067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36180904522613067):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_282",
    "sat": "def sat(counts: List[int], target_prob: float=0.07878787878787878):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07878787878787878):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_283",
    "sat": "def sat(counts: List[int], target_prob: float=0.2727272727272727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2727272727272727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_284",
    "sat": "def sat(counts: List[int], target_prob: float=0.8439716312056738):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8439716312056738):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_285",
    "sat": "def sat(counts: List[int], target_prob: float=0.3897707231040564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3897707231040564):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_286",
    "sat": "def sat(counts: List[int], target_prob: float=0.2903225806451613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2903225806451613):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_287",
    "sat": "def sat(counts: List[int], target_prob: float=0.12698412698412698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12698412698412698):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_288",
    "sat": "def sat(counts: List[int], target_prob: float=0.9221183800623053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9221183800623053):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_289",
    "sat": "def sat(counts: List[int], target_prob: float=0.21739130434782608):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21739130434782608):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_290",
    "sat": "def sat(counts: List[int], target_prob: float=0.13966480446927373):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13966480446927373):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_291",
    "sat": "def sat(counts: List[int], target_prob: float=0.8256410256410256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8256410256410256):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_292",
    "sat": "def sat(counts: List[int], target_prob: float=0.37777777777777777):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.37777777777777777):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_293",
    "sat": "def sat(counts: List[int], target_prob: float=0.02881844380403458):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02881844380403458):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_294",
    "sat": "def sat(counts: List[int], target_prob: float=0.3545706371191136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3545706371191136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_295",
    "sat": "def sat(counts: List[int], target_prob: float=0.8648648648648649):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8648648648648649):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_296",
    "sat": "def sat(counts: List[int], target_prob: float=0.8072289156626506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8072289156626506):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_297",
    "sat": "def sat(counts: List[int], target_prob: float=0.3283582089552239):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3283582089552239):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_298",
    "sat": "def sat(counts: List[int], target_prob: float=0.21100917431192662):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21100917431192662):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_299",
    "sat": "def sat(counts: List[int], target_prob: float=0.28735632183908044):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28735632183908044):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_300",
    "sat": "def sat(counts: List[int], target_prob: float=0.7285067873303167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7285067873303167):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_301",
    "sat": "def sat(counts: List[int], target_prob: float=0.0072992700729927005):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0072992700729927005):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_302",
    "sat": "def sat(counts: List[int], target_prob: float=0.45):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_303",
    "sat": "def sat(counts: List[int], target_prob: float=0.5901639344262295):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5901639344262295):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_304",
    "sat": "def sat(counts: List[int], target_prob: float=0.48672566371681414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48672566371681414):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_305",
    "sat": "def sat(counts: List[int], target_prob: float=0.4302788844621514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4302788844621514):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_306",
    "sat": "def sat(counts: List[int], target_prob: float=0.49356913183279744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49356913183279744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_307",
    "sat": "def sat(counts: List[int], target_prob: float=0.5686274509803921):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5686274509803921):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_308",
    "sat": "def sat(counts: List[int], target_prob: float=0.8820638820638821):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8820638820638821):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_309",
    "sat": "def sat(counts: List[int], target_prob: float=0.5974842767295597):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5974842767295597):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_310",
    "sat": "def sat(counts: List[int], target_prob: float=0.08323281061519903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08323281061519903):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_311",
    "sat": "def sat(counts: List[int], target_prob: float=0.22388059701492538):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22388059701492538):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_312",
    "sat": "def sat(counts: List[int], target_prob: float=0.41272189349112426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41272189349112426):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_313",
    "sat": "def sat(counts: List[int], target_prob: float=0.1781818181818182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1781818181818182):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_314",
    "sat": "def sat(counts: List[int], target_prob: float=0.1):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_315",
    "sat": "def sat(counts: List[int], target_prob: float=0.08064516129032258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08064516129032258):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_316",
    "sat": "def sat(counts: List[int], target_prob: float=0.4342105263157895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4342105263157895):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_317",
    "sat": "def sat(counts: List[int], target_prob: float=0.29983792544570503):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29983792544570503):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_318",
    "sat": "def sat(counts: List[int], target_prob: float=0.6850393700787402):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6850393700787402):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_319",
    "sat": "def sat(counts: List[int], target_prob: float=0.25333333333333335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25333333333333335):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_320",
    "sat": "def sat(counts: List[int], target_prob: float=0.8333333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8333333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_321",
    "sat": "def sat(counts: List[int], target_prob: float=0.26744186046511625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26744186046511625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_322",
    "sat": "def sat(counts: List[int], target_prob: float=0.026102610261026102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.026102610261026102):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_323",
    "sat": "def sat(counts: List[int], target_prob: float=0.4132231404958678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4132231404958678):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_324",
    "sat": "def sat(counts: List[int], target_prob: float=0.09259259259259259):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09259259259259259):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_325",
    "sat": "def sat(counts: List[int], target_prob: float=0.7391304347826086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7391304347826086):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_326",
    "sat": "def sat(counts: List[int], target_prob: float=0.11235955056179775):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11235955056179775):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_327",
    "sat": "def sat(counts: List[int], target_prob: float=0.1757188498402556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1757188498402556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_328",
    "sat": "def sat(counts: List[int], target_prob: float=0.25210084033613445):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25210084033613445):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_329",
    "sat": "def sat(counts: List[int], target_prob: float=0.05641025641025641):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05641025641025641):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_330",
    "sat": "def sat(counts: List[int], target_prob: float=0.6282527881040892):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6282527881040892):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_331",
    "sat": "def sat(counts: List[int], target_prob: float=0.7538461538461538):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7538461538461538):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_332",
    "sat": "def sat(counts: List[int], target_prob: float=0.33043478260869563):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.33043478260869563):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_333",
    "sat": "def sat(counts: List[int], target_prob: float=0.6035743298131601):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6035743298131601):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_334",
    "sat": "def sat(counts: List[int], target_prob: float=0.15327564894932014):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15327564894932014):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_335",
    "sat": "def sat(counts: List[int], target_prob: float=0.07479224376731301):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07479224376731301):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_336",
    "sat": "def sat(counts: List[int], target_prob: float=0.3652173913043478):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3652173913043478):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_337",
    "sat": "def sat(counts: List[int], target_prob: float=0.1079136690647482):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1079136690647482):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_338",
    "sat": "def sat(counts: List[int], target_prob: float=0.09130434782608696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09130434782608696):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_339",
    "sat": "def sat(counts: List[int], target_prob: float=0.24242424242424243):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24242424242424243):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_340",
    "sat": "def sat(counts: List[int], target_prob: float=0.24705882352941178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24705882352941178):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_341",
    "sat": "def sat(counts: List[int], target_prob: float=0.13131313131313133):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13131313131313133):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_342",
    "sat": "def sat(counts: List[int], target_prob: float=0.19767441860465115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19767441860465115):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_343",
    "sat": "def sat(counts: List[int], target_prob: float=0.2332657200811359):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2332657200811359):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_344",
    "sat": "def sat(counts: List[int], target_prob: float=0.0880503144654088):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0880503144654088):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_345",
    "sat": "def sat(counts: List[int], target_prob: float=0.7744360902255639):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7744360902255639):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_346",
    "sat": "def sat(counts: List[int], target_prob: float=0.8238341968911918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8238341968911918):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_347",
    "sat": "def sat(counts: List[int], target_prob: float=0.7940199335548173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7940199335548173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_348",
    "sat": "def sat(counts: List[int], target_prob: float=0.5967741935483871):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5967741935483871):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_349",
    "sat": "def sat(counts: List[int], target_prob: float=0.9433962264150944):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9433962264150944):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_350",
    "sat": "def sat(counts: List[int], target_prob: float=0.05806451612903226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05806451612903226):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_351",
    "sat": "def sat(counts: List[int], target_prob: float=0.16666666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16666666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_352",
    "sat": "def sat(counts: List[int], target_prob: float=0.0794979079497908):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0794979079497908):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_353",
    "sat": "def sat(counts: List[int], target_prob: float=0.9822222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9822222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_354",
    "sat": "def sat(counts: List[int], target_prob: float=0.4398496240601504):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4398496240601504):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_355",
    "sat": "def sat(counts: List[int], target_prob: float=0.256120527306968):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.256120527306968):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_356",
    "sat": "def sat(counts: List[int], target_prob: float=0.7217391304347827):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7217391304347827):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_357",
    "sat": "def sat(counts: List[int], target_prob: float=0.8526315789473684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8526315789473684):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_358",
    "sat": "def sat(counts: List[int], target_prob: float=0.056818181818181816):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.056818181818181816):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_359",
    "sat": "def sat(counts: List[int], target_prob: float=0.44680851063829785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44680851063829785):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_360",
    "sat": "def sat(counts: List[int], target_prob: float=0.7830188679245284):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7830188679245284):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_361",
    "sat": "def sat(counts: List[int], target_prob: float=0.8709677419354839):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8709677419354839):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_362",
    "sat": "def sat(counts: List[int], target_prob: float=0.0196078431372549):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0196078431372549):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_363",
    "sat": "def sat(counts: List[int], target_prob: float=0.5689655172413793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5689655172413793):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_364",
    "sat": "def sat(counts: List[int], target_prob: float=0.5098039215686274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5098039215686274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_365",
    "sat": "def sat(counts: List[int], target_prob: float=0.6216216216216216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6216216216216216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_366",
    "sat": "def sat(counts: List[int], target_prob: float=0.4565826330532213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4565826330532213):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_367",
    "sat": "def sat(counts: List[int], target_prob: float=0.14473684210526316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14473684210526316):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_368",
    "sat": "def sat(counts: List[int], target_prob: float=0.06878306878306878):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06878306878306878):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_369",
    "sat": "def sat(counts: List[int], target_prob: float=0.4556213017751479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4556213017751479):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_370",
    "sat": "def sat(counts: List[int], target_prob: float=0.3259668508287293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3259668508287293):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_371",
    "sat": "def sat(counts: List[int], target_prob: float=0.9420289855072463):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9420289855072463):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_372",
    "sat": "def sat(counts: List[int], target_prob: float=0.011960478419136765):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.011960478419136765):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_373",
    "sat": "def sat(counts: List[int], target_prob: float=0.05737704918032787):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05737704918032787):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_374",
    "sat": "def sat(counts: List[int], target_prob: float=0.19093851132686085):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19093851132686085):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_375",
    "sat": "def sat(counts: List[int], target_prob: float=0.27906976744186046):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27906976744186046):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_376",
    "sat": "def sat(counts: List[int], target_prob: float=0.18200408997955012):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18200408997955012):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_377",
    "sat": "def sat(counts: List[int], target_prob: float=0.044585987261146494):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.044585987261146494):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_378",
    "sat": "def sat(counts: List[int], target_prob: float=0.6622889305816135):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6622889305816135):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_379",
    "sat": "def sat(counts: List[int], target_prob: float=0.10526315789473684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10526315789473684):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_380",
    "sat": "def sat(counts: List[int], target_prob: float=0.008379888268156424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.008379888268156424):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_381",
    "sat": "def sat(counts: List[int], target_prob: float=0.7938144329896907):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7938144329896907):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_382",
    "sat": "def sat(counts: List[int], target_prob: float=0.19895287958115182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19895287958115182):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_383",
    "sat": "def sat(counts: List[int], target_prob: float=0.9155749636098981):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9155749636098981):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_384",
    "sat": "def sat(counts: List[int], target_prob: float=0.47317073170731705):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47317073170731705):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_385",
    "sat": "def sat(counts: List[int], target_prob: float=0.2777777777777778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2777777777777778):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_386",
    "sat": "def sat(counts: List[int], target_prob: float=0.16455696202531644):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16455696202531644):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_387",
    "sat": "def sat(counts: List[int], target_prob: float=0.8364389233954451):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8364389233954451):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_388",
    "sat": "def sat(counts: List[int], target_prob: float=0.7857142857142857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7857142857142857):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_389",
    "sat": "def sat(counts: List[int], target_prob: float=0.8556701030927835):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8556701030927835):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_390",
    "sat": "def sat(counts: List[int], target_prob: float=0.35714285714285715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35714285714285715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_391",
    "sat": "def sat(counts: List[int], target_prob: float=0.010869565217391304):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.010869565217391304):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_392",
    "sat": "def sat(counts: List[int], target_prob: float=0.6378737541528239):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6378737541528239):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_393",
    "sat": "def sat(counts: List[int], target_prob: float=0.2229299363057325):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2229299363057325):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_394",
    "sat": "def sat(counts: List[int], target_prob: float=0.2222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_395",
    "sat": "def sat(counts: List[int], target_prob: float=0.5636363636363636):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5636363636363636):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_396",
    "sat": "def sat(counts: List[int], target_prob: float=0.4025974025974026):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4025974025974026):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_397",
    "sat": "def sat(counts: List[int], target_prob: float=0.6995708154506438):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6995708154506438):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_398",
    "sat": "def sat(counts: List[int], target_prob: float=0.06051282051282051):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06051282051282051):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_399",
    "sat": "def sat(counts: List[int], target_prob: float=0.5463917525773195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5463917525773195):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_400",
    "sat": "def sat(counts: List[int], target_prob: float=0.4962962962962963):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4962962962962963):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_401",
    "sat": "def sat(counts: List[int], target_prob: float=0.10189982728842832):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10189982728842832):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_402",
    "sat": "def sat(counts: List[int], target_prob: float=0.39490445859872614):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39490445859872614):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_403",
    "sat": "def sat(counts: List[int], target_prob: float=0.6086956521739131):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6086956521739131):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_404",
    "sat": "def sat(counts: List[int], target_prob: float=0.07228915662650602):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07228915662650602):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_405",
    "sat": "def sat(counts: List[int], target_prob: float=0.2413793103448276):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2413793103448276):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_406",
    "sat": "def sat(counts: List[int], target_prob: float=0.15602094240837697):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15602094240837697):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_407",
    "sat": "def sat(counts: List[int], target_prob: float=0.16040100250626566):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16040100250626566):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_408",
    "sat": "def sat(counts: List[int], target_prob: float=0.7802197802197802):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7802197802197802):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_409",
    "sat": "def sat(counts: List[int], target_prob: float=0.6545454545454545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6545454545454545):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_410",
    "sat": "def sat(counts: List[int], target_prob: float=0.12149532710280374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12149532710280374):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_411",
    "sat": "def sat(counts: List[int], target_prob: float=0.7816377171215881):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7816377171215881):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_412",
    "sat": "def sat(counts: List[int], target_prob: float=0.0066815144766146995):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0066815144766146995):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_413",
    "sat": "def sat(counts: List[int], target_prob: float=0.8518518518518519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8518518518518519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_414",
    "sat": "def sat(counts: List[int], target_prob: float=0.3217893217893218):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3217893217893218):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_415",
    "sat": "def sat(counts: List[int], target_prob: float=0.4523809523809524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4523809523809524):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_416",
    "sat": "def sat(counts: List[int], target_prob: float=0.4226327944572748):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4226327944572748):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_417",
    "sat": "def sat(counts: List[int], target_prob: float=0.05654281098546042):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05654281098546042):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_418",
    "sat": "def sat(counts: List[int], target_prob: float=0.2045889101338432):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2045889101338432):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_419",
    "sat": "def sat(counts: List[int], target_prob: float=0.4117647058823529):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4117647058823529):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_420",
    "sat": "def sat(counts: List[int], target_prob: float=0.5726495726495726):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5726495726495726):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_421",
    "sat": "def sat(counts: List[int], target_prob: float=0.375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_422",
    "sat": "def sat(counts: List[int], target_prob: float=0.6212121212121212):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6212121212121212):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_423",
    "sat": "def sat(counts: List[int], target_prob: float=0.22247191011235956):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22247191011235956):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_424",
    "sat": "def sat(counts: List[int], target_prob: float=0.6548672566371682):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6548672566371682):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_425",
    "sat": "def sat(counts: List[int], target_prob: float=0.17307692307692307):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17307692307692307):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_426",
    "sat": "def sat(counts: List[int], target_prob: float=0.2982456140350877):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2982456140350877):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_427",
    "sat": "def sat(counts: List[int], target_prob: float=0.30666666666666664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30666666666666664):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_428",
    "sat": "def sat(counts: List[int], target_prob: float=0.9884393063583815):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9884393063583815):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_429",
    "sat": "def sat(counts: List[int], target_prob: float=0.10144927536231885):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10144927536231885):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_430",
    "sat": "def sat(counts: List[int], target_prob: float=0.21875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_431",
    "sat": "def sat(counts: List[int], target_prob: float=0.2641509433962264):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2641509433962264):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_432",
    "sat": "def sat(counts: List[int], target_prob: float=0.9103448275862069):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9103448275862069):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_433",
    "sat": "def sat(counts: List[int], target_prob: float=0.136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_434",
    "sat": "def sat(counts: List[int], target_prob: float=0.5719844357976653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5719844357976653):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_435",
    "sat": "def sat(counts: List[int], target_prob: float=0.47058823529411764):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47058823529411764):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_436",
    "sat": "def sat(counts: List[int], target_prob: float=0.06451612903225806):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06451612903225806):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_437",
    "sat": "def sat(counts: List[int], target_prob: float=0.10839913854989232):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10839913854989232):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_438",
    "sat": "def sat(counts: List[int], target_prob: float=0.8199672667757774):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8199672667757774):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_439",
    "sat": "def sat(counts: List[int], target_prob: float=0.012048192771084338):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012048192771084338):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_440",
    "sat": "def sat(counts: List[int], target_prob: float=0.49056603773584906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49056603773584906):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_441",
    "sat": "def sat(counts: List[int], target_prob: float=0.07692307692307693):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07692307692307693):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_442",
    "sat": "def sat(counts: List[int], target_prob: float=0.7855227882037533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7855227882037533):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_443",
    "sat": "def sat(counts: List[int], target_prob: float=0.8222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_444",
    "sat": "def sat(counts: List[int], target_prob: float=0.26804123711340205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26804123711340205):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_445",
    "sat": "def sat(counts: List[int], target_prob: float=0.29411764705882354):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29411764705882354):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_446",
    "sat": "def sat(counts: List[int], target_prob: float=0.6486486486486487):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6486486486486487):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_447",
    "sat": "def sat(counts: List[int], target_prob: float=0.983739837398374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.983739837398374):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_448",
    "sat": "def sat(counts: List[int], target_prob: float=0.3364485981308411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3364485981308411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_449",
    "sat": "def sat(counts: List[int], target_prob: float=0.13140311804008908):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13140311804008908):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_450",
    "sat": "def sat(counts: List[int], target_prob: float=0.8571428571428571):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8571428571428571):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_451",
    "sat": "def sat(counts: List[int], target_prob: float=0.17647058823529413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17647058823529413):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_452",
    "sat": "def sat(counts: List[int], target_prob: float=0.14098360655737704):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14098360655737704):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_453",
    "sat": "def sat(counts: List[int], target_prob: float=0.5164835164835165):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5164835164835165):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_454",
    "sat": "def sat(counts: List[int], target_prob: float=0.1193058568329718):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1193058568329718):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_455",
    "sat": "def sat(counts: List[int], target_prob: float=0.2579185520361991):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2579185520361991):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_456",
    "sat": "def sat(counts: List[int], target_prob: float=0.04477611940298507):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04477611940298507):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_457",
    "sat": "def sat(counts: List[int], target_prob: float=0.1903485254691689):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1903485254691689):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_458",
    "sat": "def sat(counts: List[int], target_prob: float=0.23333333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23333333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_459",
    "sat": "def sat(counts: List[int], target_prob: float=0.18181818181818182):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18181818181818182):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_460",
    "sat": "def sat(counts: List[int], target_prob: float=0.5138888888888888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5138888888888888):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_461",
    "sat": "def sat(counts: List[int], target_prob: float=0.10884353741496598):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10884353741496598):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_462",
    "sat": "def sat(counts: List[int], target_prob: float=0.043583535108958835):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.043583535108958835):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_463",
    "sat": "def sat(counts: List[int], target_prob: float=0.12021857923497267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12021857923497267):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_464",
    "sat": "def sat(counts: List[int], target_prob: float=0.9415730337078652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9415730337078652):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_465",
    "sat": "def sat(counts: List[int], target_prob: float=0.4084507042253521):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4084507042253521):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_466",
    "sat": "def sat(counts: List[int], target_prob: float=0.9389671361502347):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9389671361502347):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_467",
    "sat": "def sat(counts: List[int], target_prob: float=0.15916955017301038):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15916955017301038):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_468",
    "sat": "def sat(counts: List[int], target_prob: float=0.12236286919831224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12236286919831224):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_469",
    "sat": "def sat(counts: List[int], target_prob: float=0.2966360856269113):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2966360856269113):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_470",
    "sat": "def sat(counts: List[int], target_prob: float=0.3014354066985646):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3014354066985646):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_471",
    "sat": "def sat(counts: List[int], target_prob: float=0.76):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.76):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_472",
    "sat": "def sat(counts: List[int], target_prob: float=0.24429967426710097):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24429967426710097):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_473",
    "sat": "def sat(counts: List[int], target_prob: float=0.20689655172413793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20689655172413793):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_474",
    "sat": "def sat(counts: List[int], target_prob: float=0.0994236311239193):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0994236311239193):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_475",
    "sat": "def sat(counts: List[int], target_prob: float=0.6136363636363636):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6136363636363636):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_476",
    "sat": "def sat(counts: List[int], target_prob: float=0.41767068273092367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41767068273092367):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_477",
    "sat": "def sat(counts: List[int], target_prob: float=0.3113207547169811):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3113207547169811):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_478",
    "sat": "def sat(counts: List[int], target_prob: float=0.1044776119402985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1044776119402985):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_479",
    "sat": "def sat(counts: List[int], target_prob: float=0.8938053097345132):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8938053097345132):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_480",
    "sat": "def sat(counts: List[int], target_prob: float=0.725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_481",
    "sat": "def sat(counts: List[int], target_prob: float=0.7159763313609467):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7159763313609467):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_482",
    "sat": "def sat(counts: List[int], target_prob: float=0.2786885245901639):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2786885245901639):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_483",
    "sat": "def sat(counts: List[int], target_prob: float=0.05979381443298969):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05979381443298969):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_484",
    "sat": "def sat(counts: List[int], target_prob: float=0.19777931991672448):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19777931991672448):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_485",
    "sat": "def sat(counts: List[int], target_prob: float=0.9946091644204852):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9946091644204852):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_486",
    "sat": "def sat(counts: List[int], target_prob: float=0.2483221476510067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2483221476510067):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_487",
    "sat": "def sat(counts: List[int], target_prob: float=0.38461538461538464):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38461538461538464):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_488",
    "sat": "def sat(counts: List[int], target_prob: float=0.075):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.075):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_489",
    "sat": "def sat(counts: List[int], target_prob: float=0.9024390243902439):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9024390243902439):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_490",
    "sat": "def sat(counts: List[int], target_prob: float=0.8950437317784257):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8950437317784257):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_491",
    "sat": "def sat(counts: List[int], target_prob: float=0.8502673796791443):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8502673796791443):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_492",
    "sat": "def sat(counts: List[int], target_prob: float=0.6445783132530121):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6445783132530121):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_493",
    "sat": "def sat(counts: List[int], target_prob: float=0.047619047619047616):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.047619047619047616):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_494",
    "sat": "def sat(counts: List[int], target_prob: float=0.1967654986522911):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1967654986522911):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_495",
    "sat": "def sat(counts: List[int], target_prob: float=0.6408839779005525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6408839779005525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_496",
    "sat": "def sat(counts: List[int], target_prob: float=0.046153846153846156):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.046153846153846156):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_497",
    "sat": "def sat(counts: List[int], target_prob: float=0.3142857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_498",
    "sat": "def sat(counts: List[int], target_prob: float=0.1836734693877551):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1836734693877551):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_499",
    "sat": "def sat(counts: List[int], target_prob: float=0.2677165354330709):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2677165354330709):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_500",
    "sat": "def sat(counts: List[int], target_prob: float=0.05084745762711865):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05084745762711865):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_501",
    "sat": "def sat(counts: List[int], target_prob: float=0.5547945205479452):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5547945205479452):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_502",
    "sat": "def sat(counts: List[int], target_prob: float=0.5584415584415584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5584415584415584):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_503",
    "sat": "def sat(counts: List[int], target_prob: float=0.3531073446327684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3531073446327684):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_504",
    "sat": "def sat(counts: List[int], target_prob: float=0.9878048780487805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9878048780487805):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_505",
    "sat": "def sat(counts: List[int], target_prob: float=0.3148717948717949):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3148717948717949):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_506",
    "sat": "def sat(counts: List[int], target_prob: float=0.01652892561983471):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01652892561983471):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_507",
    "sat": "def sat(counts: List[int], target_prob: float=0.8198198198198198):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8198198198198198):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_508",
    "sat": "def sat(counts: List[int], target_prob: float=0.10344827586206896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10344827586206896):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_509",
    "sat": "def sat(counts: List[int], target_prob: float=0.6793743890518084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6793743890518084):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_510",
    "sat": "def sat(counts: List[int], target_prob: float=0.8536585365853658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8536585365853658):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_511",
    "sat": "def sat(counts: List[int], target_prob: float=0.5836734693877551):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5836734693877551):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_512",
    "sat": "def sat(counts: List[int], target_prob: float=0.08092485549132948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08092485549132948):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_513",
    "sat": "def sat(counts: List[int], target_prob: float=0.04008551576696953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04008551576696953):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_514",
    "sat": "def sat(counts: List[int], target_prob: float=0.3579175704989154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3579175704989154):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_515",
    "sat": "def sat(counts: List[int], target_prob: float=0.48186528497409326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.48186528497409326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_516",
    "sat": "def sat(counts: List[int], target_prob: float=0.63125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.63125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_517",
    "sat": "def sat(counts: List[int], target_prob: float=0.17857142857142858):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17857142857142858):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_518",
    "sat": "def sat(counts: List[int], target_prob: float=0.35658914728682173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35658914728682173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_519",
    "sat": "def sat(counts: List[int], target_prob: float=0.7866666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7866666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_520",
    "sat": "def sat(counts: List[int], target_prob: float=0.7009345794392523):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7009345794392523):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_521",
    "sat": "def sat(counts: List[int], target_prob: float=0.32727272727272727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32727272727272727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_522",
    "sat": "def sat(counts: List[int], target_prob: float=0.015873015873015872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.015873015873015872):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_523",
    "sat": "def sat(counts: List[int], target_prob: float=0.4889867841409692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4889867841409692):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_524",
    "sat": "def sat(counts: List[int], target_prob: float=0.0992462311557789):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0992462311557789):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_525",
    "sat": "def sat(counts: List[int], target_prob: float=0.046610169491525424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.046610169491525424):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_526",
    "sat": "def sat(counts: List[int], target_prob: float=0.09662921348314607):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09662921348314607):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_527",
    "sat": "def sat(counts: List[int], target_prob: float=0.01694915254237288):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01694915254237288):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_528",
    "sat": "def sat(counts: List[int], target_prob: float=0.002347417840375587):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.002347417840375587):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_529",
    "sat": "def sat(counts: List[int], target_prob: float=0.1070615034168565):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1070615034168565):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_530",
    "sat": "def sat(counts: List[int], target_prob: float=0.20364741641337386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20364741641337386):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_531",
    "sat": "def sat(counts: List[int], target_prob: float=0.4444444444444444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4444444444444444):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_532",
    "sat": "def sat(counts: List[int], target_prob: float=0.7890625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7890625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_533",
    "sat": "def sat(counts: List[int], target_prob: float=0.25274725274725274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25274725274725274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_534",
    "sat": "def sat(counts: List[int], target_prob: float=0.24481327800829875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24481327800829875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_535",
    "sat": "def sat(counts: List[int], target_prob: float=0.04669887278582931):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04669887278582931):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_536",
    "sat": "def sat(counts: List[int], target_prob: float=0.9518652226233454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9518652226233454):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_537",
    "sat": "def sat(counts: List[int], target_prob: float=0.3068181818181818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3068181818181818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_538",
    "sat": "def sat(counts: List[int], target_prob: float=0.20754716981132076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20754716981132076):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_539",
    "sat": "def sat(counts: List[int], target_prob: float=0.3707865168539326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3707865168539326):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_540",
    "sat": "def sat(counts: List[int], target_prob: float=0.7373134328358208):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7373134328358208):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_541",
    "sat": "def sat(counts: List[int], target_prob: float=0.2693498452012384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2693498452012384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_542",
    "sat": "def sat(counts: List[int], target_prob: float=0.7262180974477959):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7262180974477959):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_543",
    "sat": "def sat(counts: List[int], target_prob: float=0.5483870967741935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5483870967741935):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_544",
    "sat": "def sat(counts: List[int], target_prob: float=0.6235294117647059):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6235294117647059):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_545",
    "sat": "def sat(counts: List[int], target_prob: float=0.18387909319899245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.18387909319899245):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_546",
    "sat": "def sat(counts: List[int], target_prob: float=0.52):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.52):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_547",
    "sat": "def sat(counts: List[int], target_prob: float=0.2774869109947644):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2774869109947644):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_548",
    "sat": "def sat(counts: List[int], target_prob: float=0.9459459459459459):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9459459459459459):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_549",
    "sat": "def sat(counts: List[int], target_prob: float=0.028680688336520075):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.028680688336520075):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_550",
    "sat": "def sat(counts: List[int], target_prob: float=0.44876325088339225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44876325088339225):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_551",
    "sat": "def sat(counts: List[int], target_prob: float=0.8686131386861314):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8686131386861314):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_552",
    "sat": "def sat(counts: List[int], target_prob: float=0.12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_553",
    "sat": "def sat(counts: List[int], target_prob: float=0.38396624472573837):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38396624472573837):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_554",
    "sat": "def sat(counts: List[int], target_prob: float=0.12380952380952381):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12380952380952381):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_555",
    "sat": "def sat(counts: List[int], target_prob: float=0.29581331503088537):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29581331503088537):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_556",
    "sat": "def sat(counts: List[int], target_prob: float=0.16):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_557",
    "sat": "def sat(counts: List[int], target_prob: float=0.21818181818181817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21818181818181817):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_558",
    "sat": "def sat(counts: List[int], target_prob: float=0.3793103448275862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3793103448275862):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_559",
    "sat": "def sat(counts: List[int], target_prob: float=0.10581222056631892):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10581222056631892):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_560",
    "sat": "def sat(counts: List[int], target_prob: float=0.43389830508474575):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43389830508474575):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_561",
    "sat": "def sat(counts: List[int], target_prob: float=0.16417910447761194):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16417910447761194):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_562",
    "sat": "def sat(counts: List[int], target_prob: float=0.001584786053882726):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.001584786053882726):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_563",
    "sat": "def sat(counts: List[int], target_prob: float=0.9052132701421801):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9052132701421801):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_564",
    "sat": "def sat(counts: List[int], target_prob: float=0.10638297872340426):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10638297872340426):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_565",
    "sat": "def sat(counts: List[int], target_prob: float=0.5945945945945946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5945945945945946):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_566",
    "sat": "def sat(counts: List[int], target_prob: float=0.4375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_567",
    "sat": "def sat(counts: List[int], target_prob: float=0.124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.124):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_568",
    "sat": "def sat(counts: List[int], target_prob: float=0.9399141630901288):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9399141630901288):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_569",
    "sat": "def sat(counts: List[int], target_prob: float=0.27371273712737126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.27371273712737126):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_570",
    "sat": "def sat(counts: List[int], target_prob: float=0.6475095785440613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6475095785440613):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_571",
    "sat": "def sat(counts: List[int], target_prob: float=0.8064516129032258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8064516129032258):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_572",
    "sat": "def sat(counts: List[int], target_prob: float=0.008547008547008548):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.008547008547008548):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_573",
    "sat": "def sat(counts: List[int], target_prob: float=0.20717781402936378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20717781402936378):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_574",
    "sat": "def sat(counts: List[int], target_prob: float=0.03694102397926118):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03694102397926118):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_575",
    "sat": "def sat(counts: List[int], target_prob: float=0.656441717791411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.656441717791411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_576",
    "sat": "def sat(counts: List[int], target_prob: float=0.265625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.265625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_577",
    "sat": "def sat(counts: List[int], target_prob: float=0.125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_578",
    "sat": "def sat(counts: List[int], target_prob: float=0.40913508260447035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40913508260447035):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_579",
    "sat": "def sat(counts: List[int], target_prob: float=0.2818181818181818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2818181818181818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_580",
    "sat": "def sat(counts: List[int], target_prob: float=0.08333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_581",
    "sat": "def sat(counts: List[int], target_prob: float=0.08527131782945736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08527131782945736):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_582",
    "sat": "def sat(counts: List[int], target_prob: float=0.6931608133086876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6931608133086876):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_583",
    "sat": "def sat(counts: List[int], target_prob: float=0.03333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_584",
    "sat": "def sat(counts: List[int], target_prob: float=0.25190839694656486):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25190839694656486):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_585",
    "sat": "def sat(counts: List[int], target_prob: float=0.781021897810219):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.781021897810219):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_586",
    "sat": "def sat(counts: List[int], target_prob: float=0.816793893129771):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.816793893129771):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_587",
    "sat": "def sat(counts: List[int], target_prob: float=0.12195121951219512):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12195121951219512):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_588",
    "sat": "def sat(counts: List[int], target_prob: float=0.0430622009569378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0430622009569378):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_589",
    "sat": "def sat(counts: List[int], target_prob: float=0.34212840809146877):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34212840809146877):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_590",
    "sat": "def sat(counts: List[int], target_prob: float=0.11450381679389313):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11450381679389313):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_591",
    "sat": "def sat(counts: List[int], target_prob: float=0.7692307692307693):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7692307692307693):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_592",
    "sat": "def sat(counts: List[int], target_prob: float=0.1595744680851064):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1595744680851064):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_593",
    "sat": "def sat(counts: List[int], target_prob: float=0.03076923076923077):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03076923076923077):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_594",
    "sat": "def sat(counts: List[int], target_prob: float=0.2542372881355932):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2542372881355932):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_595",
    "sat": "def sat(counts: List[int], target_prob: float=0.11320754716981132):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11320754716981132):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_596",
    "sat": "def sat(counts: List[int], target_prob: float=0.30798479087452474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30798479087452474):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_597",
    "sat": "def sat(counts: List[int], target_prob: float=0.560233918128655):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.560233918128655):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_598",
    "sat": "def sat(counts: List[int], target_prob: float=0.7935483870967742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7935483870967742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_599",
    "sat": "def sat(counts: List[int], target_prob: float=0.6019900497512438):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6019900497512438):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_600",
    "sat": "def sat(counts: List[int], target_prob: float=0.4706994328922495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4706994328922495):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_601",
    "sat": "def sat(counts: List[int], target_prob: float=0.21367521367521367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21367521367521367):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_602",
    "sat": "def sat(counts: List[int], target_prob: float=0.5335029686174725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5335029686174725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_603",
    "sat": "def sat(counts: List[int], target_prob: float=0.8553191489361702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8553191489361702):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_604",
    "sat": "def sat(counts: List[int], target_prob: float=0.9605263157894737):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9605263157894737):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_605",
    "sat": "def sat(counts: List[int], target_prob: float=0.16047430830039525):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16047430830039525):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_606",
    "sat": "def sat(counts: List[int], target_prob: float=0.7846153846153846):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7846153846153846):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_607",
    "sat": "def sat(counts: List[int], target_prob: float=0.2603437301082113):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2603437301082113):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_608",
    "sat": "def sat(counts: List[int], target_prob: float=0.8177874186550976):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8177874186550976):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_609",
    "sat": "def sat(counts: List[int], target_prob: float=0.4076655052264808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4076655052264808):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_610",
    "sat": "def sat(counts: List[int], target_prob: float=0.8666666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8666666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_611",
    "sat": "def sat(counts: List[int], target_prob: float=0.41037735849056606):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41037735849056606):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_612",
    "sat": "def sat(counts: List[int], target_prob: float=0.36550745209368346):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36550745209368346):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_613",
    "sat": "def sat(counts: List[int], target_prob: float=0.0859106529209622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0859106529209622):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_614",
    "sat": "def sat(counts: List[int], target_prob: float=0.6432748538011696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6432748538011696):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_615",
    "sat": "def sat(counts: List[int], target_prob: float=0.9574468085106383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9574468085106383):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_616",
    "sat": "def sat(counts: List[int], target_prob: float=0.7204301075268817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7204301075268817):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_617",
    "sat": "def sat(counts: List[int], target_prob: float=0.2744479495268139):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2744479495268139):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_618",
    "sat": "def sat(counts: List[int], target_prob: float=0.30210016155088854):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30210016155088854):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_619",
    "sat": "def sat(counts: List[int], target_prob: float=0.10909090909090909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10909090909090909):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_620",
    "sat": "def sat(counts: List[int], target_prob: float=0.6333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_621",
    "sat": "def sat(counts: List[int], target_prob: float=0.9366754617414248):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9366754617414248):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_622",
    "sat": "def sat(counts: List[int], target_prob: float=0.8452380952380952):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8452380952380952):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_623",
    "sat": "def sat(counts: List[int], target_prob: float=0.03816793893129771):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03816793893129771):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_624",
    "sat": "def sat(counts: List[int], target_prob: float=0.6458333333333334):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6458333333333334):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_625",
    "sat": "def sat(counts: List[int], target_prob: float=0.07317073170731707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07317073170731707):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_626",
    "sat": "def sat(counts: List[int], target_prob: float=0.4596774193548387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4596774193548387):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_627",
    "sat": "def sat(counts: List[int], target_prob: float=0.4146341463414634):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4146341463414634):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_628",
    "sat": "def sat(counts: List[int], target_prob: float=0.9753086419753086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9753086419753086):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_629",
    "sat": "def sat(counts: List[int], target_prob: float=0.7282608695652174):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7282608695652174):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_630",
    "sat": "def sat(counts: List[int], target_prob: float=0.1125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_631",
    "sat": "def sat(counts: List[int], target_prob: float=0.6972972972972973):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6972972972972973):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_632",
    "sat": "def sat(counts: List[int], target_prob: float=0.33579335793357934):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.33579335793357934):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_633",
    "sat": "def sat(counts: List[int], target_prob: float=0.5436241610738255):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5436241610738255):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_634",
    "sat": "def sat(counts: List[int], target_prob: float=0.6691729323308271):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6691729323308271):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_635",
    "sat": "def sat(counts: List[int], target_prob: float=0.09743589743589744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09743589743589744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_636",
    "sat": "def sat(counts: List[int], target_prob: float=0.04194260485651214):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04194260485651214):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_637",
    "sat": "def sat(counts: List[int], target_prob: float=0.3574007220216607):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3574007220216607):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_638",
    "sat": "def sat(counts: List[int], target_prob: float=0.004291845493562232):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.004291845493562232):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_639",
    "sat": "def sat(counts: List[int], target_prob: float=0.5238095238095238):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5238095238095238):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_640",
    "sat": "def sat(counts: List[int], target_prob: float=0.5370370370370371):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5370370370370371):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_641",
    "sat": "def sat(counts: List[int], target_prob: float=0.2815533980582524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2815533980582524):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_642",
    "sat": "def sat(counts: List[int], target_prob: float=0.4838709677419355):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4838709677419355):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_643",
    "sat": "def sat(counts: List[int], target_prob: float=0.92):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.92):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_644",
    "sat": "def sat(counts: List[int], target_prob: float=0.6140350877192983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6140350877192983):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_645",
    "sat": "def sat(counts: List[int], target_prob: float=0.009708737864077669):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.009708737864077669):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_646",
    "sat": "def sat(counts: List[int], target_prob: float=0.5308641975308642):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5308641975308642):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_647",
    "sat": "def sat(counts: List[int], target_prob: float=0.1935483870967742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1935483870967742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_648",
    "sat": "def sat(counts: List[int], target_prob: float=0.17370892018779344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17370892018779344):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_649",
    "sat": "def sat(counts: List[int], target_prob: float=0.89):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.89):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_650",
    "sat": "def sat(counts: List[int], target_prob: float=0.6818181818181818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6818181818181818):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_651",
    "sat": "def sat(counts: List[int], target_prob: float=0.8888888888888888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8888888888888888):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_652",
    "sat": "def sat(counts: List[int], target_prob: float=0.9036144578313253):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9036144578313253):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_653",
    "sat": "def sat(counts: List[int], target_prob: float=0.6388888888888888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6388888888888888):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_654",
    "sat": "def sat(counts: List[int], target_prob: float=0.4722222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4722222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_655",
    "sat": "def sat(counts: List[int], target_prob: float=0.10810810810810811):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10810810810810811):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_656",
    "sat": "def sat(counts: List[int], target_prob: float=0.19753086419753085):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19753086419753085):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_657",
    "sat": "def sat(counts: List[int], target_prob: float=0.39166666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39166666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_658",
    "sat": "def sat(counts: List[int], target_prob: float=0.2602739726027397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2602739726027397):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_659",
    "sat": "def sat(counts: List[int], target_prob: float=0.5081967213114754):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5081967213114754):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_660",
    "sat": "def sat(counts: List[int], target_prob: float=0.15640599001663893):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15640599001663893):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_661",
    "sat": "def sat(counts: List[int], target_prob: float=0.9487179487179487):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9487179487179487):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_662",
    "sat": "def sat(counts: List[int], target_prob: float=0.5120435120435121):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5120435120435121):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_663",
    "sat": "def sat(counts: List[int], target_prob: float=0.3153153153153153):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3153153153153153):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_664",
    "sat": "def sat(counts: List[int], target_prob: float=0.7125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_665",
    "sat": "def sat(counts: List[int], target_prob: float=0.4533333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4533333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_666",
    "sat": "def sat(counts: List[int], target_prob: float=0.13258426966292136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13258426966292136):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_667",
    "sat": "def sat(counts: List[int], target_prob: float=0.018779342723004695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.018779342723004695):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_668",
    "sat": "def sat(counts: List[int], target_prob: float=0.04838709677419355):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04838709677419355):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_669",
    "sat": "def sat(counts: List[int], target_prob: float=0.3284671532846715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3284671532846715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_670",
    "sat": "def sat(counts: List[int], target_prob: float=0.05742574257425743):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05742574257425743):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_671",
    "sat": "def sat(counts: List[int], target_prob: float=0.0136986301369863):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0136986301369863):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_672",
    "sat": "def sat(counts: List[int], target_prob: float=0.9164420485175202):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9164420485175202):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_673",
    "sat": "def sat(counts: List[int], target_prob: float=0.8095238095238095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8095238095238095):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_674",
    "sat": "def sat(counts: List[int], target_prob: float=0.4463840399002494):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4463840399002494):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_675",
    "sat": "def sat(counts: List[int], target_prob: float=0.3670886075949367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3670886075949367):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_676",
    "sat": "def sat(counts: List[int], target_prob: float=0.7813121272365805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7813121272365805):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_677",
    "sat": "def sat(counts: List[int], target_prob: float=0.7979094076655052):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7979094076655052):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_678",
    "sat": "def sat(counts: List[int], target_prob: float=0.3553113553113553):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3553113553113553):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_679",
    "sat": "def sat(counts: List[int], target_prob: float=0.8484848484848485):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8484848484848485):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_680",
    "sat": "def sat(counts: List[int], target_prob: float=0.8766066838046273):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8766066838046273):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_681",
    "sat": "def sat(counts: List[int], target_prob: float=0.21161825726141079):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21161825726141079):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_682",
    "sat": "def sat(counts: List[int], target_prob: float=0.5084745762711864):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5084745762711864):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_683",
    "sat": "def sat(counts: List[int], target_prob: float=0.03690036900369004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.03690036900369004):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_684",
    "sat": "def sat(counts: List[int], target_prob: float=0.30357142857142855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30357142857142855):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_685",
    "sat": "def sat(counts: List[int], target_prob: float=0.45652173913043476):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45652173913043476):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_686",
    "sat": "def sat(counts: List[int], target_prob: float=0.15031055900621118):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15031055900621118):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_687",
    "sat": "def sat(counts: List[int], target_prob: float=0.12549019607843137):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12549019607843137):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_688",
    "sat": "def sat(counts: List[int], target_prob: float=0.17894736842105263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17894736842105263):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_689",
    "sat": "def sat(counts: List[int], target_prob: float=0.6190476190476191):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6190476190476191):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_690",
    "sat": "def sat(counts: List[int], target_prob: float=0.00631578947368421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.00631578947368421):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_691",
    "sat": "def sat(counts: List[int], target_prob: float=0.10043668122270742):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10043668122270742):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_692",
    "sat": "def sat(counts: List[int], target_prob: float=0.1282051282051282):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1282051282051282):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_693",
    "sat": "def sat(counts: List[int], target_prob: float=0.5737704918032787):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5737704918032787):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_694",
    "sat": "def sat(counts: List[int], target_prob: float=0.34615384615384615):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34615384615384615):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_695",
    "sat": "def sat(counts: List[int], target_prob: float=0.13513513513513514):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13513513513513514):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_696",
    "sat": "def sat(counts: List[int], target_prob: float=0.901565995525727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.901565995525727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_697",
    "sat": "def sat(counts: List[int], target_prob: float=0.045576407506702415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.045576407506702415):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_698",
    "sat": "def sat(counts: List[int], target_prob: float=0.31313131313131315):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31313131313131315):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_699",
    "sat": "def sat(counts: List[int], target_prob: float=0.39186991869918697):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39186991869918697):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_700",
    "sat": "def sat(counts: List[int], target_prob: float=0.40119760479041916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40119760479041916):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_701",
    "sat": "def sat(counts: List[int], target_prob: float=0.8963414634146342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8963414634146342):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_702",
    "sat": "def sat(counts: List[int], target_prob: float=0.296875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.296875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_703",
    "sat": "def sat(counts: List[int], target_prob: float=0.1048158640226629):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1048158640226629):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_704",
    "sat": "def sat(counts: List[int], target_prob: float=0.02030456852791878):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02030456852791878):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_705",
    "sat": "def sat(counts: List[int], target_prob: float=0.6222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_706",
    "sat": "def sat(counts: List[int], target_prob: float=0.08074534161490683):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08074534161490683):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_707",
    "sat": "def sat(counts: List[int], target_prob: float=0.17123287671232876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17123287671232876):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_708",
    "sat": "def sat(counts: List[int], target_prob: float=0.10153846153846154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10153846153846154):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_709",
    "sat": "def sat(counts: List[int], target_prob: float=0.23870967741935484):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23870967741935484):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_710",
    "sat": "def sat(counts: List[int], target_prob: float=0.06493506493506493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06493506493506493):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_711",
    "sat": "def sat(counts: List[int], target_prob: float=0.7631578947368421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7631578947368421):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_712",
    "sat": "def sat(counts: List[int], target_prob: float=0.20393120393120392):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20393120393120392):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_713",
    "sat": "def sat(counts: List[int], target_prob: float=0.13043478260869565):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13043478260869565):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_714",
    "sat": "def sat(counts: List[int], target_prob: float=0.1643835616438356):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1643835616438356):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_715",
    "sat": "def sat(counts: List[int], target_prob: float=0.5616438356164384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5616438356164384):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_716",
    "sat": "def sat(counts: List[int], target_prob: float=0.11764705882352941):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.11764705882352941):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_717",
    "sat": "def sat(counts: List[int], target_prob: float=0.5818639798488665):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5818639798488665):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_718",
    "sat": "def sat(counts: List[int], target_prob: float=0.9791666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9791666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_719",
    "sat": "def sat(counts: List[int], target_prob: float=0.660377358490566):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.660377358490566):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_720",
    "sat": "def sat(counts: List[int], target_prob: float=0.20353982300884957):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20353982300884957):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_721",
    "sat": "def sat(counts: List[int], target_prob: float=0.8309859154929577):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8309859154929577):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_722",
    "sat": "def sat(counts: List[int], target_prob: float=0.6451612903225806):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6451612903225806):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_723",
    "sat": "def sat(counts: List[int], target_prob: float=0.06756756756756757):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06756756756756757):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_724",
    "sat": "def sat(counts: List[int], target_prob: float=0.7528089887640449):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7528089887640449):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_725",
    "sat": "def sat(counts: List[int], target_prob: float=0.6821829855537721):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6821829855537721):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_726",
    "sat": "def sat(counts: List[int], target_prob: float=0.3559322033898305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3559322033898305):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_727",
    "sat": "def sat(counts: List[int], target_prob: float=0.6803418803418804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6803418803418804):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_728",
    "sat": "def sat(counts: List[int], target_prob: float=0.0893854748603352):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0893854748603352):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_729",
    "sat": "def sat(counts: List[int], target_prob: float=0.46292585170340683):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46292585170340683):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_730",
    "sat": "def sat(counts: List[int], target_prob: float=0.5151515151515151):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5151515151515151):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_731",
    "sat": "def sat(counts: List[int], target_prob: float=0.08602150537634409):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08602150537634409):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_732",
    "sat": "def sat(counts: List[int], target_prob: float=0.12691771269177127):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12691771269177127):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_733",
    "sat": "def sat(counts: List[int], target_prob: float=0.05785123966942149):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05785123966942149):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_734",
    "sat": "def sat(counts: List[int], target_prob: float=0.2616822429906542):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2616822429906542):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_735",
    "sat": "def sat(counts: List[int], target_prob: float=0.32571428571428573):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32571428571428573):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_736",
    "sat": "def sat(counts: List[int], target_prob: float=0.45893719806763283):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.45893719806763283):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_737",
    "sat": "def sat(counts: List[int], target_prob: float=0.046296296296296294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.046296296296296294):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_738",
    "sat": "def sat(counts: List[int], target_prob: float=0.012564671101256468):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.012564671101256468):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_739",
    "sat": "def sat(counts: List[int], target_prob: float=0.40350877192982454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.40350877192982454):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_740",
    "sat": "def sat(counts: List[int], target_prob: float=0.4587737843551797):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4587737843551797):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_741",
    "sat": "def sat(counts: List[int], target_prob: float=0.4025157232704403):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4025157232704403):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_742",
    "sat": "def sat(counts: List[int], target_prob: float=0.16989247311827957):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.16989247311827957):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_743",
    "sat": "def sat(counts: List[int], target_prob: float=0.3249370277078086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3249370277078086):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_744",
    "sat": "def sat(counts: List[int], target_prob: float=0.1794871794871795):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1794871794871795):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_745",
    "sat": "def sat(counts: List[int], target_prob: float=0.46808510638297873):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46808510638297873):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_746",
    "sat": "def sat(counts: List[int], target_prob: float=0.44881889763779526):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.44881889763779526):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_747",
    "sat": "def sat(counts: List[int], target_prob: float=0.23348017621145375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23348017621145375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_748",
    "sat": "def sat(counts: List[int], target_prob: float=0.29174311926605506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.29174311926605506):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_749",
    "sat": "def sat(counts: List[int], target_prob: float=0.07434944237918216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07434944237918216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_750",
    "sat": "def sat(counts: List[int], target_prob: float=0.23209169054441262):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23209169054441262):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_751",
    "sat": "def sat(counts: List[int], target_prob: float=0.2535885167464115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2535885167464115):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_752",
    "sat": "def sat(counts: List[int], target_prob: float=0.2019704433497537):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2019704433497537):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_753",
    "sat": "def sat(counts: List[int], target_prob: float=0.2956521739130435):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2956521739130435):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_754",
    "sat": "def sat(counts: List[int], target_prob: float=0.6464937560038425):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6464937560038425):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_755",
    "sat": "def sat(counts: List[int], target_prob: float=0.285958904109589):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.285958904109589):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_756",
    "sat": "def sat(counts: List[int], target_prob: float=0.026845637583892617):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.026845637583892617):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_757",
    "sat": "def sat(counts: List[int], target_prob: float=0.47560975609756095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47560975609756095):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_758",
    "sat": "def sat(counts: List[int], target_prob: float=0.7078651685393258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7078651685393258):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_759",
    "sat": "def sat(counts: List[int], target_prob: float=0.7250470809792844):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7250470809792844):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_760",
    "sat": "def sat(counts: List[int], target_prob: float=0.8274509803921568):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8274509803921568):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_761",
    "sat": "def sat(counts: List[int], target_prob: float=0.7714285714285715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7714285714285715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_762",
    "sat": "def sat(counts: List[int], target_prob: float=0.01876675603217158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01876675603217158):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_763",
    "sat": "def sat(counts: List[int], target_prob: float=0.19626168224299065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19626168224299065):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_764",
    "sat": "def sat(counts: List[int], target_prob: float=0.2884097035040431):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2884097035040431):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_765",
    "sat": "def sat(counts: List[int], target_prob: float=0.7619047619047619):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7619047619047619):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_766",
    "sat": "def sat(counts: List[int], target_prob: float=0.5245098039215687):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5245098039215687):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_767",
    "sat": "def sat(counts: List[int], target_prob: float=0.46296296296296297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46296296296296297):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_768",
    "sat": "def sat(counts: List[int], target_prob: float=0.09144542772861357):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09144542772861357):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_769",
    "sat": "def sat(counts: List[int], target_prob: float=0.014925373134328358):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.014925373134328358):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_770",
    "sat": "def sat(counts: List[int], target_prob: float=0.64):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.64):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_771",
    "sat": "def sat(counts: List[int], target_prob: float=0.32989690721649484):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32989690721649484):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_772",
    "sat": "def sat(counts: List[int], target_prob: float=0.00411522633744856):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.00411522633744856):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_773",
    "sat": "def sat(counts: List[int], target_prob: float=0.02832244008714597):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02832244008714597):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_774",
    "sat": "def sat(counts: List[int], target_prob: float=0.6701030927835051):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6701030927835051):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_775",
    "sat": "def sat(counts: List[int], target_prob: float=0.9832635983263598):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9832635983263598):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_776",
    "sat": "def sat(counts: List[int], target_prob: float=0.6766917293233082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6766917293233082):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_777",
    "sat": "def sat(counts: List[int], target_prob: float=0.25227568270481143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25227568270481143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_778",
    "sat": "def sat(counts: List[int], target_prob: float=0.6513761467889908):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6513761467889908):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_779",
    "sat": "def sat(counts: List[int], target_prob: float=0.5271411338962606):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5271411338962606):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_780",
    "sat": "def sat(counts: List[int], target_prob: float=0.47191011235955055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.47191011235955055):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_781",
    "sat": "def sat(counts: List[int], target_prob: float=0.24210526315789474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24210526315789474):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_782",
    "sat": "def sat(counts: List[int], target_prob: float=0.4671814671814672):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4671814671814672):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_783",
    "sat": "def sat(counts: List[int], target_prob: float=0.41683778234086244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.41683778234086244):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_784",
    "sat": "def sat(counts: List[int], target_prob: float=0.145478374836173):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.145478374836173):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_785",
    "sat": "def sat(counts: List[int], target_prob: float=0.7906976744186046):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7906976744186046):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_786",
    "sat": "def sat(counts: List[int], target_prob: float=0.4244604316546763):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4244604316546763):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_787",
    "sat": "def sat(counts: List[int], target_prob: float=0.2391653290529695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2391653290529695):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_788",
    "sat": "def sat(counts: List[int], target_prob: float=0.9148936170212766):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9148936170212766):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_789",
    "sat": "def sat(counts: List[int], target_prob: float=0.8865671641791045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8865671641791045):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_790",
    "sat": "def sat(counts: List[int], target_prob: float=0.31049250535331907):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31049250535331907):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_791",
    "sat": "def sat(counts: List[int], target_prob: float=0.22448979591836735):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22448979591836735):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_792",
    "sat": "def sat(counts: List[int], target_prob: float=0.1134020618556701):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1134020618556701):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_793",
    "sat": "def sat(counts: List[int], target_prob: float=0.8245614035087719):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8245614035087719):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_794",
    "sat": "def sat(counts: List[int], target_prob: float=0.625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_795",
    "sat": "def sat(counts: List[int], target_prob: float=0.2608695652173913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2608695652173913):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_796",
    "sat": "def sat(counts: List[int], target_prob: float=0.036734693877551024):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.036734693877551024):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_797",
    "sat": "def sat(counts: List[int], target_prob: float=0.2391304347826087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2391304347826087):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_798",
    "sat": "def sat(counts: List[int], target_prob: float=0.048728813559322036):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.048728813559322036):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_799",
    "sat": "def sat(counts: List[int], target_prob: float=0.2485207100591716):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2485207100591716):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_800",
    "sat": "def sat(counts: List[int], target_prob: float=0.3551020408163265):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3551020408163265):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_801",
    "sat": "def sat(counts: List[int], target_prob: float=0.06741573033707865):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06741573033707865):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_802",
    "sat": "def sat(counts: List[int], target_prob: float=0.05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_803",
    "sat": "def sat(counts: List[int], target_prob: float=0.36316695352839934):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36316695352839934):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_804",
    "sat": "def sat(counts: List[int], target_prob: float=0.5934426229508196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5934426229508196):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_805",
    "sat": "def sat(counts: List[int], target_prob: float=0.13268608414239483):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13268608414239483):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_806",
    "sat": "def sat(counts: List[int], target_prob: float=0.21089297023432552):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21089297023432552):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_807",
    "sat": "def sat(counts: List[int], target_prob: float=0.07142857142857142):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07142857142857142):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_808",
    "sat": "def sat(counts: List[int], target_prob: float=0.1232876712328767):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1232876712328767):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_809",
    "sat": "def sat(counts: List[int], target_prob: float=0.21511627906976744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21511627906976744):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_810",
    "sat": "def sat(counts: List[int], target_prob: float=0.5542452830188679):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5542452830188679):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_811",
    "sat": "def sat(counts: List[int], target_prob: float=0.5431472081218274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5431472081218274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_812",
    "sat": "def sat(counts: List[int], target_prob: float=0.5950920245398773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5950920245398773):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_813",
    "sat": "def sat(counts: List[int], target_prob: float=0.3684210526315789):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3684210526315789):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_814",
    "sat": "def sat(counts: List[int], target_prob: float=0.5102040816326531):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5102040816326531):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_815",
    "sat": "def sat(counts: List[int], target_prob: float=0.3429718875502008):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3429718875502008):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_816",
    "sat": "def sat(counts: List[int], target_prob: float=0.6864):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6864):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_817",
    "sat": "def sat(counts: List[int], target_prob: float=0.8032786885245902):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8032786885245902):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_818",
    "sat": "def sat(counts: List[int], target_prob: float=0.06264501160092807):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06264501160092807):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_819",
    "sat": "def sat(counts: List[int], target_prob: float=0.39655172413793105):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.39655172413793105):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_820",
    "sat": "def sat(counts: List[int], target_prob: float=0.09866666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09866666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_821",
    "sat": "def sat(counts: List[int], target_prob: float=0.02702702702702703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.02702702702702703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_822",
    "sat": "def sat(counts: List[int], target_prob: float=0.3805309734513274):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3805309734513274):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_823",
    "sat": "def sat(counts: List[int], target_prob: float=0.6056338028169014):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6056338028169014):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_824",
    "sat": "def sat(counts: List[int], target_prob: float=0.050724637681159424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.050724637681159424):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_825",
    "sat": "def sat(counts: List[int], target_prob: float=0.7):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_826",
    "sat": "def sat(counts: List[int], target_prob: float=0.9288888888888889):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9288888888888889):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_827",
    "sat": "def sat(counts: List[int], target_prob: float=0.8690476190476191):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8690476190476191):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_828",
    "sat": "def sat(counts: List[int], target_prob: float=0.014084507042253521):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.014084507042253521):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_829",
    "sat": "def sat(counts: List[int], target_prob: float=0.6521739130434783):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6521739130434783):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_830",
    "sat": "def sat(counts: List[int], target_prob: float=0.3064516129032258):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3064516129032258):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_831",
    "sat": "def sat(counts: List[int], target_prob: float=0.68):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.68):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_832",
    "sat": "def sat(counts: List[int], target_prob: float=0.42771084337349397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.42771084337349397):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_833",
    "sat": "def sat(counts: List[int], target_prob: float=0.8697674418604651):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8697674418604651):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_834",
    "sat": "def sat(counts: List[int], target_prob: float=0.07079646017699115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07079646017699115):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_835",
    "sat": "def sat(counts: List[int], target_prob: float=0.90625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.90625):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_836",
    "sat": "def sat(counts: List[int], target_prob: float=0.345679012345679):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.345679012345679):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_837",
    "sat": "def sat(counts: List[int], target_prob: float=0.06397306397306397):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06397306397306397):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_838",
    "sat": "def sat(counts: List[int], target_prob: float=0.46122448979591835):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.46122448979591835):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_839",
    "sat": "def sat(counts: List[int], target_prob: float=0.23031496062992127):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23031496062992127):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_840",
    "sat": "def sat(counts: List[int], target_prob: float=0.12965050732807215):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.12965050732807215):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_841",
    "sat": "def sat(counts: List[int], target_prob: float=0.49473684210526314):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49473684210526314):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_842",
    "sat": "def sat(counts: List[int], target_prob: float=0.6727272727272727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6727272727272727):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_843",
    "sat": "def sat(counts: List[int], target_prob: float=0.8077858880778589):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8077858880778589):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_844",
    "sat": "def sat(counts: List[int], target_prob: float=0.6323119777158774):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6323119777158774):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_845",
    "sat": "def sat(counts: List[int], target_prob: float=0.22365988909426987):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.22365988909426987):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_846",
    "sat": "def sat(counts: List[int], target_prob: float=0.3894736842105263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3894736842105263):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_847",
    "sat": "def sat(counts: List[int], target_prob: float=0.8947368421052632):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8947368421052632):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_848",
    "sat": "def sat(counts: List[int], target_prob: float=0.8561151079136691):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8561151079136691):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_849",
    "sat": "def sat(counts: List[int], target_prob: float=0.7333333333333333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7333333333333333):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_850",
    "sat": "def sat(counts: List[int], target_prob: float=0.4296577946768061):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4296577946768061):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_851",
    "sat": "def sat(counts: List[int], target_prob: float=0.1365079365079365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1365079365079365):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_852",
    "sat": "def sat(counts: List[int], target_prob: float=0.2199630314232902):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2199630314232902):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_853",
    "sat": "def sat(counts: List[int], target_prob: float=0.6787564766839378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6787564766839378):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_854",
    "sat": "def sat(counts: List[int], target_prob: float=0.6397058823529411):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6397058823529411):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_855",
    "sat": "def sat(counts: List[int], target_prob: float=0.5389408099688473):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5389408099688473):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_856",
    "sat": "def sat(counts: List[int], target_prob: float=0.35135135135135137):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35135135135135137):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_857",
    "sat": "def sat(counts: List[int], target_prob: float=0.31958762886597936):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.31958762886597936):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_858",
    "sat": "def sat(counts: List[int], target_prob: float=0.4225352112676056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4225352112676056):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_859",
    "sat": "def sat(counts: List[int], target_prob: float=0.6690647482014388):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6690647482014388):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_860",
    "sat": "def sat(counts: List[int], target_prob: float=0.6183745583038869):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6183745583038869):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_861",
    "sat": "def sat(counts: List[int], target_prob: float=0.30526315789473685):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30526315789473685):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_862",
    "sat": "def sat(counts: List[int], target_prob: float=0.043076923076923075):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.043076923076923075):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_863",
    "sat": "def sat(counts: List[int], target_prob: float=0.49624060150375937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.49624060150375937):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_864",
    "sat": "def sat(counts: List[int], target_prob: float=0.35384615384615387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.35384615384615387):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_865",
    "sat": "def sat(counts: List[int], target_prob: float=0.3):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_866",
    "sat": "def sat(counts: List[int], target_prob: float=0.7222222222222222):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7222222222222222):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_867",
    "sat": "def sat(counts: List[int], target_prob: float=0.36363636363636365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36363636363636365):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_868",
    "sat": "def sat(counts: List[int], target_prob: float=0.3858267716535433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3858267716535433):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_869",
    "sat": "def sat(counts: List[int], target_prob: float=0.723404255319149):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.723404255319149):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_870",
    "sat": "def sat(counts: List[int], target_prob: float=0.7168949771689498):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7168949771689498):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_871",
    "sat": "def sat(counts: List[int], target_prob: float=0.4336283185840708):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4336283185840708):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_872",
    "sat": "def sat(counts: List[int], target_prob: float=0.7939914163090128):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7939914163090128):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_873",
    "sat": "def sat(counts: List[int], target_prob: float=0.5722679200940071):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5722679200940071):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_874",
    "sat": "def sat(counts: List[int], target_prob: float=0.9706959706959707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9706959706959707):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_875",
    "sat": "def sat(counts: List[int], target_prob: float=0.175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.175):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_876",
    "sat": "def sat(counts: List[int], target_prob: float=0.7509578544061303):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7509578544061303):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_877",
    "sat": "def sat(counts: List[int], target_prob: float=0.577639751552795):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.577639751552795):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_878",
    "sat": "def sat(counts: List[int], target_prob: float=0.2914046121593291):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2914046121593291):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_879",
    "sat": "def sat(counts: List[int], target_prob: float=0.024390243902439025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.024390243902439025):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_880",
    "sat": "def sat(counts: List[int], target_prob: float=0.6242038216560509):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6242038216560509):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_881",
    "sat": "def sat(counts: List[int], target_prob: float=0.19555555555555557):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.19555555555555557):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_882",
    "sat": "def sat(counts: List[int], target_prob: float=0.28484848484848485):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.28484848484848485):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_883",
    "sat": "def sat(counts: List[int], target_prob: float=0.6369982547993019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6369982547993019):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_884",
    "sat": "def sat(counts: List[int], target_prob: float=0.3224932249322493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3224932249322493):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_885",
    "sat": "def sat(counts: List[int], target_prob: float=0.391304347826087):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.391304347826087):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_886",
    "sat": "def sat(counts: List[int], target_prob: float=0.9242424242424242):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9242424242424242):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_887",
    "sat": "def sat(counts: List[int], target_prob: float=0.7105263157894737):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7105263157894737):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_888",
    "sat": "def sat(counts: List[int], target_prob: float=0.5981941309255079):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5981941309255079):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_889",
    "sat": "def sat(counts: List[int], target_prob: float=0.993103448275862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.993103448275862):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_890",
    "sat": "def sat(counts: List[int], target_prob: float=0.38317757009345793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38317757009345793):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_891",
    "sat": "def sat(counts: List[int], target_prob: float=0.01718213058419244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.01718213058419244):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_892",
    "sat": "def sat(counts: List[int], target_prob: float=0.4601226993865031):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4601226993865031):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_893",
    "sat": "def sat(counts: List[int], target_prob: float=0.4188034188034188):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4188034188034188):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_894",
    "sat": "def sat(counts: List[int], target_prob: float=0.24609375):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24609375):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_895",
    "sat": "def sat(counts: List[int], target_prob: float=0.935064935064935):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.935064935064935):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_896",
    "sat": "def sat(counts: List[int], target_prob: float=0.9156908665105387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9156908665105387):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_897",
    "sat": "def sat(counts: List[int], target_prob: float=0.5932203389830508):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5932203389830508):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_898",
    "sat": "def sat(counts: List[int], target_prob: float=0.5247524752475248):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5247524752475248):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_899",
    "sat": "def sat(counts: List[int], target_prob: float=0.20147874306839186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.20147874306839186):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_900",
    "sat": "def sat(counts: List[int], target_prob: float=0.8076545632973503):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8076545632973503):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_901",
    "sat": "def sat(counts: List[int], target_prob: float=0.07210031347962383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07210031347962383):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_902",
    "sat": "def sat(counts: List[int], target_prob: float=0.06280193236714976):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06280193236714976):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_903",
    "sat": "def sat(counts: List[int], target_prob: float=0.4948453608247423):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4948453608247423):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_904",
    "sat": "def sat(counts: List[int], target_prob: float=0.3402061855670103):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3402061855670103):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_905",
    "sat": "def sat(counts: List[int], target_prob: float=0.8421052631578947):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8421052631578947):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_906",
    "sat": "def sat(counts: List[int], target_prob: float=0.8684807256235828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8684807256235828):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_907",
    "sat": "def sat(counts: List[int], target_prob: float=0.3738019169329074):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3738019169329074):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_908",
    "sat": "def sat(counts: List[int], target_prob: float=0.6629213483146067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6629213483146067):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_909",
    "sat": "def sat(counts: List[int], target_prob: float=0.15692307692307692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15692307692307692):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_910",
    "sat": "def sat(counts: List[int], target_prob: float=0.71875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.71875):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_911",
    "sat": "def sat(counts: List[int], target_prob: float=0.21981424148606812):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21981424148606812):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_912",
    "sat": "def sat(counts: List[int], target_prob: float=0.0743801652892562):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.0743801652892562):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_913",
    "sat": "def sat(counts: List[int], target_prob: float=0.15447154471544716):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15447154471544716):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_914",
    "sat": "def sat(counts: List[int], target_prob: float=0.05263157894736842):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05263157894736842):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_915",
    "sat": "def sat(counts: List[int], target_prob: float=0.2509505703422053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2509505703422053):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_916",
    "sat": "def sat(counts: List[int], target_prob: float=0.3498233215547703):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3498233215547703):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_917",
    "sat": "def sat(counts: List[int], target_prob: float=0.018691588785046728):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.018691588785046728):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_918",
    "sat": "def sat(counts: List[int], target_prob: float=0.08315565031982942):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08315565031982942):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_919",
    "sat": "def sat(counts: List[int], target_prob: float=0.015384615384615385):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.015384615384615385):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_920",
    "sat": "def sat(counts: List[int], target_prob: float=0.6538461538461539):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6538461538461539):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_921",
    "sat": "def sat(counts: List[int], target_prob: float=0.3087557603686636):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3087557603686636):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_922",
    "sat": "def sat(counts: List[int], target_prob: float=0.30434782608695654):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.30434782608695654):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_923",
    "sat": "def sat(counts: List[int], target_prob: float=0.24288107202680068):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.24288107202680068):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_924",
    "sat": "def sat(counts: List[int], target_prob: float=0.3409090909090909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3409090909090909):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_925",
    "sat": "def sat(counts: List[int], target_prob: float=0.639344262295082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.639344262295082):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_926",
    "sat": "def sat(counts: List[int], target_prob: float=0.014545454545454545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.014545454545454545):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_927",
    "sat": "def sat(counts: List[int], target_prob: float=0.4909090909090909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4909090909090909):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_928",
    "sat": "def sat(counts: List[int], target_prob: float=0.9672131147540983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9672131147540983):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_929",
    "sat": "def sat(counts: List[int], target_prob: float=0.6376811594202898):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6376811594202898):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_930",
    "sat": "def sat(counts: List[int], target_prob: float=0.9902439024390244):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9902439024390244):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_931",
    "sat": "def sat(counts: List[int], target_prob: float=0.2570093457943925):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2570093457943925):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_932",
    "sat": "def sat(counts: List[int], target_prob: float=0.38016528925619836):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.38016528925619836):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_933",
    "sat": "def sat(counts: List[int], target_prob: float=0.4152542372881356):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4152542372881356):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_934",
    "sat": "def sat(counts: List[int], target_prob: float=0.4479553903345725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4479553903345725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_935",
    "sat": "def sat(counts: List[int], target_prob: float=0.3497942386831276):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3497942386831276):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_936",
    "sat": "def sat(counts: List[int], target_prob: float=0.851063829787234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.851063829787234):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_937",
    "sat": "def sat(counts: List[int], target_prob: float=0.10510510510510511):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.10510510510510511):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_938",
    "sat": "def sat(counts: List[int], target_prob: float=0.3723076923076923):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3723076923076923):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_939",
    "sat": "def sat(counts: List[int], target_prob: float=0.049429657794676805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.049429657794676805):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_940",
    "sat": "def sat(counts: List[int], target_prob: float=0.1568627450980392):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1568627450980392):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_941",
    "sat": "def sat(counts: List[int], target_prob: float=0.206266318537859):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.206266318537859):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_942",
    "sat": "def sat(counts: List[int], target_prob: float=0.08029197080291971):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08029197080291971):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_943",
    "sat": "def sat(counts: List[int], target_prob: float=0.6805555555555556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6805555555555556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_944",
    "sat": "def sat(counts: List[int], target_prob: float=0.36752136752136755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36752136752136755):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_945",
    "sat": "def sat(counts: List[int], target_prob: float=0.25):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.25):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_946",
    "sat": "def sat(counts: List[int], target_prob: float=0.8235294117647058):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8235294117647058):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_947",
    "sat": "def sat(counts: List[int], target_prob: float=0.14594594594594595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14594594594594595):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_948",
    "sat": "def sat(counts: List[int], target_prob: float=0.23297491039426524):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.23297491039426524):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_949",
    "sat": "def sat(counts: List[int], target_prob: float=0.6595041322314049):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6595041322314049):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_950",
    "sat": "def sat(counts: List[int], target_prob: float=0.05426356589147287):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.05426356589147287):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_951",
    "sat": "def sat(counts: List[int], target_prob: float=0.700374531835206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.700374531835206):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_952",
    "sat": "def sat(counts: List[int], target_prob: float=0.43859649122807015):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43859649122807015):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_953",
    "sat": "def sat(counts: List[int], target_prob: float=0.9166666666666666):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9166666666666666):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_954",
    "sat": "def sat(counts: List[int], target_prob: float=0.14826498422712933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14826498422712933):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_955",
    "sat": "def sat(counts: List[int], target_prob: float=0.7101910828025477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7101910828025477):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_956",
    "sat": "def sat(counts: List[int], target_prob: float=0.5216216216216216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5216216216216216):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_957",
    "sat": "def sat(counts: List[int], target_prob: float=0.9072847682119205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9072847682119205):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_958",
    "sat": "def sat(counts: List[int], target_prob: float=0.4260869565217391):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4260869565217391):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_959",
    "sat": "def sat(counts: List[int], target_prob: float=0.3125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.3125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_960",
    "sat": "def sat(counts: List[int], target_prob: float=0.08015267175572519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08015267175572519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_961",
    "sat": "def sat(counts: List[int], target_prob: float=0.6941176470588235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6941176470588235):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_962",
    "sat": "def sat(counts: List[int], target_prob: float=0.43333333333333335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.43333333333333335):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_963",
    "sat": "def sat(counts: List[int], target_prob: float=0.8848167539267016):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.8848167539267016):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_964",
    "sat": "def sat(counts: List[int], target_prob: float=0.08108108108108109):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.08108108108108109):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_965",
    "sat": "def sat(counts: List[int], target_prob: float=0.5714285714285714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5714285714285714):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_966",
    "sat": "def sat(counts: List[int], target_prob: float=0.2170212765957447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.2170212765957447):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_967",
    "sat": "def sat(counts: List[int], target_prob: float=0.9638009049773756):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9638009049773756):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_968",
    "sat": "def sat(counts: List[int], target_prob: float=0.07958477508650519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.07958477508650519):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_969",
    "sat": "def sat(counts: List[int], target_prob: float=0.9452054794520548):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.9452054794520548):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_970",
    "sat": "def sat(counts: List[int], target_prob: float=0.5122838944494995):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5122838944494995):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_971",
    "sat": "def sat(counts: List[int], target_prob: float=0.15527950310559005):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.15527950310559005):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_972",
    "sat": "def sat(counts: List[int], target_prob: float=0.21212121212121213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.21212121212121213):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_973",
    "sat": "def sat(counts: List[int], target_prob: float=0.5915985997666278):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5915985997666278):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_974",
    "sat": "def sat(counts: List[int], target_prob: float=0.6713286713286714):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6713286713286714):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_975",
    "sat": "def sat(counts: List[int], target_prob: float=0.14071294559099437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14071294559099437):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_976",
    "sat": "def sat(counts: List[int], target_prob: float=0.04225352112676056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04225352112676056):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_977",
    "sat": "def sat(counts: List[int], target_prob: float=0.1712538226299694):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1712538226299694):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_978",
    "sat": "def sat(counts: List[int], target_prob: float=0.04):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.04):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_979",
    "sat": "def sat(counts: List[int], target_prob: float=0.4362934362934363):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4362934362934363):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_980",
    "sat": "def sat(counts: List[int], target_prob: float=0.6517857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6517857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_981",
    "sat": "def sat(counts: List[int], target_prob: float=0.7760617760617761):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.7760617760617761):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_982",
    "sat": "def sat(counts: List[int], target_prob: float=0.6553398058252428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.6553398058252428):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_983",
    "sat": "def sat(counts: List[int], target_prob: float=0.4861111111111111):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4861111111111111):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_984",
    "sat": "def sat(counts: List[int], target_prob: float=0.26905829596412556):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.26905829596412556):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_985",
    "sat": "def sat(counts: List[int], target_prob: float=0.17142857142857143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.17142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_986",
    "sat": "def sat(counts: List[int], target_prob: float=0.34306569343065696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.34306569343065696):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_987",
    "sat": "def sat(counts: List[int], target_prob: float=0.1267605633802817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.1267605633802817):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_988",
    "sat": "def sat(counts: List[int], target_prob: float=0.4666666666666667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4666666666666667):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_989",
    "sat": "def sat(counts: List[int], target_prob: float=0.348):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.348):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_990",
    "sat": "def sat(counts: List[int], target_prob: float=0.06521739130434782):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.06521739130434782):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_991",
    "sat": "def sat(counts: List[int], target_prob: float=0.325):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.325):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_992",
    "sat": "def sat(counts: List[int], target_prob: float=0.32972972972972975):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.32972972972972975):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_993",
    "sat": "def sat(counts: List[int], target_prob: float=0.4294573643410853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.4294573643410853):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_994",
    "sat": "def sat(counts: List[int], target_prob: float=0.962059620596206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.962059620596206):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_995",
    "sat": "def sat(counts: List[int], target_prob: float=0.13714285714285715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.13714285714285715):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_996",
    "sat": "def sat(counts: List[int], target_prob: float=0.36727272727272725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.36727272727272725):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_997",
    "sat": "def sat(counts: List[int], target_prob: float=0.14093959731543623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.14093959731543623):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_998",
    "sat": "def sat(counts: List[int], target_prob: float=0.09774436090225563):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.09774436090225563):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BallotProblem_999",
    "sat": "def sat(counts: List[int], target_prob: float=0.5964912280701754):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "sols": [
      "def sol(target_prob=0.5964912280701754):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ]
  },
  {
    "name": "BinomialProbabilities_0",
    "sat": "def sat(counts: List[int], p: float=0.5, target_prob: float=0.0625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5, target_prob=0.0625):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_1",
    "sat": "def sat(counts: List[int], p: float=0.41409343481407657, target_prob: float=0.5859065651859234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41409343481407657, target_prob=0.5859065651859234):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_2",
    "sat": "def sat(counts: List[int], p: float=0.44988724294487226, target_prob: float=0.4949774231606675):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44988724294487226, target_prob=0.4949774231606675):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_3",
    "sat": "def sat(counts: List[int], p: float=0.0891376737959737, target_prob: float=4.4712512394951255e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0891376737959737, target_prob=4.4712512394951255e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_4",
    "sat": "def sat(counts: List[int], p: float=0.22245375340163231, target_prob: float=0.04948567240247424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22245375340163231, target_prob=0.04948567240247424):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_5",
    "sat": "def sat(counts: List[int], p: float=0.16630127396334493, target_prob: float=1.82976534893595e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16630127396334493, target_prob=1.82976534893595e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_6",
    "sat": "def sat(counts: List[int], p: float=0.31903948796620407, target_prob: float=0.03247381549709785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31903948796620407, target_prob=0.03247381549709785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_7",
    "sat": "def sat(counts: List[int], p: float=0.061342203040559706, target_prob: float=1.4159159584729811e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.061342203040559706, target_prob=1.4159159584729811e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_8",
    "sat": "def sat(counts: List[int], p: float=0.4251415150249188, target_prob: float=0.18074530779768327):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4251415150249188, target_prob=0.18074530779768327):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_9",
    "sat": "def sat(counts: List[int], p: float=0.5984613901460974, target_prob: float=0.04203336626485389):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5984613901460974, target_prob=0.04203336626485389):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_10",
    "sat": "def sat(counts: List[int], p: float=0.0073621723701732256, target_prob: float=0.021762504742639265):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0073621723701732256, target_prob=0.021762504742639265):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_11",
    "sat": "def sat(counts: List[int], p: float=0.6905664230674393, target_prob: float=0.11227033526779076):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6905664230674393, target_prob=0.11227033526779076):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_12",
    "sat": "def sat(counts: List[int], p: float=0.9569265318462092, target_prob: float=4.728112662681059e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9569265318462092, target_prob=4.728112662681059e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_13",
    "sat": "def sat(counts: List[int], p: float=0.36112066154012346, target_prob: float=0.004093315230434317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36112066154012346, target_prob=0.004093315230434317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_14",
    "sat": "def sat(counts: List[int], p: float=0.7953560183393737, target_prob: float=7.345034879408848e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7953560183393737, target_prob=7.345034879408848e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_15",
    "sat": "def sat(counts: List[int], p: float=0.5674208704181687, target_prob: float=0.19784249475997862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5674208704181687, target_prob=0.19784249475997862):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_16",
    "sat": "def sat(counts: List[int], p: float=0.6488749716397589, target_prob: float=0.08165448276812834):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6488749716397589, target_prob=0.08165448276812834):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_17",
    "sat": "def sat(counts: List[int], p: float=0.5125452830211126, target_prob: float=0.5125452830211126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5125452830211126, target_prob=0.5125452830211126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_18",
    "sat": "def sat(counts: List[int], p: float=0.8850182045941886, target_prob: float=0.021075304845193002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8850182045941886, target_prob=0.021075304845193002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_19",
    "sat": "def sat(counts: List[int], p: float=0.8569046795966825, target_prob: float=0.03485909497581417):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8569046795966825, target_prob=0.03485909497581417):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_20",
    "sat": "def sat(counts: List[int], p: float=0.04526972458480294, target_prob: float=0.23998829505970098):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04526972458480294, target_prob=0.23998829505970098):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_21",
    "sat": "def sat(counts: List[int], p: float=0.9853712235983894, target_prob: float=3.039651232663248e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9853712235983894, target_prob=3.039651232663248e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_22",
    "sat": "def sat(counts: List[int], p: float=0.49966743727315466, target_prob: float=0.000970086540848379):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49966743727315466, target_prob=0.000970086540848379):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_23",
    "sat": "def sat(counts: List[int], p: float=0.7086642526173739, target_prob: float=0.003033201243794785):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7086642526173739, target_prob=0.003033201243794785):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_24",
    "sat": "def sat(counts: List[int], p: float=0.2761217982023567, target_prob: float=0.7238782017976433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2761217982023567, target_prob=0.7238782017976433):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_25",
    "sat": "def sat(counts: List[int], p: float=0.041284438182926375, target_prob: float=4.951288967440196e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.041284438182926375, target_prob=4.951288967440196e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_26",
    "sat": "def sat(counts: List[int], p: float=0.8029454153866972, target_prob: float=0.04387208806728875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8029454153866972, target_prob=0.04387208806728875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_27",
    "sat": "def sat(counts: List[int], p: float=0.39370684478260465, target_prob: float=0.04358298308586478):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39370684478260465, target_prob=0.04358298308586478):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_28",
    "sat": "def sat(counts: List[int], p: float=0.006185808499785117, target_prob: float=0.030170829580649625):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.006185808499785117, target_prob=0.030170829580649625):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_29",
    "sat": "def sat(counts: List[int], p: float=0.871120959377773, target_prob: float=0.128879040622227):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.871120959377773, target_prob=0.128879040622227):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_30",
    "sat": "def sat(counts: List[int], p: float=0.8052808911045336, target_prob: float=0.16911781856304678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8052808911045336, target_prob=0.16911781856304678):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_31",
    "sat": "def sat(counts: List[int], p: float=0.5796975645666564, target_prob: float=0.06546472970184804):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5796975645666564, target_prob=0.06546472970184804):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_32",
    "sat": "def sat(counts: List[int], p: float=0.22399567599073922, target_prob: float=0.20614985694609614):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22399567599073922, target_prob=0.20614985694609614):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_33",
    "sat": "def sat(counts: List[int], p: float=0.6674581452788697, target_prob: float=0.11058408514136933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6674581452788697, target_prob=0.11058408514136933):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_34",
    "sat": "def sat(counts: List[int], p: float=0.9855800461494876, target_prob: float=7.412377115537304e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9855800461494876, target_prob=7.412377115537304e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_35",
    "sat": "def sat(counts: List[int], p: float=0.28968593905238504, target_prob: float=0.32044074853172905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.28968593905238504, target_prob=0.32044074853172905):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_36",
    "sat": "def sat(counts: List[int], p: float=0.8690932650346597, target_prob: float=0.22754032341210895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8690932650346597, target_prob=0.22754032341210895):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_37",
    "sat": "def sat(counts: List[int], p: float=0.08768993469934938, target_prob: float=9.062603109747077e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08768993469934938, target_prob=9.062603109747077e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_38",
    "sat": "def sat(counts: List[int], p: float=0.5986776453525569, target_prob: float=0.4315197625714623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5986776453525569, target_prob=0.4315197625714623):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_39",
    "sat": "def sat(counts: List[int], p: float=0.23105564640317577, target_prob: float=4.336764709396533e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23105564640317577, target_prob=4.336764709396533e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_40",
    "sat": "def sat(counts: List[int], p: float=0.7935702103400544, target_prob: float=0.10144983648358454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7935702103400544, target_prob=0.10144983648358454):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_41",
    "sat": "def sat(counts: List[int], p: float=0.6358351696002601, target_prob: float=0.005627112713637394):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6358351696002601, target_prob=0.005627112713637394):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_42",
    "sat": "def sat(counts: List[int], p: float=0.11328239674900731, target_prob: float=0.0314555042873885):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11328239674900731, target_prob=0.0314555042873885):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_43",
    "sat": "def sat(counts: List[int], p: float=0.2768241059656019, target_prob: float=0.24046227115711924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2768241059656019, target_prob=0.24046227115711924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_44",
    "sat": "def sat(counts: List[int], p: float=0.9595016474577076, target_prob: float=0.005967788032869996):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9595016474577076, target_prob=0.005967788032869996):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_45",
    "sat": "def sat(counts: List[int], p: float=0.7787783253523424, target_prob: float=0.06566149076571404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7787783253523424, target_prob=0.06566149076571404):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_46",
    "sat": "def sat(counts: List[int], p: float=0.6150144682405924, target_prob: float=0.1101706895077931):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6150144682405924, target_prob=0.1101706895077931):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_47",
    "sat": "def sat(counts: List[int], p: float=0.23707471742798492, target_prob: float=0.4139715645606515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23707471742798492, target_prob=0.4139715645606515):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_48",
    "sat": "def sat(counts: List[int], p: float=0.988546623800019, target_prob: float=0.9440299785885073):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.988546623800019, target_prob=0.9440299785885073):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_49",
    "sat": "def sat(counts: List[int], p: float=0.185364567608035, target_prob: float=0.185364567608035):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.185364567608035, target_prob=0.185364567608035):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_50",
    "sat": "def sat(counts: List[int], p: float=0.3986629141354604, target_prob: float=0.6013370858645396):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3986629141354604, target_prob=0.6013370858645396):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_51",
    "sat": "def sat(counts: List[int], p: float=0.2878669329437661, target_prob: float=0.08286737108245072):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2878669329437661, target_prob=0.08286737108245072):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_52",
    "sat": "def sat(counts: List[int], p: float=0.8634046837605163, target_prob: float=0.3932412425177143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8634046837605163, target_prob=0.3932412425177143):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_53",
    "sat": "def sat(counts: List[int], p: float=0.6404823889801118, target_prob: float=0.12925291263344765):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6404823889801118, target_prob=0.12925291263344765):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_54",
    "sat": "def sat(counts: List[int], p: float=0.7277753591796958, target_prob: float=0.076917373235482):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7277753591796958, target_prob=0.076917373235482):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_55",
    "sat": "def sat(counts: List[int], p: float=0.28898393403359846, target_prob: float=0.7110160659664015):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.28898393403359846, target_prob=0.7110160659664015):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_56",
    "sat": "def sat(counts: List[int], p: float=0.7908878612665127, target_prob: float=0.30943864429764084):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7908878612665127, target_prob=0.30943864429764084):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_57",
    "sat": "def sat(counts: List[int], p: float=0.6592139918454532, target_prob: float=0.6592139918454532):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6592139918454532, target_prob=0.6592139918454532):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_58",
    "sat": "def sat(counts: List[int], p: float=0.8180951370749211, target_prob: float=0.04028473863878916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8180951370749211, target_prob=0.04028473863878916):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_59",
    "sat": "def sat(counts: List[int], p: float=0.584412444202406, target_prob: float=0.3539282509355479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.584412444202406, target_prob=0.3539282509355479):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_60",
    "sat": "def sat(counts: List[int], p: float=0.3451019708413896, target_prob: float=0.2723727811934936):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3451019708413896, target_prob=0.2723727811934936):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_61",
    "sat": "def sat(counts: List[int], p: float=0.5911584671254752, target_prob: float=0.1321523254317915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5911584671254752, target_prob=0.1321523254317915):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_62",
    "sat": "def sat(counts: List[int], p: float=0.486029502404847, target_prob: float=0.21602249009100286):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.486029502404847, target_prob=0.21602249009100286):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_63",
    "sat": "def sat(counts: List[int], p: float=0.32643849976703987, target_prob: float=0.005705366335615444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32643849976703987, target_prob=0.005705366335615444):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_64",
    "sat": "def sat(counts: List[int], p: float=0.9226373241864367, target_prob: float=1.2241690216291476e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9226373241864367, target_prob=1.2241690216291476e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_65",
    "sat": "def sat(counts: List[int], p: float=0.21820366265388746, target_prob: float=0.11167062800493052):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21820366265388746, target_prob=0.11167062800493052):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_66",
    "sat": "def sat(counts: List[int], p: float=0.9670851664417363, target_prob: float=0.9352537191516407):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9670851664417363, target_prob=0.9352537191516407):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_67",
    "sat": "def sat(counts: List[int], p: float=0.614982827130387, target_prob: float=0.385017172869613):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.614982827130387, target_prob=0.385017172869613):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_68",
    "sat": "def sat(counts: List[int], p: float=0.03438218439851648, target_prob: float=0.0007318906531345111):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03438218439851648, target_prob=0.0007318906531345111):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_69",
    "sat": "def sat(counts: List[int], p: float=0.3346624751218631, target_prob: float=0.3942693934770437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3346624751218631, target_prob=0.3942693934770437):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_70",
    "sat": "def sat(counts: List[int], p: float=0.11213800991275502, target_prob: float=0.0007019834064234891):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11213800991275502, target_prob=0.0007019834064234891):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_71",
    "sat": "def sat(counts: List[int], p: float=0.8111342731193805, target_prob: float=0.0868001180407841):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8111342731193805, target_prob=0.0868001180407841):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_72",
    "sat": "def sat(counts: List[int], p: float=0.22420950926555927, target_prob: float=0.34787921044091275):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22420950926555927, target_prob=0.34787921044091275):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_73",
    "sat": "def sat(counts: List[int], p: float=0.12311673015011881, target_prob: float=0.16502979527390615):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12311673015011881, target_prob=0.16502979527390615):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_74",
    "sat": "def sat(counts: List[int], p: float=0.09634016520895483, target_prob: float=0.009281427432488712):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09634016520895483, target_prob=0.009281427432488712):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_75",
    "sat": "def sat(counts: List[int], p: float=0.9527624579175453, target_prob: float=0.090012313400926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9527624579175453, target_prob=0.090012313400926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_76",
    "sat": "def sat(counts: List[int], p: float=0.017732853580073815, target_prob: float=0.0009266337829460305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.017732853580073815, target_prob=0.0009266337829460305):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_77",
    "sat": "def sat(counts: List[int], p: float=0.034681808624796084, target_prob: float=2.093215296033735e-12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.034681808624796084, target_prob=2.093215296033735e-12):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_78",
    "sat": "def sat(counts: List[int], p: float=0.34402837874353176, target_prob: float=0.008835527540453959):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34402837874353176, target_prob=0.008835527540453959):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_79",
    "sat": "def sat(counts: List[int], p: float=0.230237961807631, target_prob: float=0.0018771079044838474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.230237961807631, target_prob=0.0018771079044838474):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_80",
    "sat": "def sat(counts: List[int], p: float=0.6502305008215192, target_prob: float=0.42279970419860374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6502305008215192, target_prob=0.42279970419860374):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_81",
    "sat": "def sat(counts: List[int], p: float=0.033613908707468276, target_prob: float=0.06496802769774852):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.033613908707468276, target_prob=0.06496802769774852):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_82",
    "sat": "def sat(counts: List[int], p: float=0.7954819426069853, target_prob: float=0.4004251090669372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7954819426069853, target_prob=0.4004251090669372):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_83",
    "sat": "def sat(counts: List[int], p: float=0.5760888326095063, target_prob: float=0.4239111673904937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5760888326095063, target_prob=0.4239111673904937):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_84",
    "sat": "def sat(counts: List[int], p: float=0.9788887129019547, target_prob: float=0.09692102530432323):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9788887129019547, target_prob=0.09692102530432323):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_85",
    "sat": "def sat(counts: List[int], p: float=0.6387659667798762, target_prob: float=0.0639535388972474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6387659667798762, target_prob=0.0639535388972474):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_86",
    "sat": "def sat(counts: List[int], p: float=0.924646783349219, target_prob: float=0.7905468081800152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.924646783349219, target_prob=0.7905468081800152):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_87",
    "sat": "def sat(counts: List[int], p: float=0.9413494347667088, target_prob: float=0.0002017514225877922):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9413494347667088, target_prob=0.0002017514225877922):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_88",
    "sat": "def sat(counts: List[int], p: float=0.38274627786437554, target_prob: float=0.3348888107842326):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38274627786437554, target_prob=0.3348888107842326):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_89",
    "sat": "def sat(counts: List[int], p: float=0.5945929764127761, target_prob: float=0.3535408075994041):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5945929764127761, target_prob=0.3535408075994041):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_90",
    "sat": "def sat(counts: List[int], p: float=0.5085116019866044, target_prob: float=0.15573541298991977):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5085116019866044, target_prob=0.15573541298991977):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_91",
    "sat": "def sat(counts: List[int], p: float=0.341272366955901, target_prob: float=0.04467662777593931):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.341272366955901, target_prob=0.04467662777593931):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_92",
    "sat": "def sat(counts: List[int], p: float=0.7373735492254337, target_prob: float=0.03879897268087895):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7373735492254337, target_prob=0.03879897268087895):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_93",
    "sat": "def sat(counts: List[int], p: float=0.07890537950965781, target_prob: float=5.733320248835359e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07890537950965781, target_prob=5.733320248835359e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_94",
    "sat": "def sat(counts: List[int], p: float=0.6828675909689348, target_prob: float=0.20603405468724362):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6828675909689348, target_prob=0.20603405468724362):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_95",
    "sat": "def sat(counts: List[int], p: float=0.35041933465128394, target_prob: float=0.0018515198144024383):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35041933465128394, target_prob=0.0018515198144024383):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_96",
    "sat": "def sat(counts: List[int], p: float=0.7294857027628621, target_prob: float=0.2896012548983946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7294857027628621, target_prob=0.2896012548983946):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_97",
    "sat": "def sat(counts: List[int], p: float=0.10042701409320354, target_prob: float=0.048969442690509096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10042701409320354, target_prob=0.048969442690509096):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_98",
    "sat": "def sat(counts: List[int], p: float=0.028506615415023195, target_prob: float=7.200330143859591e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.028506615415023195, target_prob=7.200330143859591e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_99",
    "sat": "def sat(counts: List[int], p: float=0.19882664560290542, target_prob: float=0.025846750692884026):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19882664560290542, target_prob=0.025846750692884026):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_100",
    "sat": "def sat(counts: List[int], p: float=0.9601909229544681, target_prob: float=0.0015847626152170977):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9601909229544681, target_prob=0.0015847626152170977):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_101",
    "sat": "def sat(counts: List[int], p: float=0.37916783425587697, target_prob: float=0.36292267984389226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37916783425587697, target_prob=0.36292267984389226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_102",
    "sat": "def sat(counts: List[int], p: float=0.3510521760703256, target_prob: float=0.21503754985331133):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3510521760703256, target_prob=0.21503754985331133):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_103",
    "sat": "def sat(counts: List[int], p: float=0.6435047142255806, target_prob: float=0.051968107543759245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6435047142255806, target_prob=0.051968107543759245):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_104",
    "sat": "def sat(counts: List[int], p: float=0.5173236477610248, target_prob: float=0.009915995443131409):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5173236477610248, target_prob=0.009915995443131409):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_105",
    "sat": "def sat(counts: List[int], p: float=0.11444717164293572, target_prob: float=0.11444717164293572):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11444717164293572, target_prob=0.11444717164293572):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_106",
    "sat": "def sat(counts: List[int], p: float=0.2552257178771611, target_prob: float=0.2535871536838876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2552257178771611, target_prob=0.2535871536838876):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_107",
    "sat": "def sat(counts: List[int], p: float=0.8187746799806583, target_prob: float=0.3294402177982623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8187746799806583, target_prob=0.3294402177982623):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_108",
    "sat": "def sat(counts: List[int], p: float=0.8737781968736124, target_prob: float=0.22057971908382215):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8737781968736124, target_prob=0.22057971908382215):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_109",
    "sat": "def sat(counts: List[int], p: float=0.7569221739597916, target_prob: float=0.13417239434082898):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7569221739597916, target_prob=0.13417239434082898):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_110",
    "sat": "def sat(counts: List[int], p: float=0.5637971093146135, target_prob: float=0.43620289068538654):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5637971093146135, target_prob=0.43620289068538654):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_111",
    "sat": "def sat(counts: List[int], p: float=0.2664447906617018, target_prob: float=0.15581054027092378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2664447906617018, target_prob=0.15581054027092378):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_112",
    "sat": "def sat(counts: List[int], p: float=0.5937499515102892, target_prob: float=0.29397587624752586):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5937499515102892, target_prob=0.29397587624752586):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_113",
    "sat": "def sat(counts: List[int], p: float=0.24845614508710157, target_prob: float=0.046106647752814846):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24845614508710157, target_prob=0.046106647752814846):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_114",
    "sat": "def sat(counts: List[int], p: float=0.5427308778870479, target_prob: float=0.013870487198611909):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5427308778870479, target_prob=0.013870487198611909):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_115",
    "sat": "def sat(counts: List[int], p: float=0.3949651540970043, target_prob: float=0.3949651540970043):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3949651540970043, target_prob=0.3949651540970043):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_116",
    "sat": "def sat(counts: List[int], p: float=0.27314143545132585, target_prob: float=0.05924785962524917):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27314143545132585, target_prob=0.05924785962524917):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_117",
    "sat": "def sat(counts: List[int], p: float=0.9954825188844636, target_prob: float=0.03921100371320962):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9954825188844636, target_prob=0.03921100371320962):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_118",
    "sat": "def sat(counts: List[int], p: float=0.7141595933576333, target_prob: float=0.0625417095312945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7141595933576333, target_prob=0.0625417095312945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_119",
    "sat": "def sat(counts: List[int], p: float=0.09909479247927977, target_prob: float=0.19175511485930025):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09909479247927977, target_prob=0.19175511485930025):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_120",
    "sat": "def sat(counts: List[int], p: float=0.49018600001780455, target_prob: float=0.3747111118720564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49018600001780455, target_prob=0.3747111118720564):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_121",
    "sat": "def sat(counts: List[int], p: float=0.2145359185143455, target_prob: float=0.2797390934787756):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2145359185143455, target_prob=0.2797390934787756):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_122",
    "sat": "def sat(counts: List[int], p: float=0.4287166388067021, target_prob: float=0.09383520222394143):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4287166388067021, target_prob=0.09383520222394143):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_123",
    "sat": "def sat(counts: List[int], p: float=0.8422769688305092, target_prob: float=0.3769813651606161):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8422769688305092, target_prob=0.3769813651606161):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_124",
    "sat": "def sat(counts: List[int], p: float=0.16272819360551505, target_prob: float=0.34450759775926204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16272819360551505, target_prob=0.34450759775926204):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_125",
    "sat": "def sat(counts: List[int], p: float=0.14848606838932366, target_prob: float=0.004781521548359159):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14848606838932366, target_prob=0.004781521548359159):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_126",
    "sat": "def sat(counts: List[int], p: float=0.9716367283508107, target_prob: float=0.05511759294108715):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9716367283508107, target_prob=0.05511759294108715):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_127",
    "sat": "def sat(counts: List[int], p: float=0.7121226747226059, target_prob: float=0.09287176529209588):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7121226747226059, target_prob=0.09287176529209588):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_128",
    "sat": "def sat(counts: List[int], p: float=0.03552710971176476, target_prob: float=0.004177255615475365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03552710971176476, target_prob=0.004177255615475365):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_129",
    "sat": "def sat(counts: List[int], p: float=0.3150249074374556, target_prob: float=0.15079047130794496):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3150249074374556, target_prob=0.15079047130794496):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_130",
    "sat": "def sat(counts: List[int], p: float=0.9085072128910209, target_prob: float=4.0148169535362225e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9085072128910209, target_prob=4.0148169535362225e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_131",
    "sat": "def sat(counts: List[int], p: float=0.11710652756903206, target_prob: float=0.3259678389965737):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11710652756903206, target_prob=0.3259678389965737):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_132",
    "sat": "def sat(counts: List[int], p: float=0.7831826880957139, target_prob: float=0.3762290414328622):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7831826880957139, target_prob=0.3762290414328622):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_133",
    "sat": "def sat(counts: List[int], p: float=0.47509870452851066, target_prob: float=0.14127857215834558):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47509870452851066, target_prob=0.14127857215834558):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_134",
    "sat": "def sat(counts: List[int], p: float=0.2309085751149479, target_prob: float=0.07282426705681486):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2309085751149479, target_prob=0.07282426705681486):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_135",
    "sat": "def sat(counts: List[int], p: float=0.43940185558129075, target_prob: float=0.3142702795257):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43940185558129075, target_prob=0.3142702795257):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_136",
    "sat": "def sat(counts: List[int], p: float=0.6773566041632499, target_prob: float=0.10409876087706979):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6773566041632499, target_prob=0.10409876087706979):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_137",
    "sat": "def sat(counts: List[int], p: float=0.5495340918520142, target_prob: float=0.3345336061725305):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5495340918520142, target_prob=0.3345336061725305):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_138",
    "sat": "def sat(counts: List[int], p: float=0.5236754361267928, target_prob: float=0.10807094161455623):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5236754361267928, target_prob=0.10807094161455623):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_139",
    "sat": "def sat(counts: List[int], p: float=0.459087163672219, target_prob: float=0.04527131660170386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.459087163672219, target_prob=0.04527131660170386):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_140",
    "sat": "def sat(counts: List[int], p: float=0.8936881673537209, target_prob: float=1.3580258092885824e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8936881673537209, target_prob=1.3580258092885824e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_141",
    "sat": "def sat(counts: List[int], p: float=0.946135452055178, target_prob: float=0.01558346109655975):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.946135452055178, target_prob=0.01558346109655975):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_142",
    "sat": "def sat(counts: List[int], p: float=0.2343642924298227, target_prob: float=0.01154936105739818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2343642924298227, target_prob=0.01154936105739818):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_143",
    "sat": "def sat(counts: List[int], p: float=0.020444255536928524, target_prob: float=3.571548099019844e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.020444255536928524, target_prob=3.571548099019844e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_144",
    "sat": "def sat(counts: List[int], p: float=0.44756053778248406, target_prob: float=0.15720588222074872):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44756053778248406, target_prob=0.15720588222074872):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_145",
    "sat": "def sat(counts: List[int], p: float=0.9939390592153275, target_prob: float=6.706407299106399e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9939390592153275, target_prob=6.706407299106399e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_146",
    "sat": "def sat(counts: List[int], p: float=0.48354836715962224, target_prob: float=0.09546778968439497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48354836715962224, target_prob=0.09546778968439497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_147",
    "sat": "def sat(counts: List[int], p: float=0.08466873407077491, target_prob: float=0.08466873407077491):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08466873407077491, target_prob=0.08466873407077491):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_148",
    "sat": "def sat(counts: List[int], p: float=0.35805785030865633, target_prob: float=0.264537763001619):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35805785030865633, target_prob=0.264537763001619):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_149",
    "sat": "def sat(counts: List[int], p: float=0.7939589854528549, target_prob: float=0.1840469961774135):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7939589854528549, target_prob=0.1840469961774135):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_150",
    "sat": "def sat(counts: List[int], p: float=0.3322627109897024, target_prob: float=4.9355372965170654e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3322627109897024, target_prob=4.9355372965170654e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_151",
    "sat": "def sat(counts: List[int], p: float=0.7946201707828099, target_prob: float=0.027535498388462358):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7946201707828099, target_prob=0.027535498388462358):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_152",
    "sat": "def sat(counts: List[int], p: float=0.8785347231278638, target_prob: float=0.0062976041103306344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8785347231278638, target_prob=0.0062976041103306344):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_153",
    "sat": "def sat(counts: List[int], p: float=0.9426331874142638, target_prob: float=0.8885573260147747):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9426331874142638, target_prob=0.8885573260147747):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_154",
    "sat": "def sat(counts: List[int], p: float=0.7877048019477729, target_prob: float=0.2602708753960082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7877048019477729, target_prob=0.2602708753960082):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_155",
    "sat": "def sat(counts: List[int], p: float=0.8022991754433456, target_prob: float=0.8022991754433456):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8022991754433456, target_prob=0.8022991754433456):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_156",
    "sat": "def sat(counts: List[int], p: float=0.3215944826522381, target_prob: float=0.4363429427597549):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3215944826522381, target_prob=0.4363429427597549):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_157",
    "sat": "def sat(counts: List[int], p: float=0.15901040008598144, target_prob: float=0.003386004679369224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15901040008598144, target_prob=0.003386004679369224):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_158",
    "sat": "def sat(counts: List[int], p: float=0.050439000306130244, target_prob: float=0.00012832149509099018):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.050439000306130244, target_prob=0.00012832149509099018):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_159",
    "sat": "def sat(counts: List[int], p: float=0.9679585321787407, target_prob: float=0.018320100937759026):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9679585321787407, target_prob=0.018320100937759026):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_160",
    "sat": "def sat(counts: List[int], p: float=0.3197790296679375, target_prob: float=0.13191452625650651):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3197790296679375, target_prob=0.13191452625650651):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_161",
    "sat": "def sat(counts: List[int], p: float=0.15649946875008502, target_prob: float=0.6001448468163062):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15649946875008502, target_prob=0.6001448468163062):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_162",
    "sat": "def sat(counts: List[int], p: float=0.029758497711907306, target_prob: float=0.8861747897844449):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.029758497711907306, target_prob=0.8861747897844449):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_163",
    "sat": "def sat(counts: List[int], p: float=0.1279344901589593, target_prob: float=0.0030559064208702403):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1279344901589593, target_prob=0.0030559064208702403):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_164",
    "sat": "def sat(counts: List[int], p: float=0.427259153764764, target_prob: float=0.030694350382377306):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.427259153764764, target_prob=0.030694350382377306):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_165",
    "sat": "def sat(counts: List[int], p: float=0.20461937439731426, target_prob: float=0.004765440739325536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20461937439731426, target_prob=0.004765440739325536):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_166",
    "sat": "def sat(counts: List[int], p: float=0.02730221493531204, target_prob: float=0.00423158303055335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02730221493531204, target_prob=0.00423158303055335):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_167",
    "sat": "def sat(counts: List[int], p: float=0.47413080721715406, target_prob: float=0.4986615697295279):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47413080721715406, target_prob=0.4986615697295279):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_168",
    "sat": "def sat(counts: List[int], p: float=0.9905186421763266, target_prob: float=0.9718247626299924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9905186421763266, target_prob=0.9718247626299924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_169",
    "sat": "def sat(counts: List[int], p: float=0.07730724078261164, target_prob: float=0.6687835197284212):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07730724078261164, target_prob=0.6687835197284212):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_170",
    "sat": "def sat(counts: List[int], p: float=0.04398261676795001, target_prob: float=0.00037655095043117833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04398261676795001, target_prob=0.00037655095043117833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_171",
    "sat": "def sat(counts: List[int], p: float=0.40587252094703774, target_prob: float=0.1647325032599036):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40587252094703774, target_prob=0.1647325032599036):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_172",
    "sat": "def sat(counts: List[int], p: float=0.8561191643330547, target_prob: float=0.024834387072803242):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8561191643330547, target_prob=0.024834387072803242):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_173",
    "sat": "def sat(counts: List[int], p: float=0.9063873261677637, target_prob: float=0.8215379850375482):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9063873261677637, target_prob=0.8215379850375482):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_174",
    "sat": "def sat(counts: List[int], p: float=0.2787643001335053, target_prob: float=0.0528074186142809):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2787643001335053, target_prob=0.0528074186142809):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_175",
    "sat": "def sat(counts: List[int], p: float=0.9683314431505582, target_prob: float=6.272038671175413e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9683314431505582, target_prob=6.272038671175413e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_176",
    "sat": "def sat(counts: List[int], p: float=0.8297301935936767, target_prob: float=0.08188956193956681):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8297301935936767, target_prob=0.08188956193956681):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_177",
    "sat": "def sat(counts: List[int], p: float=0.6846460121191826, target_prob: float=0.0020631523464306016):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6846460121191826, target_prob=0.0020631523464306016):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_178",
    "sat": "def sat(counts: List[int], p: float=0.20471331971813966, target_prob: float=0.0061828788420617495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20471331971813966, target_prob=0.0061828788420617495):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_179",
    "sat": "def sat(counts: List[int], p: float=0.8053398275605157, target_prob: float=0.16903851219904437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8053398275605157, target_prob=0.16903851219904437):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_180",
    "sat": "def sat(counts: List[int], p: float=0.5845457554552637, target_prob: float=0.34169374022076493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5845457554552637, target_prob=0.34169374022076493):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_181",
    "sat": "def sat(counts: List[int], p: float=0.87150963640724, target_prob: float=0.12849036359276):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.87150963640724, target_prob=0.12849036359276):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_182",
    "sat": "def sat(counts: List[int], p: float=0.6567730739982026, target_prob: float=0.3337403522715818):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6567730739982026, target_prob=0.3337403522715818):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_183",
    "sat": "def sat(counts: List[int], p: float=0.8849854684025311, target_prob: float=0.00033102069738218527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8849854684025311, target_prob=0.00033102069738218527):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_184",
    "sat": "def sat(counts: List[int], p: float=0.008362789796778736, target_prob: float=5.751209286120185e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.008362789796778736, target_prob=5.751209286120185e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_185",
    "sat": "def sat(counts: List[int], p: float=0.9249460325145463, target_prob: float=0.029384409475979395):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9249460325145463, target_prob=0.029384409475979395):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_186",
    "sat": "def sat(counts: List[int], p: float=0.7370877156454078, target_prob: float=0.26291228435459224):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7370877156454078, target_prob=0.26291228435459224):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_187",
    "sat": "def sat(counts: List[int], p: float=0.9378311651421031, target_prob: float=0.3488949428796645):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9378311651421031, target_prob=0.3488949428796645):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_188",
    "sat": "def sat(counts: List[int], p: float=0.9874552582547077, target_prob: float=4.889135519229094e-14):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9874552582547077, target_prob=4.889135519229094e-14):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_189",
    "sat": "def sat(counts: List[int], p: float=0.2675719961224202, target_prob: float=0.289153427054347):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2675719961224202, target_prob=0.289153427054347):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_190",
    "sat": "def sat(counts: List[int], p: float=0.4621979173845334, target_prob: float=0.09873791513383519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4621979173845334, target_prob=0.09873791513383519):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_191",
    "sat": "def sat(counts: List[int], p: float=0.06354178490678009, target_prob: float=0.03315767205157015):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06354178490678009, target_prob=0.03315767205157015):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_192",
    "sat": "def sat(counts: List[int], p: float=0.3764653731646391, target_prob: float=0.06262254687391386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3764653731646391, target_prob=0.06262254687391386):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_193",
    "sat": "def sat(counts: List[int], p: float=0.5633220256771821, target_prob: float=0.3173317046130439):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5633220256771821, target_prob=0.3173317046130439):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_194",
    "sat": "def sat(counts: List[int], p: float=0.4577135054806253, target_prob: float=0.4577135054806253):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4577135054806253, target_prob=0.4577135054806253):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_195",
    "sat": "def sat(counts: List[int], p: float=0.7526594295928771, target_prob: float=0.0002289666067652919):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7526594295928771, target_prob=0.0002289666067652919):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_196",
    "sat": "def sat(counts: List[int], p: float=0.0356043964802929, target_prob: float=0.06867344686313401):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0356043964802929, target_prob=0.06867344686313401):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_197",
    "sat": "def sat(counts: List[int], p: float=0.555129736360491, target_prob: float=0.444870263639509):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.555129736360491, target_prob=0.444870263639509):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_198",
    "sat": "def sat(counts: List[int], p: float=0.08074335100475749, target_prob: float=1.8081324588437293e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08074335100475749, target_prob=1.8081324588437293e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_199",
    "sat": "def sat(counts: List[int], p: float=0.4996377270511151, target_prob: float=0.2462715390788648):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4996377270511151, target_prob=0.2462715390788648):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_200",
    "sat": "def sat(counts: List[int], p: float=0.38938594347646105, target_prob: float=0.3161687842775865):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38938594347646105, target_prob=0.3161687842775865):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_201",
    "sat": "def sat(counts: List[int], p: float=0.23529017441409095, target_prob: float=0.0007211389584490056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23529017441409095, target_prob=0.0007211389584490056):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_202",
    "sat": "def sat(counts: List[int], p: float=0.17249042719191998, target_prob: float=0.2092730773071253):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17249042719191998, target_prob=0.2092730773071253):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_203",
    "sat": "def sat(counts: List[int], p: float=0.10001037717788752, target_prob: float=0.24301961231701308):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10001037717788752, target_prob=0.24301961231701308):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_204",
    "sat": "def sat(counts: List[int], p: float=0.3131832044910188, target_prob: float=0.3273797507451651):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3131832044910188, target_prob=0.3273797507451651):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_205",
    "sat": "def sat(counts: List[int], p: float=0.1525764162002603, target_prob: float=0.2585937068394905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1525764162002603, target_prob=0.2585937068394905):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_206",
    "sat": "def sat(counts: List[int], p: float=0.7320699360119829, target_prob: float=0.005551263753773071):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7320699360119829, target_prob=0.005551263753773071):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_207",
    "sat": "def sat(counts: List[int], p: float=0.5981271848637056, target_prob: float=0.289795778362581):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5981271848637056, target_prob=0.289795778362581):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_208",
    "sat": "def sat(counts: List[int], p: float=0.581554341323472, target_prob: float=0.06651988817903831):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.581554341323472, target_prob=0.06651988817903831):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_209",
    "sat": "def sat(counts: List[int], p: float=0.22419790487761826, target_prob: float=0.22419790487761826):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22419790487761826, target_prob=0.22419790487761826):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_210",
    "sat": "def sat(counts: List[int], p: float=0.34553470243250595, target_prob: float=0.09158644212016928):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34553470243250595, target_prob=0.09158644212016928):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_211",
    "sat": "def sat(counts: List[int], p: float=0.6992942214627198, target_prob: float=0.00042076212485980005):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6992942214627198, target_prob=0.00042076212485980005):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_212",
    "sat": "def sat(counts: List[int], p: float=0.6856527600392874, target_prob: float=0.026124613906133985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6856527600392874, target_prob=0.026124613906133985):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_213",
    "sat": "def sat(counts: List[int], p: float=0.6425514930089927, target_prob: float=0.17609991634293384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6425514930089927, target_prob=0.17609991634293384):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_214",
    "sat": "def sat(counts: List[int], p: float=0.4002138730933439, target_prob: float=0.04020313178710015):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4002138730933439, target_prob=0.04020313178710015):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_215",
    "sat": "def sat(counts: List[int], p: float=0.9488507071259349, target_prob: float=4.68508066408209e-11):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9488507071259349, target_prob=4.68508066408209e-11):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_216",
    "sat": "def sat(counts: List[int], p: float=0.31316436429459615, target_prob: float=0.2872021501876773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31316436429459615, target_prob=0.2872021501876773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_217",
    "sat": "def sat(counts: List[int], p: float=0.9386012184769581, target_prob: float=0.0037698103725142314):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9386012184769581, target_prob=0.0037698103725142314):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_218",
    "sat": "def sat(counts: List[int], p: float=0.6263335401129447, target_prob: float=0.6263335401129447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6263335401129447, target_prob=0.6263335401129447):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_219",
    "sat": "def sat(counts: List[int], p: float=0.06326156825843454, target_prob: float=0.0040020260185165725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06326156825843454, target_prob=0.0040020260185165725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_220",
    "sat": "def sat(counts: List[int], p: float=0.17058085431172887, target_prob: float=0.014286381617699271):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17058085431172887, target_prob=0.014286381617699271):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_221",
    "sat": "def sat(counts: List[int], p: float=0.5772622845379506, target_prob: float=0.013500659386267402):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5772622845379506, target_prob=0.013500659386267402):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_222",
    "sat": "def sat(counts: List[int], p: float=0.7908638824837717, target_prob: float=8.367086293498812e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7908638824837717, target_prob=8.367086293498812e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_223",
    "sat": "def sat(counts: List[int], p: float=0.1008395241202823, target_prob: float=0.1255067004519071):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1008395241202823, target_prob=0.1255067004519071):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_224",
    "sat": "def sat(counts: List[int], p: float=0.945906123955659, target_prob: float=0.21652610047071053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.945906123955659, target_prob=0.21652610047071053):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_225",
    "sat": "def sat(counts: List[int], p: float=0.8720286816208932, target_prob: float=0.7604340215694732):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8720286816208932, target_prob=0.7604340215694732):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_226",
    "sat": "def sat(counts: List[int], p: float=0.8988603088680677, target_prob: float=0.0015648390456475558):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8988603088680677, target_prob=0.0015648390456475558):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_227",
    "sat": "def sat(counts: List[int], p: float=0.09421493729430752, target_prob: float=0.3446646842399237):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09421493729430752, target_prob=0.3446646842399237):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_228",
    "sat": "def sat(counts: List[int], p: float=0.7441813046140432, target_prob: float=0.30107232781023):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7441813046140432, target_prob=0.30107232781023):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_229",
    "sat": "def sat(counts: List[int], p: float=0.8693505213788821, target_prob: float=3.0264886153561805e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8693505213788821, target_prob=3.0264886153561805e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_230",
    "sat": "def sat(counts: List[int], p: float=0.13463582743736735, target_prob: float=0.3024681987194686):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13463582743736735, target_prob=0.3024681987194686):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_231",
    "sat": "def sat(counts: List[int], p: float=0.1023781203020514, target_prob: float=6.995237838951358e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1023781203020514, target_prob=6.995237838951358e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_232",
    "sat": "def sat(counts: List[int], p: float=0.6814828257572341, target_prob: float=0.05810547348982056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6814828257572341, target_prob=0.05810547348982056):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_233",
    "sat": "def sat(counts: List[int], p: float=0.4772063447322178, target_prob: float=0.2733132059882487):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4772063447322178, target_prob=0.2733132059882487):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_234",
    "sat": "def sat(counts: List[int], p: float=0.749143005104456, target_prob: float=0.26457366726630094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.749143005104456, target_prob=0.26457366726630094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_235",
    "sat": "def sat(counts: List[int], p: float=0.6730246375233394, target_prob: float=0.24074057871579152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6730246375233394, target_prob=0.24074057871579152):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_236",
    "sat": "def sat(counts: List[int], p: float=0.4984474533691896, target_prob: float=0.2515549570318512):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4984474533691896, target_prob=0.2515549570318512):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_237",
    "sat": "def sat(counts: List[int], p: float=0.40878993348633097, target_prob: float=0.2541443251719933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40878993348633097, target_prob=0.2541443251719933):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_238",
    "sat": "def sat(counts: List[int], p: float=0.3791323852433769, target_prob: float=0.07533997110171088):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3791323852433769, target_prob=0.07533997110171088):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_239",
    "sat": "def sat(counts: List[int], p: float=0.11313016667334319, target_prob: float=0.00016379992850582437):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11313016667334319, target_prob=0.00016379992850582437):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_240",
    "sat": "def sat(counts: List[int], p: float=0.5693293207072301, target_prob: float=0.2592802998174488):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5693293207072301, target_prob=0.2592802998174488):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_241",
    "sat": "def sat(counts: List[int], p: float=0.20274054511582495, target_prob: float=0.20274054511582495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20274054511582495, target_prob=0.20274054511582495):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_242",
    "sat": "def sat(counts: List[int], p: float=0.563663066427908, target_prob: float=0.22022686442612557):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.563663066427908, target_prob=0.22022686442612557):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_243",
    "sat": "def sat(counts: List[int], p: float=0.43094931406177894, target_prob: float=0.12918483849621312):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43094931406177894, target_prob=0.12918483849621312):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_244",
    "sat": "def sat(counts: List[int], p: float=0.4397471827209517, target_prob: float=0.19337758471101407):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4397471827209517, target_prob=0.19337758471101407):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_245",
    "sat": "def sat(counts: List[int], p: float=0.2931958391117593, target_prob: float=0.00738977492289592):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2931958391117593, target_prob=0.00738977492289592):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_246",
    "sat": "def sat(counts: List[int], p: float=0.47891282239454913, target_prob: float=0.2605103990357502):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47891282239454913, target_prob=0.2605103990357502):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_247",
    "sat": "def sat(counts: List[int], p: float=0.9386727507174167, target_prob: float=0.0008660334346477751):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9386727507174167, target_prob=0.0008660334346477751):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_248",
    "sat": "def sat(counts: List[int], p: float=0.8080237739049068, target_prob: float=1.3416716657538648e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8080237739049068, target_prob=1.3416716657538648e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_249",
    "sat": "def sat(counts: List[int], p: float=0.34793814781483023, target_prob: float=0.44381388827366763):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34793814781483023, target_prob=0.44381388827366763):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_250",
    "sat": "def sat(counts: List[int], p: float=0.005431015175184739, target_prob: float=0.9945689848248153):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.005431015175184739, target_prob=0.9945689848248153):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_251",
    "sat": "def sat(counts: List[int], p: float=0.730724593828202, target_prob: float=0.1049300057748515):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.730724593828202, target_prob=0.1049300057748515):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_252",
    "sat": "def sat(counts: List[int], p: float=0.48224113482440933, target_prob: float=0.05853388589217759):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48224113482440933, target_prob=0.05853388589217759):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_253",
    "sat": "def sat(counts: List[int], p: float=0.5317628573156099, target_prob: float=0.5317628573156099):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5317628573156099, target_prob=0.5317628573156099):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_254",
    "sat": "def sat(counts: List[int], p: float=0.021286034423334765, target_prob: float=8.97124756429441e-16):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.021286034423334765, target_prob=8.97124756429441e-16):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_255",
    "sat": "def sat(counts: List[int], p: float=0.42827304383614306, target_prob: float=0.031097467286868123):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42827304383614306, target_prob=0.031097467286868123):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_256",
    "sat": "def sat(counts: List[int], p: float=0.6513943547687204, target_prob: float=0.03241544021464505):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6513943547687204, target_prob=0.03241544021464505):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_257",
    "sat": "def sat(counts: List[int], p: float=0.7733782624884364, target_prob: float=0.5981139368896329):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7733782624884364, target_prob=0.5981139368896329):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_258",
    "sat": "def sat(counts: List[int], p: float=0.07408853699026752, target_prob: float=9.078375699266141e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07408853699026752, target_prob=9.078375699266141e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_259",
    "sat": "def sat(counts: List[int], p: float=0.9782068010838639, target_prob: float=2.1909967465862175e-12):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9782068010838639, target_prob=2.1909967465862175e-12):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_260",
    "sat": "def sat(counts: List[int], p: float=0.15317127329044278, target_prob: float=0.25941966865805455):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15317127329044278, target_prob=0.25941966865805455):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_261",
    "sat": "def sat(counts: List[int], p: float=0.5466794359752292, target_prob: float=0.20370842470264267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5466794359752292, target_prob=0.20370842470264267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_262",
    "sat": "def sat(counts: List[int], p: float=0.5627616955495628, target_prob: float=0.3167007259778188):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5627616955495628, target_prob=0.3167007259778188):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_263",
    "sat": "def sat(counts: List[int], p: float=0.9850372374006382, target_prob: float=0.0002238842646048603):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9850372374006382, target_prob=0.0002238842646048603):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_264",
    "sat": "def sat(counts: List[int], p: float=0.529581060650691, target_prob: float=0.2610902392114413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.529581060650691, target_prob=0.2610902392114413):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_265",
    "sat": "def sat(counts: List[int], p: float=0.8626248868599259, target_prob: float=0.013804421971350546):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8626248868599259, target_prob=0.013804421971350546):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_266",
    "sat": "def sat(counts: List[int], p: float=0.01603249457497724, target_prob: float=7.851914648475365e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.01603249457497724, target_prob=7.851914648475365e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_267",
    "sat": "def sat(counts: List[int], p: float=0.14767080097325158, target_prob: float=0.38339301861674263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14767080097325158, target_prob=0.38339301861674263):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_268",
    "sat": "def sat(counts: List[int], p: float=0.2980110508090468, target_prob: float=0.30481406063185057):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2980110508090468, target_prob=0.30481406063185057):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_269",
    "sat": "def sat(counts: List[int], p: float=0.7386442486543586, target_prob: float=0.3860978451683933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7386442486543586, target_prob=0.3860978451683933):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_270",
    "sat": "def sat(counts: List[int], p: float=0.6140163144834532, target_prob: float=0.14898340548493652):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6140163144834532, target_prob=0.14898340548493652):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_271",
    "sat": "def sat(counts: List[int], p: float=0.19514271255939986, target_prob: float=6.130119991785702e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19514271255939986, target_prob=6.130119991785702e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_272",
    "sat": "def sat(counts: List[int], p: float=0.5584726796967728, target_prob: float=0.2684581600824404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5584726796967728, target_prob=0.2684581600824404):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_273",
    "sat": "def sat(counts: List[int], p: float=0.059699187167690515, target_prob: float=0.6911954477244037):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.059699187167690515, target_prob=0.6911954477244037):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_274",
    "sat": "def sat(counts: List[int], p: float=0.8802494646302608, target_prob: float=2.462562821745072e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8802494646302608, target_prob=2.462562821745072e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_275",
    "sat": "def sat(counts: List[int], p: float=0.6175325949861742, target_prob: float=0.12240206577182745):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6175325949861742, target_prob=0.12240206577182745):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_276",
    "sat": "def sat(counts: List[int], p: float=0.4614893428485779, target_prob: float=0.019205075718680267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4614893428485779, target_prob=0.019205075718680267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_277",
    "sat": "def sat(counts: List[int], p: float=0.7708556625443533, target_prob: float=0.01620514329949905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7708556625443533, target_prob=0.01620514329949905):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_278",
    "sat": "def sat(counts: List[int], p: float=0.24785489510761538, target_prob: float=9.641045835252071e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24785489510761538, target_prob=9.641045835252071e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_279",
    "sat": "def sat(counts: List[int], p: float=0.3016188230511634, target_prob: float=0.11602595545515171):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3016188230511634, target_prob=0.11602595545515171):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_280",
    "sat": "def sat(counts: List[int], p: float=0.20095045647034704, target_prob: float=0.3023405850102772):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20095045647034704, target_prob=0.3023405850102772):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_281",
    "sat": "def sat(counts: List[int], p: float=0.15824023176475255, target_prob: float=0.04726560500792412):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15824023176475255, target_prob=0.04726560500792412):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_282",
    "sat": "def sat(counts: List[int], p: float=0.8997981571329999, target_prob: float=1.012171847547372e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8997981571329999, target_prob=1.012171847547372e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_283",
    "sat": "def sat(counts: List[int], p: float=0.9135891322694624, target_prob: float=0.21636722268835418):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9135891322694624, target_prob=0.21636722268835418):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_284",
    "sat": "def sat(counts: List[int], p: float=0.7566432922273459, target_prob: float=0.41797176855669405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7566432922273459, target_prob=0.41797176855669405):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_285",
    "sat": "def sat(counts: List[int], p: float=0.3316826438222613, target_prob: float=0.6683173561777387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3316826438222613, target_prob=0.6683173561777387):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_286",
    "sat": "def sat(counts: List[int], p: float=0.22452838196426095, target_prob: float=1.4502444767563948e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22452838196426095, target_prob=1.4502444767563948e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_287",
    "sat": "def sat(counts: List[int], p: float=0.07903505011031786, target_prob: float=5.88202459174013e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07903505011031786, target_prob=5.88202459174013e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_288",
    "sat": "def sat(counts: List[int], p: float=0.6793005476327907, target_prob: float=3.588260504211693e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6793005476327907, target_prob=3.588260504211693e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_289",
    "sat": "def sat(counts: List[int], p: float=0.41663424465646837, target_prob: float=0.2871558580756798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41663424465646837, target_prob=0.2871558580756798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_290",
    "sat": "def sat(counts: List[int], p: float=0.13298620689868523, target_prob: float=0.0003028286078519188):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13298620689868523, target_prob=0.0003028286078519188):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_291",
    "sat": "def sat(counts: List[int], p: float=0.36030876351693797, target_prob: float=0.36030876351693797):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36030876351693797, target_prob=0.36030876351693797):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_292",
    "sat": "def sat(counts: List[int], p: float=0.5680344766549817, target_prob: float=0.2456200483720291):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5680344766549817, target_prob=0.2456200483720291):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_293",
    "sat": "def sat(counts: List[int], p: float=0.9072724943660789, target_prob: float=0.0373535159146648):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9072724943660789, target_prob=0.0373535159146648):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_294",
    "sat": "def sat(counts: List[int], p: float=0.3919588614704539, target_prob: float=0.11646337062510331):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3919588614704539, target_prob=0.11646337062510331):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_295",
    "sat": "def sat(counts: List[int], p: float=0.08317553194310645, target_prob: float=0.5939052589816205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08317553194310645, target_prob=0.5939052589816205):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_296",
    "sat": "def sat(counts: List[int], p: float=0.9730113263665648, target_prob: float=3.554750164814006e-10):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9730113263665648, target_prob=3.554750164814006e-10):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_297",
    "sat": "def sat(counts: List[int], p: float=0.6112808428713487, target_prob: float=0.4357513789228157):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6112808428713487, target_prob=0.4357513789228157):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_298",
    "sat": "def sat(counts: List[int], p: float=0.9060205756139548, target_prob: float=7.800655933839672e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9060205756139548, target_prob=7.800655933839672e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_299",
    "sat": "def sat(counts: List[int], p: float=0.19487760652558728, target_prob: float=0.3383058680360664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19487760652558728, target_prob=0.3383058680360664):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_300",
    "sat": "def sat(counts: List[int], p: float=0.44441336108640006, target_prob: float=0.14115534335966595):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.44441336108640006, target_prob=0.14115534335966595):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_301",
    "sat": "def sat(counts: List[int], p: float=0.5395320544324002, target_prob: float=0.2895577954011239):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5395320544324002, target_prob=0.2895577954011239):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_302",
    "sat": "def sat(counts: List[int], p: float=0.8674806298389225, target_prob: float=0.0014940467971446421):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8674806298389225, target_prob=0.0014940467971446421):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_303",
    "sat": "def sat(counts: List[int], p: float=0.8326577687398988, target_prob: float=0.01560785406846009):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8326577687398988, target_prob=0.01560785406846009):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_304",
    "sat": "def sat(counts: List[int], p: float=0.13191512917119663, target_prob: float=0.0034228988217436546):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13191512917119663, target_prob=0.0034228988217436546):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_305",
    "sat": "def sat(counts: List[int], p: float=0.2189488641997579, target_prob: float=0.2189488641997579):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2189488641997579, target_prob=0.2189488641997579):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_306",
    "sat": "def sat(counts: List[int], p: float=0.4334301207977035, target_prob: float=0.4911369023659833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4334301207977035, target_prob=0.4911369023659833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_307",
    "sat": "def sat(counts: List[int], p: float=0.041981682177113844, target_prob: float=0.0002835393333064371):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.041981682177113844, target_prob=0.0002835393333064371):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_308",
    "sat": "def sat(counts: List[int], p: float=0.501056841010347, target_prob: float=0.24894316370626057):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.501056841010347, target_prob=0.24894316370626057):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_309",
    "sat": "def sat(counts: List[int], p: float=0.7336273678443248, target_prob: float=0.005383276575423675):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7336273678443248, target_prob=0.005383276575423675):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_310",
    "sat": "def sat(counts: List[int], p: float=0.18453742063968015, target_prob: float=0.07161125717373519):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18453742063968015, target_prob=0.07161125717373519):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_311",
    "sat": "def sat(counts: List[int], p: float=0.9820594862498234, target_prob: float=1.8908264741897237e-15):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9820594862498234, target_prob=1.8908264741897237e-15):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_312",
    "sat": "def sat(counts: List[int], p: float=0.8069487856728995, target_prob: float=0.013566672925592558):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8069487856728995, target_prob=0.013566672925592558):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_313",
    "sat": "def sat(counts: List[int], p: float=0.7767438346787756, target_prob: float=0.3640082771129351):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7767438346787756, target_prob=0.3640082771129351):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_314",
    "sat": "def sat(counts: List[int], p: float=0.7547529884752361, target_prob: float=0.02136097986785436):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7547529884752361, target_prob=0.02136097986785436):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_315",
    "sat": "def sat(counts: List[int], p: float=0.2940943491229331, target_prob: float=0.7059056508770669):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2940943491229331, target_prob=0.7059056508770669):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_316",
    "sat": "def sat(counts: List[int], p: float=0.15276635335749922, target_prob: float=0.1340561508063279):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15276635335749922, target_prob=0.1340561508063279):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_317",
    "sat": "def sat(counts: List[int], p: float=0.21833236771491238, target_prob: float=0.7816676322850876):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21833236771491238, target_prob=0.7816676322850876):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_318",
    "sat": "def sat(counts: List[int], p: float=0.27635329667568564, target_prob: float=0.27779358820235256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27635329667568564, target_prob=0.27779358820235256):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_319",
    "sat": "def sat(counts: List[int], p: float=0.527930942030335, target_prob: float=0.30958360401212165):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.527930942030335, target_prob=0.30958360401212165):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_320",
    "sat": "def sat(counts: List[int], p: float=0.7901359624761802, target_prob: float=0.389769018443024):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7901359624761802, target_prob=0.389769018443024):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_321",
    "sat": "def sat(counts: List[int], p: float=0.3768840400397858, target_prob: float=0.3768840400397858):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3768840400397858, target_prob=0.3768840400397858):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_322",
    "sat": "def sat(counts: List[int], p: float=0.5143556892910336, target_prob: float=0.23565597483922468):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5143556892910336, target_prob=0.23565597483922468):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_323",
    "sat": "def sat(counts: List[int], p: float=0.19152127395475038, target_prob: float=0.16479420328100658):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19152127395475038, target_prob=0.16479420328100658):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_324",
    "sat": "def sat(counts: List[int], p: float=0.4529101096416932, target_prob: float=0.2912989017490648):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4529101096416932, target_prob=0.2912989017490648):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_325",
    "sat": "def sat(counts: List[int], p: float=0.6337680679522927, target_prob: float=0.34143141455143067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6337680679522927, target_prob=0.34143141455143067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_326",
    "sat": "def sat(counts: List[int], p: float=0.41158799996156503, target_prob: float=0.08319554570082578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41158799996156503, target_prob=0.08319554570082578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_327",
    "sat": "def sat(counts: List[int], p: float=0.10046460194798845, target_prob: float=6.474328113757141e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10046460194798845, target_prob=6.474328113757141e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_328",
    "sat": "def sat(counts: List[int], p: float=0.245744284638565, target_prob: float=0.3236491262348391):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.245744284638565, target_prob=0.3236491262348391):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_329",
    "sat": "def sat(counts: List[int], p: float=0.2541650442876664, target_prob: float=0.31308669118458277):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2541650442876664, target_prob=0.31308669118458277):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_330",
    "sat": "def sat(counts: List[int], p: float=0.35225419246495304, target_prob: float=0.0005408914881024158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35225419246495304, target_prob=0.0005408914881024158):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_331",
    "sat": "def sat(counts: List[int], p: float=0.32674252533443604, target_prob: float=0.005734732854254871):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32674252533443604, target_prob=0.005734732854254871):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_332",
    "sat": "def sat(counts: List[int], p: float=0.9634314290310708, target_prob: float=0.22539467135657992):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9634314290310708, target_prob=0.22539467135657992):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_333",
    "sat": "def sat(counts: List[int], p: float=0.5001821762936911, target_prob: float=0.25018220948189307):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5001821762936911, target_prob=0.25018220948189307):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_334",
    "sat": "def sat(counts: List[int], p: float=0.7781781251400945, target_prob: float=0.34480735612843516):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7781781251400945, target_prob=0.34480735612843516):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_335",
    "sat": "def sat(counts: List[int], p: float=0.1674666011843745, target_prob: float=0.008177252610909756):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1674666011843745, target_prob=0.008177252610909756):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_336",
    "sat": "def sat(counts: List[int], p: float=0.4652195118502984, target_prob: float=0.09746466998527702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4652195118502984, target_prob=0.09746466998527702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_337",
    "sat": "def sat(counts: List[int], p: float=0.8755449717649674, target_prob: float=0.12445502823503263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8755449717649674, target_prob=0.12445502823503263):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_338",
    "sat": "def sat(counts: List[int], p: float=0.6876931072304912, target_prob: float=0.4729218097323278):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6876931072304912, target_prob=0.4729218097323278):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_339",
    "sat": "def sat(counts: List[int], p: float=0.04716365009186385, target_prob: float=0.6473883067840019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04716365009186385, target_prob=0.6473883067840019):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_340",
    "sat": "def sat(counts: List[int], p: float=0.5027208550997595, target_prob: float=0.4972791449002405):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5027208550997595, target_prob=0.4972791449002405):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_341",
    "sat": "def sat(counts: List[int], p: float=0.6422456513458488, target_prob: float=0.6422456513458488):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6422456513458488, target_prob=0.6422456513458488):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_342",
    "sat": "def sat(counts: List[int], p: float=0.001041845469113678, target_prob: float=0.006218577336351071):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.001041845469113678, target_prob=0.006218577336351071):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_343",
    "sat": "def sat(counts: List[int], p: float=0.13882134119146572, target_prob: float=0.034172635957983574):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13882134119146572, target_prob=0.034172635957983574):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_344",
    "sat": "def sat(counts: List[int], p: float=0.8933098463401739, target_prob: float=0.054500962678548384):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8933098463401739, target_prob=0.054500962678548384):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_345",
    "sat": "def sat(counts: List[int], p: float=0.02160082087228188, target_prob: float=0.06203312637771373):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02160082087228188, target_prob=0.06203312637771373):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_346",
    "sat": "def sat(counts: List[int], p: float=0.3796768439161887, target_prob: float=0.2612921171809781):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3796768439161887, target_prob=0.2612921171809781):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_347",
    "sat": "def sat(counts: List[int], p: float=0.22210400840727362, target_prob: float=0.0025226370307071424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22210400840727362, target_prob=0.0025226370307071424):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_348",
    "sat": "def sat(counts: List[int], p: float=0.3681740715873497, target_prob: float=0.02775530352705918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3681740715873497, target_prob=0.02775530352705918):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_349",
    "sat": "def sat(counts: List[int], p: float=0.4237740621110493, target_prob: float=0.09529645790070074):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4237740621110493, target_prob=0.09529645790070074):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_350",
    "sat": "def sat(counts: List[int], p: float=0.8838557833882893, target_prob: float=0.007773453914935448):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8838557833882893, target_prob=0.007773453914935448):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_351",
    "sat": "def sat(counts: List[int], p: float=0.9361323098899623, target_prob: float=0.0042745000686715065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9361323098899623, target_prob=0.0042745000686715065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_352",
    "sat": "def sat(counts: List[int], p: float=0.9849467282912765, target_prob: float=0.8992681118212396):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9849467282912765, target_prob=0.8992681118212396):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_353",
    "sat": "def sat(counts: List[int], p: float=0.12466704708926213, target_prob: float=0.22030217975822428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12466704708926213, target_prob=0.22030217975822428):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_354",
    "sat": "def sat(counts: List[int], p: float=0.4273493924490054, target_prob: float=0.10753724430458796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4273493924490054, target_prob=0.10753724430458796):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_355",
    "sat": "def sat(counts: List[int], p: float=0.7586255958459174, target_prob: float=2.7811277110313357e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7586255958459174, target_prob=2.7811277110313357e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_356",
    "sat": "def sat(counts: List[int], p: float=0.7028624276252867, target_prob: float=0.30656750984248327):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7028624276252867, target_prob=0.30656750984248327):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_357",
    "sat": "def sat(counts: List[int], p: float=0.9392921835579119, target_prob: float=0.04303118609130339):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9392921835579119, target_prob=0.04303118609130339):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_358",
    "sat": "def sat(counts: List[int], p: float=0.34766442817141796, target_prob: float=0.3086127664942812):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34766442817141796, target_prob=0.3086127664942812):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_359",
    "sat": "def sat(counts: List[int], p: float=0.2285827426203637, target_prob: float=0.07107371528285589):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2285827426203637, target_prob=0.07107371528285589):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_360",
    "sat": "def sat(counts: List[int], p: float=0.2865785083628465, target_prob: float=0.4162384290565352):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2865785083628465, target_prob=0.4162384290565352):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_361",
    "sat": "def sat(counts: List[int], p: float=0.6115995775389845, target_prob: float=0.022757197284148194):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6115995775389845, target_prob=0.022757197284148194):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_362",
    "sat": "def sat(counts: List[int], p: float=0.5687034515786688, target_prob: float=0.0323225865517019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5687034515786688, target_prob=0.0323225865517019):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_363",
    "sat": "def sat(counts: List[int], p: float=0.11156872763319281, target_prob: float=0.3129492988871294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11156872763319281, target_prob=0.3129492988871294):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_364",
    "sat": "def sat(counts: List[int], p: float=0.06085955986225122, target_prob: float=0.8819847663021245):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06085955986225122, target_prob=0.8819847663021245):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_365",
    "sat": "def sat(counts: List[int], p: float=0.7843538387259917, target_prob: float=0.03146278863162218):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7843538387259917, target_prob=0.03146278863162218):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_366",
    "sat": "def sat(counts: List[int], p: float=0.8285655646350923, target_prob: float=0.2840893394720459):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8285655646350923, target_prob=0.2840893394720459):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_367",
    "sat": "def sat(counts: List[int], p: float=0.6692621974974249, target_prob: float=0.01641548205250994):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6692621974974249, target_prob=0.01641548205250994):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_368",
    "sat": "def sat(counts: List[int], p: float=0.6574017927612988, target_prob: float=0.018616908518612293):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6574017927612988, target_prob=0.018616908518612293):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_369",
    "sat": "def sat(counts: List[int], p: float=0.9952057717004338, target_prob: float=0.014245107729387203):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9952057717004338, target_prob=0.014245107729387203):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_370",
    "sat": "def sat(counts: List[int], p: float=0.5569659976217916, target_prob: float=0.10728695600844697):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5569659976217916, target_prob=0.10728695600844697):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_371",
    "sat": "def sat(counts: List[int], p: float=0.8738278666887814, target_prob: float=0.3856951240415316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8738278666887814, target_prob=0.3856951240415316):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_372",
    "sat": "def sat(counts: List[int], p: float=0.31657246346774004, target_prob: float=0.68342753653226):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.31657246346774004, target_prob=0.68342753653226):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_373",
    "sat": "def sat(counts: List[int], p: float=0.8576006506436363, target_prob: float=0.8576006506436363):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8576006506436363, target_prob=0.8576006506436363):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_374",
    "sat": "def sat(counts: List[int], p: float=0.8446706628203982, target_prob: float=0.0005821219240557357):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8446706628203982, target_prob=0.0005821219240557357):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_375",
    "sat": "def sat(counts: List[int], p: float=0.5206610761936293, target_prob: float=0.3588903321554827):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5206610761936293, target_prob=0.3588903321554827):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_376",
    "sat": "def sat(counts: List[int], p: float=0.4443413231009642, target_prob: float=0.1715632645102504):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4443413231009642, target_prob=0.1715632645102504):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_377",
    "sat": "def sat(counts: List[int], p: float=0.06472723403181524, target_prob: float=7.353977437393023e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06472723403181524, target_prob=7.353977437393023e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_378",
    "sat": "def sat(counts: List[int], p: float=0.7719645370066748, target_prob: float=0.007716599365166802):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7719645370066748, target_prob=0.007716599365166802):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_379",
    "sat": "def sat(counts: List[int], p: float=0.7150198375420842, target_prob: float=0.0005356582254908654):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7150198375420842, target_prob=0.0005356582254908654):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_380",
    "sat": "def sat(counts: List[int], p: float=0.5019805401508609, target_prob: float=0.25198050901432945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5019805401508609, target_prob=0.25198050901432945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_381",
    "sat": "def sat(counts: List[int], p: float=0.4294043751548742, target_prob: float=0.031551835649904963):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4294043751548742, target_prob=0.031551835649904963):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_382",
    "sat": "def sat(counts: List[int], p: float=0.1796206978573106, target_prob: float=0.0001928639294649506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1796206978573106, target_prob=0.0001928639294649506):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_383",
    "sat": "def sat(counts: List[int], p: float=0.684853007213285, target_prob: float=0.04839259784433552):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.684853007213285, target_prob=0.04839259784433552):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_384",
    "sat": "def sat(counts: List[int], p: float=0.3808904062537922, target_prob: float=0.26945661918762875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3808904062537922, target_prob=0.26945661918762875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_385",
    "sat": "def sat(counts: List[int], p: float=0.509537343012714, target_prob: float=0.49046265698728597):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.509537343012714, target_prob=0.49046265698728597):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_386",
    "sat": "def sat(counts: List[int], p: float=0.763020190400537, target_prob: float=0.15788693831764417):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.763020190400537, target_prob=0.15788693831764417):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_387",
    "sat": "def sat(counts: List[int], p: float=0.7853538563520965, target_prob: float=0.00988938468930019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7853538563520965, target_prob=0.00988938468930019):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_388",
    "sat": "def sat(counts: List[int], p: float=0.07714228176730609, target_prob: float=0.0647463387623653):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07714228176730609, target_prob=0.0647463387623653):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_389",
    "sat": "def sat(counts: List[int], p: float=0.20922303694510935, target_prob: float=0.3308975155131495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20922303694510935, target_prob=0.3308975155131495):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_390",
    "sat": "def sat(counts: List[int], p: float=0.48150807231940584, target_prob: float=0.48150807231940584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48150807231940584, target_prob=0.48150807231940584):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_391",
    "sat": "def sat(counts: List[int], p: float=0.8217003032177763, target_prob: float=0.17829969678222368):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8217003032177763, target_prob=0.17829969678222368):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_392",
    "sat": "def sat(counts: List[int], p: float=0.9413749047033001, target_prob: float=0.003436901798547145):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9413749047033001, target_prob=0.003436901798547145):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_393",
    "sat": "def sat(counts: List[int], p: float=0.39025443014029626, target_prob: float=0.19735237639076053):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39025443014029626, target_prob=0.19735237639076053):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_394",
    "sat": "def sat(counts: List[int], p: float=0.578443348732594, target_prob: float=0.19354524007282667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.578443348732594, target_prob=0.19354524007282667):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_395",
    "sat": "def sat(counts: List[int], p: float=0.728104055193706, target_prob: float=0.020100561575746308):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.728104055193706, target_prob=0.020100561575746308):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_396",
    "sat": "def sat(counts: List[int], p: float=0.012652032835877569, target_prob: float=0.08205022351275287):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.012652032835877569, target_prob=0.08205022351275287):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_397",
    "sat": "def sat(counts: List[int], p: float=0.8003335664166902, target_prob: float=0.2628005022624104):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8003335664166902, target_prob=0.2628005022624104):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_398",
    "sat": "def sat(counts: List[int], p: float=0.5396009066185813, target_prob: float=0.09758956434231779):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5396009066185813, target_prob=0.09758956434231779):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_399",
    "sat": "def sat(counts: List[int], p: float=0.22864904538426278, target_prob: float=0.22864904538426278):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22864904538426278, target_prob=0.22864904538426278):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_400",
    "sat": "def sat(counts: List[int], p: float=0.002019175922431393, target_prob: float=0.9959657252265429):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.002019175922431393, target_prob=0.9959657252265429):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_401",
    "sat": "def sat(counts: List[int], p: float=0.0032797242849708086, target_prob: float=1.4065179892824243e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0032797242849708086, target_prob=1.4065179892824243e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_402",
    "sat": "def sat(counts: List[int], p: float=0.7586762606393317, target_prob: float=1.1502715262511587e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7586762606393317, target_prob=1.1502715262511587e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_403",
    "sat": "def sat(counts: List[int], p: float=0.579030822957802, target_prob: float=0.09092281654471905):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.579030822957802, target_prob=0.09092281654471905):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_404",
    "sat": "def sat(counts: List[int], p: float=0.42938505249270054, target_prob: float=0.006267315122558216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42938505249270054, target_prob=0.006267315122558216):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_405",
    "sat": "def sat(counts: List[int], p: float=0.14392799332873107, target_prob: float=0.14392799332873107):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14392799332873107, target_prob=0.14392799332873107):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_406",
    "sat": "def sat(counts: List[int], p: float=0.9332049112567153, target_prob: float=0.6163666187037937):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9332049112567153, target_prob=0.6163666187037937):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_407",
    "sat": "def sat(counts: List[int], p: float=0.45711695372235006, target_prob: float=0.018723362350876967):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45711695372235006, target_prob=0.018723362350876967):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_408",
    "sat": "def sat(counts: List[int], p: float=0.7267176489284567, target_prob: float=0.2732823510715433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7267176489284567, target_prob=0.2732823510715433):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_409",
    "sat": "def sat(counts: List[int], p: float=0.05154428001035094, target_prob: float=1.3237463516339884e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05154428001035094, target_prob=1.3237463516339884e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_410",
    "sat": "def sat(counts: List[int], p: float=0.691823677622676, target_prob: float=0.691823677622676):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.691823677622676, target_prob=0.691823677622676):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_411",
    "sat": "def sat(counts: List[int], p: float=0.07490465728192008, target_prob: float=0.07490465728192008):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07490465728192008, target_prob=0.07490465728192008):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_412",
    "sat": "def sat(counts: List[int], p: float=0.5560464392531842, target_prob: float=0.3053027575675511):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5560464392531842, target_prob=0.3053027575675511):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_413",
    "sat": "def sat(counts: List[int], p: float=0.4159287522114954, target_prob: float=0.0008956772545174699):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4159287522114954, target_prob=0.0008956772545174699):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_414",
    "sat": "def sat(counts: List[int], p: float=0.27880532462093466, target_prob: float=0.27880532462093466):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27880532462093466, target_prob=0.27880532462093466):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_415",
    "sat": "def sat(counts: List[int], p: float=0.21463678886685056, target_prob: float=0.00045553401510145964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21463678886685056, target_prob=0.00045553401510145964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_416",
    "sat": "def sat(counts: List[int], p: float=0.7032067205765316, target_prob: float=0.08808625071093702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7032067205765316, target_prob=0.08808625071093702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_417",
    "sat": "def sat(counts: List[int], p: float=0.01814570358787304, target_prob: float=0.006309604589381295):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.01814570358787304, target_prob=0.006309604589381295):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_418",
    "sat": "def sat(counts: List[int], p: float=0.0656961929517671, target_prob: float=0.007562077570986875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0656961929517671, target_prob=0.007562077570986875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_419",
    "sat": "def sat(counts: List[int], p: float=0.795939382476688, target_prob: float=0.40134695761180217):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.795939382476688, target_prob=0.40134695761180217):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_420",
    "sat": "def sat(counts: List[int], p: float=0.03637649230174267, target_prob: float=3.68266937577574e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03637649230174267, target_prob=3.68266937577574e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_421",
    "sat": "def sat(counts: List[int], p: float=0.5921871471308604, target_prob: float=0.1781997315753473):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5921871471308604, target_prob=0.1781997315753473):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_422",
    "sat": "def sat(counts: List[int], p: float=0.009931940478111523, target_prob: float=0.019666594072901545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.009931940478111523, target_prob=0.019666594072901545):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_423",
    "sat": "def sat(counts: List[int], p: float=0.5460560679203841, target_prob: float=0.40606723179239773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5460560679203841, target_prob=0.40606723179239773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_424",
    "sat": "def sat(counts: List[int], p: float=0.7445006864474609, target_prob: float=0.00045296080106279246):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7445006864474609, target_prob=0.00045296080106279246):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_425",
    "sat": "def sat(counts: List[int], p: float=0.04552189867598211, target_prob: float=0.8695567013015817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04552189867598211, target_prob=0.8695567013015817):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_426",
    "sat": "def sat(counts: List[int], p: float=0.3014574680945298, target_prob: float=0.30084414765952094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3014574680945298, target_prob=0.30084414765952094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_427",
    "sat": "def sat(counts: List[int], p: float=0.25551177497984157, target_prob: float=3.455859705562581e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25551177497984157, target_prob=3.455859705562581e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_428",
    "sat": "def sat(counts: List[int], p: float=0.47476913114108954, target_prob: float=0.10701568158193235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47476913114108954, target_prob=0.10701568158193235):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_429",
    "sat": "def sat(counts: List[int], p: float=0.05745965820660237, target_prob: float=5.1371483228875534e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05745965820660237, target_prob=5.1371483228875534e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_430",
    "sat": "def sat(counts: List[int], p: float=0.7738987099792992, target_prob: float=0.03578106267666329):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7738987099792992, target_prob=0.03578106267666329):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_431",
    "sat": "def sat(counts: List[int], p: float=0.004794454056312958, target_prob: float=1.102091071096482e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.004794454056312958, target_prob=1.102091071096482e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_432",
    "sat": "def sat(counts: List[int], p: float=0.6060690708358131, target_prob: float=0.22262112056599018):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6060690708358131, target_prob=0.22262112056599018):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_433",
    "sat": "def sat(counts: List[int], p: float=0.520059629801041, target_prob: float=0.05305778659918389):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.520059629801041, target_prob=0.05305778659918389):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_434",
    "sat": "def sat(counts: List[int], p: float=0.06314002928867146, target_prob: float=0.019134554955820726):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06314002928867146, target_prob=0.019134554955820726):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_435",
    "sat": "def sat(counts: List[int], p: float=0.07788194353087041, target_prob: float=0.24426224862783252):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07788194353087041, target_prob=0.24426224862783252):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_436",
    "sat": "def sat(counts: List[int], p: float=0.41072605618411584, target_prob: float=0.1686958932285575):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41072605618411584, target_prob=0.1686958932285575):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_437",
    "sat": "def sat(counts: List[int], p: float=0.1600955184560151, target_prob: float=0.12100301793511985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1600955184560151, target_prob=0.12100301793511985):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_438",
    "sat": "def sat(counts: List[int], p: float=0.4322251377410856, target_prob: float=0.29558918603535467):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4322251377410856, target_prob=0.29558918603535467):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_439",
    "sat": "def sat(counts: List[int], p: float=0.638504592375211, target_prob: float=0.1306789297338124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.638504592375211, target_prob=0.1306789297338124):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_440",
    "sat": "def sat(counts: List[int], p: float=0.7551461977301819, target_prob: float=0.059953384485987186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7551461977301819, target_prob=0.059953384485987186):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_441",
    "sat": "def sat(counts: List[int], p: float=0.519327981002036, target_prob: float=0.23104558984757903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.519327981002036, target_prob=0.23104558984757903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_442",
    "sat": "def sat(counts: List[int], p: float=0.25255802883453027, target_prob: float=0.06040791458790018):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25255802883453027, target_prob=0.06040791458790018):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_443",
    "sat": "def sat(counts: List[int], p: float=0.08941832310311448, target_prob: float=0.687504631195886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08941832310311448, target_prob=0.687504631195886):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_444",
    "sat": "def sat(counts: List[int], p: float=0.5190986205673751, target_prob: float=0.0013756381308388712):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5190986205673751, target_prob=0.0013756381308388712):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_445",
    "sat": "def sat(counts: List[int], p: float=0.881292272951052, target_prob: float=0.3638812671882343):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.881292272951052, target_prob=0.3638812671882343):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_446",
    "sat": "def sat(counts: List[int], p: float=0.5413576842831185, target_prob: float=0.12404433425881098):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5413576842831185, target_prob=0.12404433425881098):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_447",
    "sat": "def sat(counts: List[int], p: float=0.7583176328327391, target_prob: float=0.3306774791871099):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7583176328327391, target_prob=0.3306774791871099):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_448",
    "sat": "def sat(counts: List[int], p: float=0.9228718797644311, target_prob: float=0.5701510015580487):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9228718797644311, target_prob=0.5701510015580487):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_449",
    "sat": "def sat(counts: List[int], p: float=0.7402375974184394, target_prob: float=0.05189912171523292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7402375974184394, target_prob=0.05189912171523292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_450",
    "sat": "def sat(counts: List[int], p: float=0.8235652090530055, target_prob: float=0.3788697743475816):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8235652090530055, target_prob=0.3788697743475816):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_451",
    "sat": "def sat(counts: List[int], p: float=0.9028860454700528, target_prob: float=0.38600032950865):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9028860454700528, target_prob=0.38600032950865):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_452",
    "sat": "def sat(counts: List[int], p: float=0.02164525530333039, target_prob: float=9.550488126039857e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02164525530333039, target_prob=9.550488126039857e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_453",
    "sat": "def sat(counts: List[int], p: float=0.09327972567066478, target_prob: float=0.09327972567066478):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09327972567066478, target_prob=0.09327972567066478):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_454",
    "sat": "def sat(counts: List[int], p: float=0.25927887468775324, target_prob: float=0.1567531267556343):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25927887468775324, target_prob=0.1567531267556343):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_455",
    "sat": "def sat(counts: List[int], p: float=0.07362930494795594, target_prob: float=0.18955776159166257):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07362930494795594, target_prob=0.18955776159166257):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_456",
    "sat": "def sat(counts: List[int], p: float=0.7317076923901465, target_prob: float=0.3926230905744664):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7317076923901465, target_prob=0.3926230905744664):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_457",
    "sat": "def sat(counts: List[int], p: float=0.11300066520764118, target_prob: float=0.33986750801529986):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11300066520764118, target_prob=0.33986750801529986):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_458",
    "sat": "def sat(counts: List[int], p: float=0.12972760876651945, target_prob: float=0.49920167087559386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12972760876651945, target_prob=0.49920167087559386):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_459",
    "sat": "def sat(counts: List[int], p: float=0.7669663479233335, target_prob: float=0.21636801644671794):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7669663479233335, target_prob=0.21636801644671794):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_460",
    "sat": "def sat(counts: List[int], p: float=0.1749930878508883, target_prob: float=0.5615297388627178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1749930878508883, target_prob=0.5615297388627178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_461",
    "sat": "def sat(counts: List[int], p: float=0.05394843477760969, target_prob: float=0.9460515652223903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05394843477760969, target_prob=0.9460515652223903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_462",
    "sat": "def sat(counts: List[int], p: float=0.49948564824946007, target_prob: float=0.007756416095930965):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49948564824946007, target_prob=0.007756416095930965):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_463",
    "sat": "def sat(counts: List[int], p: float=0.6473494490957523, target_prob: float=0.0005460593935153316):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6473494490957523, target_prob=0.0005460593935153316):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_464",
    "sat": "def sat(counts: List[int], p: float=0.42649707714798524, target_prob: float=0.16324006806888805):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42649707714798524, target_prob=0.16324006806888805):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_465",
    "sat": "def sat(counts: List[int], p: float=0.24077659906698645, target_prob: float=0.003686313060951004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24077659906698645, target_prob=0.003686313060951004):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_466",
    "sat": "def sat(counts: List[int], p: float=0.9486223951303996, target_prob: float=0.6557631168370438):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9486223951303996, target_prob=0.6557631168370438):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_467",
    "sat": "def sat(counts: List[int], p: float=0.7220239940735979, target_prob: float=0.007190174542650106):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7220239940735979, target_prob=0.007190174542650106):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_468",
    "sat": "def sat(counts: List[int], p: float=0.9623428971915339, target_prob: float=1.1484156706289902e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9623428971915339, target_prob=1.1484156706289902e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_469",
    "sat": "def sat(counts: List[int], p: float=0.9800700164440485, target_prob: float=0.9605372371326374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9800700164440485, target_prob=0.9605372371326374):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_470",
    "sat": "def sat(counts: List[int], p: float=0.5418424405022294, target_prob: float=0.2375964338400216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5418424405022294, target_prob=0.2375964338400216):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_471",
    "sat": "def sat(counts: List[int], p: float=0.45097919300078004, target_prob: float=0.29852651285764215):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45097919300078004, target_prob=0.29852651285764215):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_472",
    "sat": "def sat(counts: List[int], p: float=0.9044605092803994, target_prob: float=0.02042561997922382):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9044605092803994, target_prob=0.02042561997922382):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_473",
    "sat": "def sat(counts: List[int], p: float=0.08725130032492723, target_prob: float=0.00026448975815971195):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08725130032492723, target_prob=0.00026448975815971195):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_474",
    "sat": "def sat(counts: List[int], p: float=0.38128695177096217, target_prob: float=0.6187130482290378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38128695177096217, target_prob=0.6187130482290378):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_475",
    "sat": "def sat(counts: List[int], p: float=0.7132592433840347, target_prob: float=0.3175979715381668):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7132592433840347, target_prob=0.3175979715381668):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_476",
    "sat": "def sat(counts: List[int], p: float=0.9757036404395544, target_prob: float=4.9761324795342155e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9757036404395544, target_prob=4.9761324795342155e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_477",
    "sat": "def sat(counts: List[int], p: float=0.8383418083255129, target_prob: float=0.00010473828626042879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8383418083255129, target_prob=0.00010473828626042879):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_478",
    "sat": "def sat(counts: List[int], p: float=0.937652788566032, target_prob: float=0.2965974214912581):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.937652788566032, target_prob=0.2965974214912581):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_479",
    "sat": "def sat(counts: List[int], p: float=0.17739301104452465, target_prob: float=5.527840940576513e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17739301104452465, target_prob=5.527840940576513e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_480",
    "sat": "def sat(counts: List[int], p: float=0.06960956435820664, target_prob: float=0.0709387142062555):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06960956435820664, target_prob=0.0709387142062555):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_481",
    "sat": "def sat(counts: List[int], p: float=0.2601255311787377, target_prob: float=0.09604220558804095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2601255311787377, target_prob=0.09604220558804095):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_482",
    "sat": "def sat(counts: List[int], p: float=0.2614818538788898, target_prob: float=0.06590491108612216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2614818538788898, target_prob=0.06590491108612216):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_483",
    "sat": "def sat(counts: List[int], p: float=0.26319256394213586, target_prob: float=0.00015268115216800725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26319256394213586, target_prob=0.00015268115216800725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_484",
    "sat": "def sat(counts: List[int], p: float=0.14685593632855676, target_prob: float=0.2723795592547165):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14685593632855676, target_prob=0.2723795592547165):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_485",
    "sat": "def sat(counts: List[int], p: float=0.0019527015623298505, target_prob: float=1.8988061196472374e-21):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0019527015623298505, target_prob=1.8988061196472374e-21):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_486",
    "sat": "def sat(counts: List[int], p: float=0.4505931881091588, target_prob: float=0.36771265267078485):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4505931881091588, target_prob=0.36771265267078485):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_487",
    "sat": "def sat(counts: List[int], p: float=0.3080887714142355, target_prob: float=0.1585812704241233):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3080887714142355, target_prob=0.1585812704241233):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_488",
    "sat": "def sat(counts: List[int], p: float=0.7228439167085787, target_prob: float=0.005693584163527483):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7228439167085787, target_prob=0.005693584163527483):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_489",
    "sat": "def sat(counts: List[int], p: float=0.5852502178834422, target_prob: float=0.249697080899216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5852502178834422, target_prob=0.249697080899216):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_490",
    "sat": "def sat(counts: List[int], p: float=0.24360235729660318, target_prob: float=0.013318217936812904):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24360235729660318, target_prob=0.013318217936812904):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_491",
    "sat": "def sat(counts: List[int], p: float=0.04039476287965016, target_prob: float=0.004697469732702457):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04039476287965016, target_prob=0.004697469732702457):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_492",
    "sat": "def sat(counts: List[int], p: float=0.0399199853613903, target_prob: float=0.7218707337159219):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0399199853613903, target_prob=0.7218707337159219):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_493",
    "sat": "def sat(counts: List[int], p: float=0.36957264980842774, target_prob: float=0.006894441946752267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36957264980842774, target_prob=0.006894441946752267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_494",
    "sat": "def sat(counts: List[int], p: float=0.00912448708893121, target_prob: float=0.00024748978177298363):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.00912448708893121, target_prob=0.00024748978177298363):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_495",
    "sat": "def sat(counts: List[int], p: float=0.36976231760187883, target_prob: float=0.4406082632941845):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36976231760187883, target_prob=0.4406082632941845):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_496",
    "sat": "def sat(counts: List[int], p: float=0.42178631951070666, target_prob: float=0.5782136804892933):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42178631951070666, target_prob=0.5782136804892933):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_497",
    "sat": "def sat(counts: List[int], p: float=0.9101930773930522, target_prob: float=0.040090173532311896):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9101930773930522, target_prob=0.040090173532311896):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_498",
    "sat": "def sat(counts: List[int], p: float=0.5810107881394058, target_prob: float=0.4243190092984114):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5810107881394058, target_prob=0.4243190092984114):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_499",
    "sat": "def sat(counts: List[int], p: float=0.5831509910992806, target_prob: float=0.2931760143353202):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5831509910992806, target_prob=0.2931760143353202):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_500",
    "sat": "def sat(counts: List[int], p: float=0.5178013939944505, target_prob: float=0.02510931448029342):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5178013939944505, target_prob=0.02510931448029342):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_501",
    "sat": "def sat(counts: List[int], p: float=0.7384962011941455, target_prob: float=0.06592116135924049):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7384962011941455, target_prob=0.06592116135924049):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_502",
    "sat": "def sat(counts: List[int], p: float=0.5066645112322155, target_prob: float=0.15005826564982086):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5066645112322155, target_prob=0.15005826564982086):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_503",
    "sat": "def sat(counts: List[int], p: float=0.4724794951756567, target_prob: float=0.13759821927807483):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4724794951756567, target_prob=0.13759821927807483):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_504",
    "sat": "def sat(counts: List[int], p: float=0.8028152336662766, target_prob: float=0.27315792374848985):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8028152336662766, target_prob=0.27315792374848985):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_505",
    "sat": "def sat(counts: List[int], p: float=0.8093857865287385, target_prob: float=0.19265366861693153):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8093857865287385, target_prob=0.19265366861693153):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_506",
    "sat": "def sat(counts: List[int], p: float=0.7483067286357381, target_prob: float=0.004535121516095452):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7483067286357381, target_prob=0.004535121516095452):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_507",
    "sat": "def sat(counts: List[int], p: float=0.46456736413280675, target_prob: float=0.08602736963953732):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46456736413280675, target_prob=0.08602736963953732):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_508",
    "sat": "def sat(counts: List[int], p: float=0.35537488311120813, target_prob: float=0.0020142824976485006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35537488311120813, target_prob=0.0020142824976485006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_509",
    "sat": "def sat(counts: List[int], p: float=0.53786321471527, target_prob: float=0.19338728498090343):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.53786321471527, target_prob=0.19338728498090343):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_510",
    "sat": "def sat(counts: List[int], p: float=0.546904667277651, target_prob: float=0.0489280771207916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.546904667277651, target_prob=0.0489280771207916):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_511",
    "sat": "def sat(counts: List[int], p: float=0.8443629030483059, target_prob: float=0.18468604433667826):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8443629030483059, target_prob=0.18468604433667826):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_512",
    "sat": "def sat(counts: List[int], p: float=0.09331686048459642, target_prob: float=0.6758061801743912):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09331686048459642, target_prob=0.6758061801743912):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_513",
    "sat": "def sat(counts: List[int], p: float=0.7089714735781651, target_prob: float=0.12699088993115698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7089714735781651, target_prob=0.12699088993115698):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_514",
    "sat": "def sat(counts: List[int], p: float=0.8721752677582756, target_prob: float=0.0011642153960084581):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8721752677582756, target_prob=0.0011642153960084581):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_515",
    "sat": "def sat(counts: List[int], p: float=0.2797494188332037, target_prob: float=0.05809663514147362):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2797494188332037, target_prob=0.05809663514147362):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_516",
    "sat": "def sat(counts: List[int], p: float=0.8598282868034156, target_prob: float=7.313485171072349e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8598282868034156, target_prob=7.313485171072349e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_517",
    "sat": "def sat(counts: List[int], p: float=0.4671608058728731, target_prob: float=0.02225010140989479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4671608058728731, target_prob=0.02225010140989479):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_518",
    "sat": "def sat(counts: List[int], p: float=0.4975317897018987, target_prob: float=0.1148822316073032):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4975317897018987, target_prob=0.1148822316073032):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_519",
    "sat": "def sat(counts: List[int], p: float=0.6183840216656594, target_prob: float=0.6183840216656594):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6183840216656594, target_prob=0.6183840216656594):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_520",
    "sat": "def sat(counts: List[int], p: float=0.27623363355504216, target_prob: float=6.777778981364455e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27623363355504216, target_prob=6.777778981364455e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_521",
    "sat": "def sat(counts: List[int], p: float=0.3949864708378905, target_prob: float=0.3426461557821213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3949864708378905, target_prob=0.3426461557821213):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_522",
    "sat": "def sat(counts: List[int], p: float=0.938553281636686, target_prob: float=0.009461909092688493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.938553281636686, target_prob=0.009461909092688493):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_523",
    "sat": "def sat(counts: List[int], p: float=0.8860091891040542, target_prob: float=0.12011129510108773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8860091891040542, target_prob=0.12011129510108773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_524",
    "sat": "def sat(counts: List[int], p: float=0.7191582746988099, target_prob: float=0.4357444364680225):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7191582746988099, target_prob=0.4357444364680225):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_525",
    "sat": "def sat(counts: List[int], p: float=0.9760192348595722, target_prob: float=0.8235064645348678):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9760192348595722, target_prob=0.8235064645348678):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_526",
    "sat": "def sat(counts: List[int], p: float=0.8133005800108387, target_prob: float=0.8133005800108387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8133005800108387, target_prob=0.8133005800108387):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_527",
    "sat": "def sat(counts: List[int], p: float=0.5807431967958561, target_prob: float=0.24891126634646393):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5807431967958561, target_prob=0.24891126634646393):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_528",
    "sat": "def sat(counts: List[int], p: float=0.5202632675994463, target_prob: float=0.27067386761325307):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5202632675994463, target_prob=0.27067386761325307):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_529",
    "sat": "def sat(counts: List[int], p: float=0.7551122527696452, target_prob: float=0.10570417450823631):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7551122527696452, target_prob=0.10570417450823631):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_530",
    "sat": "def sat(counts: List[int], p: float=0.20728101486555706, target_prob: float=0.49814729709433114):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20728101486555706, target_prob=0.49814729709433114):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_531",
    "sat": "def sat(counts: List[int], p: float=0.4292109903837642, target_prob: float=0.16585394252267915):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4292109903837642, target_prob=0.16585394252267915):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_532",
    "sat": "def sat(counts: List[int], p: float=0.0834885512247806, target_prob: float=1.8062598055585882e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0834885512247806, target_prob=1.8062598055585882e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_533",
    "sat": "def sat(counts: List[int], p: float=0.13330533798174093, target_prob: float=0.8666946620182591):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.13330533798174093, target_prob=0.8666946620182591):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_534",
    "sat": "def sat(counts: List[int], p: float=0.19797353604591472, target_prob: float=0.8020264639540853):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19797353604591472, target_prob=0.8020264639540853):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_535",
    "sat": "def sat(counts: List[int], p: float=0.8713590474709095, target_prob: float=0.00018418091710954587):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8713590474709095, target_prob=0.00018418091710954587):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_536",
    "sat": "def sat(counts: List[int], p: float=0.593134809691134, target_prob: float=0.40686519030886603):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.593134809691134, target_prob=0.40686519030886603):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_537",
    "sat": "def sat(counts: List[int], p: float=0.8254042166792424, target_prob: float=0.005322323306889175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8254042166792424, target_prob=0.005322323306889175):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_538",
    "sat": "def sat(counts: List[int], p: float=0.19044328101954555, target_prob: float=0.3083492754681119):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19044328101954555, target_prob=0.3083492754681119):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_539",
    "sat": "def sat(counts: List[int], p: float=0.5409850629192355, target_prob: float=0.4966404492350126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5409850629192355, target_prob=0.4966404492350126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_540",
    "sat": "def sat(counts: List[int], p: float=0.6941610235856737, target_prob: float=0.0016598758853057314):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6941610235856737, target_prob=0.0016598758853057314):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_541",
    "sat": "def sat(counts: List[int], p: float=0.8233002569994242, target_prob: float=0.17669974300057578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8233002569994242, target_prob=0.17669974300057578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_542",
    "sat": "def sat(counts: List[int], p: float=0.4457991754378311, target_prob: float=0.03045094485488828):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4457991754378311, target_prob=0.03045094485488828):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_543",
    "sat": "def sat(counts: List[int], p: float=0.8312447087036954, target_prob: float=0.00013686329603691775):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8312447087036954, target_prob=0.00013686329603691775):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_544",
    "sat": "def sat(counts: List[int], p: float=0.005611563651162443, target_prob: float=0.0006429355027144955):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.005611563651162443, target_prob=0.0006429355027144955):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_545",
    "sat": "def sat(counts: List[int], p: float=0.5142513847579132, target_prob: float=0.4857486152420868):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5142513847579132, target_prob=0.4857486152420868):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_546",
    "sat": "def sat(counts: List[int], p: float=0.19142567195412008, target_prob: float=0.3095637681420674):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19142567195412008, target_prob=0.3095637681420674):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_547",
    "sat": "def sat(counts: List[int], p: float=0.5876646058351611, target_prob: float=0.0008356124922434082):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5876646058351611, target_prob=0.0008356124922434082):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_548",
    "sat": "def sat(counts: List[int], p: float=0.09694831159748984, target_prob: float=0.013421114224973081):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09694831159748984, target_prob=0.013421114224973081):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_549",
    "sat": "def sat(counts: List[int], p: float=0.1729074926391826, target_prob: float=0.07418275658569744):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1729074926391826, target_prob=0.07418275658569744):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_550",
    "sat": "def sat(counts: List[int], p: float=0.11594473552070261, target_prob: float=0.6108262026363493):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11594473552070261, target_prob=0.6108262026363493):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_551",
    "sat": "def sat(counts: List[int], p: float=0.6803862253094359, target_prob: float=0.08885706591183017):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6803862253094359, target_prob=0.08885706591183017):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_552",
    "sat": "def sat(counts: List[int], p: float=0.5654864759496632, target_prob: float=0.22215812131695725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5654864759496632, target_prob=0.22215812131695725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_553",
    "sat": "def sat(counts: List[int], p: float=0.6318956427387857, target_prob: float=0.25231094026302414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6318956427387857, target_prob=0.25231094026302414):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_554",
    "sat": "def sat(counts: List[int], p: float=0.1086112728535148, target_prob: float=0.01018026270308041):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1086112728535148, target_prob=0.01018026270308041):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_555",
    "sat": "def sat(counts: List[int], p: float=0.19293326257952248, target_prob: float=0.0006277104388572196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19293326257952248, target_prob=0.0006277104388572196):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_556",
    "sat": "def sat(counts: List[int], p: float=0.9789698030907723, target_prob: float=2.216105242412636e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9789698030907723, target_prob=2.216105242412636e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_557",
    "sat": "def sat(counts: List[int], p: float=0.7609922230631486, target_prob: float=0.0002775039762455727):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7609922230631486, target_prob=0.0002775039762455727):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_558",
    "sat": "def sat(counts: List[int], p: float=0.7281954120758224, target_prob: float=0.0320786259695766):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7281954120758224, target_prob=0.0320786259695766):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_559",
    "sat": "def sat(counts: List[int], p: float=0.7641956931184554, target_prob: float=0.05560367114388568):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7641956931184554, target_prob=0.05560367114388568):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_560",
    "sat": "def sat(counts: List[int], p: float=0.04364813817908564, target_prob: float=0.152713994805997):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04364813817908564, target_prob=0.152713994805997):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_561",
    "sat": "def sat(counts: List[int], p: float=0.569063214764239, target_prob: float=0.29373168644973846):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.569063214764239, target_prob=0.29373168644973846):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_562",
    "sat": "def sat(counts: List[int], p: float=0.9987114993658925, target_prob: float=0.9974246589656692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9987114993658925, target_prob=0.9974246589656692):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_563",
    "sat": "def sat(counts: List[int], p: float=0.14686584925858837, target_prob: float=0.0215695776784464):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14686584925858837, target_prob=0.0215695776784464):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_564",
    "sat": "def sat(counts: List[int], p: float=0.24355618701462167, target_prob: float=0.24355618701462167):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24355618701462167, target_prob=0.24355618701462167):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_565",
    "sat": "def sat(counts: List[int], p: float=0.03316105293052041, target_prob: float=0.02515008605195661):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03316105293052041, target_prob=0.02515008605195661):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_566",
    "sat": "def sat(counts: List[int], p: float=0.623549169961405, target_prob: float=0.21291832289886659):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.623549169961405, target_prob=0.21291832289886659):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_567",
    "sat": "def sat(counts: List[int], p: float=0.5848361331759969, target_prob: float=0.17236103631625857):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5848361331759969, target_prob=0.17236103631625857):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_568",
    "sat": "def sat(counts: List[int], p: float=0.2588925476557896, target_prob: float=0.7411074523442104):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2588925476557896, target_prob=0.7411074523442104):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_569",
    "sat": "def sat(counts: List[int], p: float=0.20298372253794206, target_prob: float=0.7970162774620579):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20298372253794206, target_prob=0.7970162774620579):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_570",
    "sat": "def sat(counts: List[int], p: float=0.4266626925066397, target_prob: float=0.18204105317701536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4266626925066397, target_prob=0.18204105317701536):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_571",
    "sat": "def sat(counts: List[int], p: float=0.8669494995685094, target_prob: float=0.2542119373935137):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8669494995685094, target_prob=0.2542119373935137):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_572",
    "sat": "def sat(counts: List[int], p: float=0.501663592053292, target_prob: float=0.501663592053292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.501663592053292, target_prob=0.501663592053292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_573",
    "sat": "def sat(counts: List[int], p: float=0.7717014091885979, target_prob: float=5.125280621326295e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7717014091885979, target_prob=5.125280621326295e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_574",
    "sat": "def sat(counts: List[int], p: float=0.5373569514742997, target_prob: float=0.20138435766262833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5373569514742997, target_prob=0.20138435766262833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_575",
    "sat": "def sat(counts: List[int], p: float=0.38295849276877225, target_prob: float=0.00596302050272444):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38295849276877225, target_prob=0.00596302050272444):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_576",
    "sat": "def sat(counts: List[int], p: float=0.6080069878176264, target_prob: float=0.2226650819398352):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6080069878176264, target_prob=0.2226650819398352):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_577",
    "sat": "def sat(counts: List[int], p: float=0.3164099369169945, target_prob: float=0.4042940301698154):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3164099369169945, target_prob=0.4042940301698154):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_578",
    "sat": "def sat(counts: List[int], p: float=0.3470391539968857, target_prob: float=0.04179606807678297):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3470391539968857, target_prob=0.04179606807678297):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_579",
    "sat": "def sat(counts: List[int], p: float=0.36292372209484924, target_prob: float=0.36292372209484924):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.36292372209484924, target_prob=0.36292372209484924):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_580",
    "sat": "def sat(counts: List[int], p: float=0.5599604039269991, target_prob: float=0.22386664986604354):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5599604039269991, target_prob=0.22386664986604354):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_581",
    "sat": "def sat(counts: List[int], p: float=0.42996948683444447, target_prob: float=0.0036222718135963724):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42996948683444447, target_prob=0.0036222718135963724):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_582",
    "sat": "def sat(counts: List[int], p: float=0.7039363217410067, target_prob: float=5.174296420656177e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7039363217410067, target_prob=5.174296420656177e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_583",
    "sat": "def sat(counts: List[int], p: float=0.4947950290290808, target_prob: float=0.15894032564406413):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4947950290290808, target_prob=0.15894032564406413):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_584",
    "sat": "def sat(counts: List[int], p: float=0.37507332959767137, target_prob: float=0.012179352565720126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37507332959767137, target_prob=0.012179352565720126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_585",
    "sat": "def sat(counts: List[int], p: float=0.6908206552532061, target_prob: float=0.07508569417379207):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6908206552532061, target_prob=0.07508569417379207):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_586",
    "sat": "def sat(counts: List[int], p: float=0.5942330738969245, target_prob: float=0.4057669261030755):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5942330738969245, target_prob=0.4057669261030755):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_587",
    "sat": "def sat(counts: List[int], p: float=0.02030646247969259, target_prob: float=0.003877388124502651):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02030646247969259, target_prob=0.003877388124502651):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_588",
    "sat": "def sat(counts: List[int], p: float=0.19575524196594873, target_prob: float=0.11320937403365477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19575524196594873, target_prob=0.11320937403365477):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_589",
    "sat": "def sat(counts: List[int], p: float=0.17187899631275105, target_prob: float=2.5783202154997295e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17187899631275105, target_prob=2.5783202154997295e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_590",
    "sat": "def sat(counts: List[int], p: float=0.1479790569400562, target_prob: float=0.3501488350157169):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1479790569400562, target_prob=0.3501488350157169):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_591",
    "sat": "def sat(counts: List[int], p: float=0.12295619545875225, target_prob: float=0.37752175389040427):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12295619545875225, target_prob=0.37752175389040427):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_592",
    "sat": "def sat(counts: List[int], p: float=0.8697341787437796, target_prob: float=0.8697341787437796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8697341787437796, target_prob=0.8697341787437796):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_593",
    "sat": "def sat(counts: List[int], p: float=0.9010171956399267, target_prob: float=0.6590711748546949):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9010171956399267, target_prob=0.6590711748546949):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_594",
    "sat": "def sat(counts: List[int], p: float=0.8758964885260555, target_prob: float=0.025688607383477387):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8758964885260555, target_prob=0.025688607383477387):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_595",
    "sat": "def sat(counts: List[int], p: float=0.25333100384106444, target_prob: float=0.5575145898249926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25333100384106444, target_prob=0.5575145898249926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_596",
    "sat": "def sat(counts: List[int], p: float=0.8080557981222214, target_prob: float=0.0013573754530688158):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8080557981222214, target_prob=0.0013573754530688158):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_597",
    "sat": "def sat(counts: List[int], p: float=0.788761024372458, target_prob: float=0.3008699341626773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.788761024372458, target_prob=0.3008699341626773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_598",
    "sat": "def sat(counts: List[int], p: float=0.4649883325898708, target_prob: float=0.23023271587875752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4649883325898708, target_prob=0.23023271587875752):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_599",
    "sat": "def sat(counts: List[int], p: float=0.9238434998593787, target_prob: float=0.7284397386546684):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9238434998593787, target_prob=0.7284397386546684):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_600",
    "sat": "def sat(counts: List[int], p: float=0.4948627364763267, target_prob: float=0.1590237062089931):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4948627364763267, target_prob=0.1590237062089931):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_601",
    "sat": "def sat(counts: List[int], p: float=0.08826900120536008, target_prob: float=0.4353118496884618):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08826900120536008, target_prob=0.4353118496884618):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_602",
    "sat": "def sat(counts: List[int], p: float=0.019466864678872153, target_prob: float=0.8887377888590702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.019466864678872153, target_prob=0.8887377888590702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_603",
    "sat": "def sat(counts: List[int], p: float=0.988174567398806, target_prob: float=0.011825432601193953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.988174567398806, target_prob=0.011825432601193953):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_604",
    "sat": "def sat(counts: List[int], p: float=0.5633491858922706, target_prob: float=0.015873451561073094):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5633491858922706, target_prob=0.015873451561073094):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_605",
    "sat": "def sat(counts: List[int], p: float=0.4239643093509774, target_prob: float=0.03230852946762581):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4239643093509774, target_prob=0.03230852946762581):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_606",
    "sat": "def sat(counts: List[int], p: float=0.4956324382637428, target_prob: float=0.0603446662613476):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4956324382637428, target_prob=0.0603446662613476):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_607",
    "sat": "def sat(counts: List[int], p: float=0.09502664379587689, target_prob: float=7.748666232275295e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09502664379587689, target_prob=7.748666232275295e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_608",
    "sat": "def sat(counts: List[int], p: float=0.060454643935350494, target_prob: float=0.05619108025922136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.060454643935350494, target_prob=0.05619108025922136):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_609",
    "sat": "def sat(counts: List[int], p: float=0.20191053073518395, target_prob: float=0.3237858771298255):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20191053073518395, target_prob=0.3237858771298255):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_610",
    "sat": "def sat(counts: List[int], p: float=0.7385766885594248, target_prob: float=0.3889526189287717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7385766885594248, target_prob=0.3889526189287717):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_611",
    "sat": "def sat(counts: List[int], p: float=0.01384049079554861, target_prob: float=0.027297863220173888):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.01384049079554861, target_prob=0.027297863220173888):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_612",
    "sat": "def sat(counts: List[int], p: float=0.39684187593999687, target_prob: float=0.36379972261958216):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39684187593999687, target_prob=0.36379972261958216):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_613",
    "sat": "def sat(counts: List[int], p: float=0.6752152644552568, target_prob: float=0.39992850190261503):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6752152644552568, target_prob=0.39992850190261503):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_614",
    "sat": "def sat(counts: List[int], p: float=0.3058400652156158, target_prob: float=0.011145066960794234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3058400652156158, target_prob=0.011145066960794234):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_615",
    "sat": "def sat(counts: List[int], p: float=0.6410496263383885, target_prob: float=0.016601129564171518):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6410496263383885, target_prob=0.016601129564171518):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_616",
    "sat": "def sat(counts: List[int], p: float=0.3509497235383906, target_prob: float=0.0006557138129824752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3509497235383906, target_prob=0.0006557138129824752):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_617",
    "sat": "def sat(counts: List[int], p: float=0.12124626571916874, target_prob: float=0.4046413724428695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12124626571916874, target_prob=0.4046413724428695):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_618",
    "sat": "def sat(counts: List[int], p: float=0.8948985148078352, target_prob: float=0.07916606674324497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8948985148078352, target_prob=0.07916606674324497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_619",
    "sat": "def sat(counts: List[int], p: float=0.9375835085032351, target_prob: float=0.7245190331420701):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9375835085032351, target_prob=0.7245190331420701):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_620",
    "sat": "def sat(counts: List[int], p: float=0.5251522132641482, target_prob: float=0.22548042056793702):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5251522132641482, target_prob=0.22548042056793702):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_621",
    "sat": "def sat(counts: List[int], p: float=0.6173115044352612, target_prob: float=0.04981782273446317):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6173115044352612, target_prob=0.04981782273446317):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_622",
    "sat": "def sat(counts: List[int], p: float=0.5834294668207117, target_prob: float=0.19960223683574335):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5834294668207117, target_prob=0.19960223683574335):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_623",
    "sat": "def sat(counts: List[int], p: float=0.15354196076626359, target_prob: float=0.4345374088011001):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15354196076626359, target_prob=0.4345374088011001):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_624",
    "sat": "def sat(counts: List[int], p: float=0.02148119180292707, target_prob: float=1.366495614706376e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02148119180292707, target_prob=1.366495614706376e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_625",
    "sat": "def sat(counts: List[int], p: float=0.42095359246301267, target_prob: float=0.037694694623150095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42095359246301267, target_prob=0.037694694623150095):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_626",
    "sat": "def sat(counts: List[int], p: float=0.37492060222095114, target_prob: float=0.17814473679696066):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37492060222095114, target_prob=0.17814473679696066):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_627",
    "sat": "def sat(counts: List[int], p: float=0.7295219583188037, target_prob: float=0.006336503598206833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7295219583188037, target_prob=0.006336503598206833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_628",
    "sat": "def sat(counts: List[int], p: float=0.49601714329732394, target_prob: float=0.30997137384343415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49601714329732394, target_prob=0.30997137384343415):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_629",
    "sat": "def sat(counts: List[int], p: float=0.09850206837744402, target_prob: float=0.3701108337586797):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09850206837744402, target_prob=0.3701108337586797):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_630",
    "sat": "def sat(counts: List[int], p: float=0.7907712198296741, target_prob: float=0.41384144198762285):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7907712198296741, target_prob=0.41384144198762285):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_631",
    "sat": "def sat(counts: List[int], p: float=0.26881401288871276, target_prob: float=0.39310607872675946):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26881401288871276, target_prob=0.39310607872675946):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_632",
    "sat": "def sat(counts: List[int], p: float=0.8769698501682144, target_prob: float=6.458088262355088e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8769698501682144, target_prob=6.458088262355088e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_633",
    "sat": "def sat(counts: List[int], p: float=0.7188341976974151, target_prob: float=0.0991747489704292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7188341976974151, target_prob=0.0991747489704292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_634",
    "sat": "def sat(counts: List[int], p: float=0.6424189549475536, target_prob: float=0.25166167878818624):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6424189549475536, target_prob=0.25166167878818624):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_635",
    "sat": "def sat(counts: List[int], p: float=0.2014968964086803, target_prob: float=0.39246655573322203):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2014968964086803, target_prob=0.39246655573322203):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_636",
    "sat": "def sat(counts: List[int], p: float=0.3603535453320936, target_prob: float=0.3260685001766439):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3603535453320936, target_prob=0.3260685001766439):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_637",
    "sat": "def sat(counts: List[int], p: float=0.819803190378071, target_prob: float=0.03247089019792171):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.819803190378071, target_prob=0.03247089019792171):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_638",
    "sat": "def sat(counts: List[int], p: float=0.8150119045346294, target_prob: float=0.2935076006873958):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8150119045346294, target_prob=0.2935076006873958):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_639",
    "sat": "def sat(counts: List[int], p: float=0.8759774616001516, target_prob: float=0.0066842821136075875):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8759774616001516, target_prob=0.0066842821136075875):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_640",
    "sat": "def sat(counts: List[int], p: float=0.8348286821915408, target_prob: float=0.025306146737061233):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8348286821915408, target_prob=0.025306146737061233):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_641",
    "sat": "def sat(counts: List[int], p: float=0.7725439016397583, target_prob: float=0.2989718565414013):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7725439016397583, target_prob=0.2989718565414013):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_642",
    "sat": "def sat(counts: List[int], p: float=0.38160637955153953, target_prob: float=0.38160637955153953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.38160637955153953, target_prob=0.38160637955153953):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_643",
    "sat": "def sat(counts: List[int], p: float=0.15444719071216373, target_prob: float=0.0014570092905894635):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15444719071216373, target_prob=0.0014570092905894635):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_644",
    "sat": "def sat(counts: List[int], p: float=0.9259525772491611, target_prob: float=0.11519764720566379):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9259525772491611, target_prob=0.11519764720566379):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_645",
    "sat": "def sat(counts: List[int], p: float=0.2706664242412775, target_prob: float=0.28421526049139484):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2706664242412775, target_prob=0.28421526049139484):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_646",
    "sat": "def sat(counts: List[int], p: float=0.851451584142674, target_prob: float=0.00011823261441782584):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.851451584142674, target_prob=0.00011823261441782584):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_647",
    "sat": "def sat(counts: List[int], p: float=0.7246248764551436, target_prob: float=0.2753751235448564):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7246248764551436, target_prob=0.2753751235448564):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_648",
    "sat": "def sat(counts: List[int], p: float=0.3420910986935194, target_prob: float=0.10807130151965122):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3420910986935194, target_prob=0.10807130151965122):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_649",
    "sat": "def sat(counts: List[int], p: float=0.47098447554395095, target_prob: float=0.021918483459451486):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47098447554395095, target_prob=0.021918483459451486):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_650",
    "sat": "def sat(counts: List[int], p: float=0.5606896314528464, target_prob: float=0.10441871479233346):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5606896314528464, target_prob=0.10441871479233346):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_651",
    "sat": "def sat(counts: List[int], p: float=0.7237978638686768, target_prob: float=0.2631379122064163):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7237978638686768, target_prob=0.2631379122064163):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_652",
    "sat": "def sat(counts: List[int], p: float=0.9924078465885389, target_prob: float=0.9924078465885389):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9924078465885389, target_prob=0.9924078465885389):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_653",
    "sat": "def sat(counts: List[int], p: float=0.07809357577424292, target_prob: float=0.0017562759706835451):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07809357577424292, target_prob=0.0017562759706835451):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_654",
    "sat": "def sat(counts: List[int], p: float=0.09009465031427533, target_prob: float=0.04531602283537621):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09009465031427533, target_prob=0.04531602283537621):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_655",
    "sat": "def sat(counts: List[int], p: float=0.5123516052084517, target_prob: float=0.014745686705458982):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5123516052084517, target_prob=0.014745686705458982):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_656",
    "sat": "def sat(counts: List[int], p: float=0.30247020142566994, target_prob: float=0.008370094902042425):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30247020142566994, target_prob=0.008370094902042425):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_657",
    "sat": "def sat(counts: List[int], p: float=0.7691990340707876, target_prob: float=0.5916671540154327):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7691990340707876, target_prob=0.5916671540154327):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_658",
    "sat": "def sat(counts: List[int], p: float=0.9372087391642702, target_prob: float=0.06279126083572983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9372087391642702, target_prob=0.06279126083572983):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_659",
    "sat": "def sat(counts: List[int], p: float=0.9228386988755128, target_prob: float=0.19713892925852333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9228386988755128, target_prob=0.19713892925852333):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_660",
    "sat": "def sat(counts: List[int], p: float=0.47414348925825023, target_prob: float=0.2560625036932943):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47414348925825023, target_prob=0.2560625036932943):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_661",
    "sat": "def sat(counts: List[int], p: float=0.6050943643087181, target_prob: float=0.1067755252423449):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6050943643087181, target_prob=0.1067755252423449):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_662",
    "sat": "def sat(counts: List[int], p: float=0.19645474917407013, target_prob: float=0.11063613488702574):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19645474917407013, target_prob=0.11063613488702574):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_663",
    "sat": "def sat(counts: List[int], p: float=0.04237320007217249, target_prob: float=0.9170490879400114):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04237320007217249, target_prob=0.9170490879400114):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_664",
    "sat": "def sat(counts: List[int], p: float=0.46635924620237545, target_prob: float=0.34818609793279004):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.46635924620237545, target_prob=0.34818609793279004):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_665",
    "sat": "def sat(counts: List[int], p: float=0.4559440859569549, target_prob: float=0.004096199573183052):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4559440859569549, target_prob=0.004096199573183052):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_666",
    "sat": "def sat(counts: List[int], p: float=0.8688898520255929, target_prob: float=0.6559854022647862):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8688898520255929, target_prob=0.6559854022647862):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_667",
    "sat": "def sat(counts: List[int], p: float=0.2709265799017251, target_prob: float=0.3175256772605788):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2709265799017251, target_prob=0.3175256772605788):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_668",
    "sat": "def sat(counts: List[int], p: float=0.335101038843057, target_prob: float=0.16635606209023276):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.335101038843057, target_prob=0.16635606209023276):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_669",
    "sat": "def sat(counts: List[int], p: float=0.8959826939441877, target_prob: float=0.001125425640348045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8959826939441877, target_prob=0.001125425640348045):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_670",
    "sat": "def sat(counts: List[int], p: float=0.19233075982243308, target_prob: float=0.046410188083317136):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19233075982243308, target_prob=0.046410188083317136):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_671",
    "sat": "def sat(counts: List[int], p: float=0.8086091607922833, target_prob: float=0.40475955484054404):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8086091607922833, target_prob=0.40475955484054404):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_672",
    "sat": "def sat(counts: List[int], p: float=0.2994946627496696, target_prob: float=0.266826308611868):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2994946627496696, target_prob=0.266826308611868):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_673",
    "sat": "def sat(counts: List[int], p: float=0.1032808751320623, target_prob: float=0.46622442952583454):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1032808751320623, target_prob=0.46622442952583454):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_674",
    "sat": "def sat(counts: List[int], p: float=0.1616382672661163, target_prob: float=0.3408225599429152):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1616382672661163, target_prob=0.3408225599429152):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_675",
    "sat": "def sat(counts: List[int], p: float=0.09727879633547343, target_prob: float=8.243797551815523e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09727879633547343, target_prob=8.243797551815523e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_676",
    "sat": "def sat(counts: List[int], p: float=0.5367327114634379, target_prob: float=0.047558491781820166):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5367327114634379, target_prob=0.047558491781820166):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_677",
    "sat": "def sat(counts: List[int], p: float=0.48946267798915544, target_prob: float=0.14651288777526497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.48946267798915544, target_prob=0.14651288777526497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_678",
    "sat": "def sat(counts: List[int], p: float=0.6978784353510973, target_prob: float=0.08062290655358696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6978784353510973, target_prob=0.08062290655358696):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_679",
    "sat": "def sat(counts: List[int], p: float=0.2110462685671214, target_prob: float=0.0015400228622838954):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2110462685671214, target_prob=0.0015400228622838954):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_680",
    "sat": "def sat(counts: List[int], p: float=0.216704379904343, target_prob: float=0.03188517146758424):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.216704379904343, target_prob=0.03188517146758424):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_681",
    "sat": "def sat(counts: List[int], p: float=0.17232797136965605, target_prob: float=0.002186325042510799):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17232797136965605, target_prob=0.002186325042510799):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_682",
    "sat": "def sat(counts: List[int], p: float=0.8513994875520688, target_prob: float=0.8513994875520688):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8513994875520688, target_prob=0.8513994875520688):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_683",
    "sat": "def sat(counts: List[int], p: float=0.9010232113595793, target_prob: float=0.8118428274087292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9010232113595793, target_prob=0.8118428274087292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_684",
    "sat": "def sat(counts: List[int], p: float=0.5915101829737175, target_prob: float=0.12241902098040618):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5915101829737175, target_prob=0.12241902098040618):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_685",
    "sat": "def sat(counts: List[int], p: float=0.4955709193159462, target_prob: float=0.3782921247269002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4955709193159462, target_prob=0.3782921247269002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_686",
    "sat": "def sat(counts: List[int], p: float=0.9521948624442574, target_prob: float=4.346481406980834e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9521948624442574, target_prob=4.346481406980834e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_687",
    "sat": "def sat(counts: List[int], p: float=0.03459307269821066, target_prob: float=1.4320446467827188e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03459307269821066, target_prob=1.4320446467827188e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_688",
    "sat": "def sat(counts: List[int], p: float=0.07035034238314508, target_prob: float=0.7469254453927763):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07035034238314508, target_prob=0.7469254453927763):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_689",
    "sat": "def sat(counts: List[int], p: float=0.4040092414401807, target_prob: float=0.48157154854222095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4040092414401807, target_prob=0.48157154854222095):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_690",
    "sat": "def sat(counts: List[int], p: float=0.45495033407197527, target_prob: float=0.45495033407197527):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.45495033407197527, target_prob=0.45495033407197527):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_691",
    "sat": "def sat(counts: List[int], p: float=0.9273832917257601, target_prob: float=0.13468704390730774):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9273832917257601, target_prob=0.13468704390730774):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_692",
    "sat": "def sat(counts: List[int], p: float=0.5883018234246236, target_prob: float=0.4844055759597732):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5883018234246236, target_prob=0.4844055759597732):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_693",
    "sat": "def sat(counts: List[int], p: float=0.9584704007912594, target_prob: float=7.046348051428895e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9584704007912594, target_prob=7.046348051428895e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_694",
    "sat": "def sat(counts: List[int], p: float=0.5762057496516825, target_prob: float=0.4237942503483175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5762057496516825, target_prob=0.4237942503483175):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_695",
    "sat": "def sat(counts: List[int], p: float=0.4546813879970544, target_prob: float=0.29093157504217115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4546813879970544, target_prob=0.29093157504217115):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_696",
    "sat": "def sat(counts: List[int], p: float=0.023845039799148426, target_prob: float=3.610410460773665e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.023845039799148426, target_prob=3.610410460773665e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_697",
    "sat": "def sat(counts: List[int], p: float=0.33532584037529034, target_prob: float=0.33532584037529034):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33532584037529034, target_prob=0.33532584037529034):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_698",
    "sat": "def sat(counts: List[int], p: float=0.7885116661983812, target_prob: float=0.10097496156113496):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7885116661983812, target_prob=0.10097496156113496):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_699",
    "sat": "def sat(counts: List[int], p: float=0.8877697554710378, target_prob: float=0.005019842188739294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8877697554710378, target_prob=0.005019842188739294):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_700",
    "sat": "def sat(counts: List[int], p: float=0.3918066298120617, target_prob: float=0.34070473921584843):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3918066298120617, target_prob=0.34070473921584843):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_701",
    "sat": "def sat(counts: List[int], p: float=0.22365915048970186, target_prob: float=0.06362890917711196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22365915048970186, target_prob=0.06362890917711196):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_702",
    "sat": "def sat(counts: List[int], p: float=0.5272654068383185, target_prob: float=0.2780088092483775):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5272654068383185, target_prob=0.2780088092483775):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_703",
    "sat": "def sat(counts: List[int], p: float=0.3994450772033685, target_prob: float=0.15955636970200504):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3994450772033685, target_prob=0.15955636970200504):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_704",
    "sat": "def sat(counts: List[int], p: float=0.014989249393006165, target_prob: float=6.43713420576709e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.014989249393006165, target_prob=6.43713420576709e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_705",
    "sat": "def sat(counts: List[int], p: float=0.8885619330882065, target_prob: float=2.3783105319243004e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8885619330882065, target_prob=2.3783105319243004e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_706",
    "sat": "def sat(counts: List[int], p: float=0.4869206759282402, target_prob: float=0.011998275824847054):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4869206759282402, target_prob=0.011998275824847054):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_707",
    "sat": "def sat(counts: List[int], p: float=0.33888076483819507, target_prob: float=0.0410216829722687):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33888076483819507, target_prob=0.0410216829722687):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_708",
    "sat": "def sat(counts: List[int], p: float=0.06259036680809693, target_prob: float=0.003917554017172122):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06259036680809693, target_prob=0.003917554017172122):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_709",
    "sat": "def sat(counts: List[int], p: float=0.39974849286167646, target_prob: float=0.6002515071383235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39974849286167646, target_prob=0.6002515071383235):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_710",
    "sat": "def sat(counts: List[int], p: float=0.05375146300425859, target_prob: float=3.9494478424541715e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05375146300425859, target_prob=3.9494478424541715e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_711",
    "sat": "def sat(counts: List[int], p: float=0.5042435157195897, target_prob: float=0.007360017095365263):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5042435157195897, target_prob=0.007360017095365263):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_712",
    "sat": "def sat(counts: List[int], p: float=0.7131896130519431, target_prob: float=0.0019407713708607197):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7131896130519431, target_prob=0.0019407713708607197):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_713",
    "sat": "def sat(counts: List[int], p: float=0.08181947992037031, target_prob: float=0.00020574293807337752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08181947992037031, target_prob=0.00020574293807337752):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_714",
    "sat": "def sat(counts: List[int], p: float=0.8632321164074381, target_prob: float=0.00024785602062996304):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8632321164074381, target_prob=0.00024785602062996304):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_715",
    "sat": "def sat(counts: List[int], p: float=0.4174352361901196, target_prob: float=0.05027835854925458):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4174352361901196, target_prob=0.05027835854925458):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_716",
    "sat": "def sat(counts: List[int], p: float=0.768738943467812, target_prob: float=0.18963304828189365):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.768738943467812, target_prob=0.18963304828189365):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_717",
    "sat": "def sat(counts: List[int], p: float=0.8102367896895426, target_prob: float=3.19086308824706e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8102367896895426, target_prob=3.19086308824706e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_718",
    "sat": "def sat(counts: List[int], p: float=0.8179973477132161, target_prob: float=0.3999341086876177):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8179973477132161, target_prob=0.3999341086876177):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_719",
    "sat": "def sat(counts: List[int], p: float=0.15959021312777855, target_prob: float=0.15959021312777855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15959021312777855, target_prob=0.15959021312777855):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_720",
    "sat": "def sat(counts: List[int], p: float=0.26757229865063115, target_prob: float=0.00017319544564553063):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26757229865063115, target_prob=0.00017319544564553063):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_721",
    "sat": "def sat(counts: List[int], p: float=0.20010328234092212, target_prob: float=0.08201520547856447):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20010328234092212, target_prob=0.08201520547856447):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_722",
    "sat": "def sat(counts: List[int], p: float=0.4728415250409106, target_prob: float=0.014865733596443213):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4728415250409106, target_prob=0.014865733596443213):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_723",
    "sat": "def sat(counts: List[int], p: float=0.8252297658469346, target_prob: float=0.8252297658469346):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8252297658469346, target_prob=0.8252297658469346):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_724",
    "sat": "def sat(counts: List[int], p: float=0.9743465471055228, target_prob: float=0.04999070649813604):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9743465471055228, target_prob=0.04999070649813604):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_725",
    "sat": "def sat(counts: List[int], p: float=0.07376810694612246, target_prob: float=0.0008235724153791345):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07376810694612246, target_prob=0.0008235724153791345):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_726",
    "sat": "def sat(counts: List[int], p: float=0.8112631034521324, target_prob: float=0.23144711751168096):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8112631034521324, target_prob=0.23144711751168096):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_727",
    "sat": "def sat(counts: List[int], p: float=0.7637708283708284, target_prob: float=0.30458021078939823):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7637708283708284, target_prob=0.30458021078939823):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_728",
    "sat": "def sat(counts: List[int], p: float=0.7811308864654036, target_prob: float=0.22831812498827964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7811308864654036, target_prob=0.22831812498827964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_729",
    "sat": "def sat(counts: List[int], p: float=0.5588958312673623, target_prob: float=0.1057950926696036):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5588958312673623, target_prob=0.1057950926696036):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_730",
    "sat": "def sat(counts: List[int], p: float=0.2842972180268003, target_prob: float=0.08082490817777803):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2842972180268003, target_prob=0.08082490817777803):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_731",
    "sat": "def sat(counts: List[int], p: float=0.6725174232855036, target_prob: float=0.4522796846225732):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6725174232855036, target_prob=0.4522796846225732):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_732",
    "sat": "def sat(counts: List[int], p: float=0.6556131080632663, target_prob: float=0.28180122993743884):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6556131080632663, target_prob=0.28180122993743884):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_733",
    "sat": "def sat(counts: List[int], p: float=0.3603127982836831, target_prob: float=0.29202294800800044):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3603127982836831, target_prob=0.29202294800800044):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_734",
    "sat": "def sat(counts: List[int], p: float=0.5935455963772538, target_prob: float=0.004508904106183506):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5935455963772538, target_prob=0.004508904106183506):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_735",
    "sat": "def sat(counts: List[int], p: float=0.4899509164836183, target_prob: float=0.03887380500669442):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4899509164836183, target_prob=0.03887380500669442):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_736",
    "sat": "def sat(counts: List[int], p: float=0.22109941735997385, target_prob: float=0.3076463635907971):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.22109941735997385, target_prob=0.3076463635907971):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_737",
    "sat": "def sat(counts: List[int], p: float=0.5182932966822962, target_prob: float=0.08065667076276942):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5182932966822962, target_prob=0.08065667076276942):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_738",
    "sat": "def sat(counts: List[int], p: float=0.5777040005687989, target_prob: float=0.24826723856435345):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5777040005687989, target_prob=0.24826723856435345):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_739",
    "sat": "def sat(counts: List[int], p: float=0.5554284491482189, target_prob: float=0.029360856724475456):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5554284491482189, target_prob=0.029360856724475456):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_740",
    "sat": "def sat(counts: List[int], p: float=0.0692424931190484, target_prob: float=0.17995629638414126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0692424931190484, target_prob=0.17995629638414126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_741",
    "sat": "def sat(counts: List[int], p: float=0.07582091259792678, target_prob: float=0.5758282383289235):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07582091259792678, target_prob=0.5758282383289235):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_742",
    "sat": "def sat(counts: List[int], p: float=0.8290289885406497, target_prob: float=0.014416556199496408):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8290289885406497, target_prob=0.014416556199496408):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_743",
    "sat": "def sat(counts: List[int], p: float=0.14233892945868154, target_prob: float=1.6849598670084258e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14233892945868154, target_prob=1.6849598670084258e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_744",
    "sat": "def sat(counts: List[int], p: float=0.7573918827387289, target_prob: float=0.014279598042347125):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7573918827387289, target_prob=0.014279598042347125):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_745",
    "sat": "def sat(counts: List[int], p: float=0.12573255860880495, target_prob: float=0.12573255860880495):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12573255860880495, target_prob=0.12573255860880495):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_746",
    "sat": "def sat(counts: List[int], p: float=0.03194804213076252, target_prob: float=0.009259435267758041):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03194804213076252, target_prob=0.009259435267758041):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_747",
    "sat": "def sat(counts: List[int], p: float=0.43485898593385974, target_prob: float=0.22179193983507914):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.43485898593385974, target_prob=0.22179193983507914):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_748",
    "sat": "def sat(counts: List[int], p: float=0.5222482984140058, target_prob: float=0.18575515908386964):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5222482984140058, target_prob=0.18575515908386964):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_749",
    "sat": "def sat(counts: List[int], p: float=0.8566697406783111, target_prob: float=0.07607970534187808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8566697406783111, target_prob=0.07607970534187808):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_750",
    "sat": "def sat(counts: List[int], p: float=0.772173127183873, target_prob: float=0.06704657075331452):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.772173127183873, target_prob=0.06704657075331452):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_751",
    "sat": "def sat(counts: List[int], p: float=0.5232110831094368, target_prob: float=0.13960412333540193):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5232110831094368, target_prob=0.13960412333540193):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_752",
    "sat": "def sat(counts: List[int], p: float=0.8608041371650268, target_prob: float=0.0003754095441653101):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8608041371650268, target_prob=0.0003754095441653101):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_753",
    "sat": "def sat(counts: List[int], p: float=0.7201868946612662, target_prob: float=0.11543861347848233):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7201868946612662, target_prob=0.11543861347848233):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_754",
    "sat": "def sat(counts: List[int], p: float=0.9576197534671307, target_prob: float=1.4486394994129337e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9576197534671307, target_prob=1.4486394994129337e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_755",
    "sat": "def sat(counts: List[int], p: float=0.9469298056877306, target_prob: float=0.05307019431226945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9469298056877306, target_prob=0.05307019431226945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_756",
    "sat": "def sat(counts: List[int], p: float=0.39658049421130914, target_prob: float=0.00024265103428594169):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.39658049421130914, target_prob=0.00024265103428594169):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_757",
    "sat": "def sat(counts: List[int], p: float=0.08404346906910631, target_prob: float=0.01940904019099121):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08404346906910631, target_prob=0.01940904019099121):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_758",
    "sat": "def sat(counts: List[int], p: float=0.05622658620956822, target_prob: float=0.03762232646009778):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.05622658620956822, target_prob=0.03762232646009778):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_759",
    "sat": "def sat(counts: List[int], p: float=0.5567651648507013, target_prob: float=0.03683433507303304):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5567651648507013, target_prob=0.03683433507303304):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_760",
    "sat": "def sat(counts: List[int], p: float=0.6897384661205583, target_prob: float=0.32813559273004267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6897384661205583, target_prob=0.32813559273004267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_761",
    "sat": "def sat(counts: List[int], p: float=0.06431847183285966, target_prob: float=0.0002660768876501633):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06431847183285966, target_prob=0.0002660768876501633):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_762",
    "sat": "def sat(counts: List[int], p: float=0.16704868544113127, target_prob: float=0.13077543725867752):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16704868544113127, target_prob=0.13077543725867752):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_763",
    "sat": "def sat(counts: List[int], p: float=0.4016908536734738, target_prob: float=0.3101542331949885):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4016908536734738, target_prob=0.3101542331949885):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_764",
    "sat": "def sat(counts: List[int], p: float=0.26441811709224605, target_prob: float=0.1894374181561499):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26441811709224605, target_prob=0.1894374181561499):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_765",
    "sat": "def sat(counts: List[int], p: float=0.6878169908445548, target_prob: float=0.05403224828211027):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6878169908445548, target_prob=0.05403224828211027):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_766",
    "sat": "def sat(counts: List[int], p: float=0.10617884325976534, target_prob: float=0.0654710983176196):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10617884325976534, target_prob=0.0654710983176196):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_767",
    "sat": "def sat(counts: List[int], p: float=0.2866961261789598, target_prob: float=0.7133038738210402):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2866961261789598, target_prob=0.7133038738210402):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_768",
    "sat": "def sat(counts: List[int], p: float=0.35618969822741764, target_prob: float=0.0020421522981980264):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35618969822741764, target_prob=0.0020421522981980264):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_769",
    "sat": "def sat(counts: List[int], p: float=0.915960239615711, target_prob: float=0.019407405837562206):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.915960239615711, target_prob=0.019407405837562206):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_770",
    "sat": "def sat(counts: List[int], p: float=0.37156541784960895, target_prob: float=0.3271462719428663):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37156541784960895, target_prob=0.3271462719428663):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_771",
    "sat": "def sat(counts: List[int], p: float=0.5584059115701712, target_prob: float=0.3395443621183372):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5584059115701712, target_prob=0.3395443621183372):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_772",
    "sat": "def sat(counts: List[int], p: float=0.6519083042930276, target_prob: float=7.503138505612526e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6519083042930276, target_prob=7.503138505612526e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_773",
    "sat": "def sat(counts: List[int], p: float=0.69795141753902, target_prob: float=0.44141637903127484):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.69795141753902, target_prob=0.44141637903127484):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_774",
    "sat": "def sat(counts: List[int], p: float=0.6514703638517585, target_prob: float=0.07367017276266294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6514703638517585, target_prob=0.07367017276266294):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_775",
    "sat": "def sat(counts: List[int], p: float=0.3261884542310205, target_prob: float=0.2503961181573817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3261884542310205, target_prob=0.2503961181573817):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_776",
    "sat": "def sat(counts: List[int], p: float=0.4809009280300838, target_prob: float=0.12669829671706176):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4809009280300838, target_prob=0.12669829671706176):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_777",
    "sat": "def sat(counts: List[int], p: float=0.08353699194250219, target_prob: float=0.2572075092384728):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08353699194250219, target_prob=0.2572075092384728):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_778",
    "sat": "def sat(counts: List[int], p: float=0.26466146998009765, target_prob: float=0.30720055080010067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26466146998009765, target_prob=0.30720055080010067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_779",
    "sat": "def sat(counts: List[int], p: float=0.09220024409060046, target_prob: float=0.00032801095541394446):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09220024409060046, target_prob=0.00032801095541394446):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_780",
    "sat": "def sat(counts: List[int], p: float=0.8861770943301785, target_prob: float=0.01707108359056278):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8861770943301785, target_prob=0.01707108359056278):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_781",
    "sat": "def sat(counts: List[int], p: float=0.24744434201532706, target_prob: float=8.605483538901622e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.24744434201532706, target_prob=8.605483538901622e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_782",
    "sat": "def sat(counts: List[int], p: float=0.3076653915828419, target_prob: float=0.31412710932378374):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3076653915828419, target_prob=0.31412710932378374):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_783",
    "sat": "def sat(counts: List[int], p: float=0.8165159339722027, target_prob: float=0.2793461742459839):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8165159339722027, target_prob=0.2793461742459839):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_784",
    "sat": "def sat(counts: List[int], p: float=0.11033082390575766, target_prob: float=0.010630352652204913):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11033082390575766, target_prob=0.010630352652204913):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_785",
    "sat": "def sat(counts: List[int], p: float=0.8874576042096248, target_prob: float=0.6202838304103239):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8874576042096248, target_prob=0.6202838304103239):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_786",
    "sat": "def sat(counts: List[int], p: float=0.8521236874944653, target_prob: float=0.10398984992928055):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8521236874944653, target_prob=0.10398984992928055):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_787",
    "sat": "def sat(counts: List[int], p: float=0.8838316788088001, target_prob: float=0.0008048045459275045):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8838316788088001, target_prob=0.0008048045459275045):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_788",
    "sat": "def sat(counts: List[int], p: float=0.06654145876746553, target_prob: float=0.21648978570639363):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06654145876746553, target_prob=0.21648978570639363):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_789",
    "sat": "def sat(counts: List[int], p: float=0.6495529283645992, target_prob: float=0.18159186796209578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6495529283645992, target_prob=0.18159186796209578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_790",
    "sat": "def sat(counts: List[int], p: float=0.8669434137746237, target_prob: float=0.012393859065831472):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8669434137746237, target_prob=0.012393859065831472):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_791",
    "sat": "def sat(counts: List[int], p: float=0.2555278536169182, target_prob: float=0.5542387767402328):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2555278536169182, target_prob=0.5542387767402328):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_792",
    "sat": "def sat(counts: List[int], p: float=0.6375504486591919, target_prob: float=0.13021667461078723):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6375504486591919, target_prob=0.13021667461078723):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_793",
    "sat": "def sat(counts: List[int], p: float=0.7672707016774625, target_prob: float=0.3052424463471879):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7672707016774625, target_prob=0.3052424463471879):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_794",
    "sat": "def sat(counts: List[int], p: float=0.26283168410107405, target_prob: float=0.737168315898926):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26283168410107405, target_prob=0.737168315898926):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_795",
    "sat": "def sat(counts: List[int], p: float=0.04911137163984858, target_prob: float=0.635575113178428):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04911137163984858, target_prob=0.635575113178428):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_796",
    "sat": "def sat(counts: List[int], p: float=0.41080387984120936, target_prob: float=0.24067078064310068):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.41080387984120936, target_prob=0.24067078064310068):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_797",
    "sat": "def sat(counts: List[int], p: float=0.5432199202178418, target_prob: float=0.009083284900200732):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5432199202178418, target_prob=0.009083284900200732):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_798",
    "sat": "def sat(counts: List[int], p: float=0.16607336679060358, target_prob: float=0.00024247373916748907):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.16607336679060358, target_prob=0.00024247373916748907):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_799",
    "sat": "def sat(counts: List[int], p: float=0.34501859743468355, target_prob: float=0.014170005584343294):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34501859743468355, target_prob=0.014170005584343294):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_800",
    "sat": "def sat(counts: List[int], p: float=0.2773028527194036, target_prob: float=0.1971431547976175):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2773028527194036, target_prob=0.1971431547976175):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_801",
    "sat": "def sat(counts: List[int], p: float=0.759987346751861, target_prob: float=0.05760607371921142):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.759987346751861, target_prob=0.05760607371921142):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_802",
    "sat": "def sat(counts: List[int], p: float=0.17570958783970103, target_prob: float=0.17570958783970103):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17570958783970103, target_prob=0.17570958783970103):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_803",
    "sat": "def sat(counts: List[int], p: float=0.9363879065928337, target_prob: float=0.16732950836350002):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9363879065928337, target_prob=0.16732950836350002):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_804",
    "sat": "def sat(counts: List[int], p: float=0.3907090566504807, target_prob: float=0.4351351616697736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3907090566504807, target_prob=0.4351351616697736):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_805",
    "sat": "def sat(counts: List[int], p: float=0.42956608594517043, target_prob: float=0.3425121537289323):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42956608594517043, target_prob=0.3425121537289323):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_806",
    "sat": "def sat(counts: List[int], p: float=0.6999382981163654, target_prob: float=0.26682790781507176):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6999382981163654, target_prob=0.26682790781507176):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_807",
    "sat": "def sat(counts: List[int], p: float=0.2303445632513229, target_prob: float=0.21339843680630205):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2303445632513229, target_prob=0.21339843680630205):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_808",
    "sat": "def sat(counts: List[int], p: float=0.9678231217194878, target_prob: float=0.9366815949348545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9678231217194878, target_prob=0.9366815949348545):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_809",
    "sat": "def sat(counts: List[int], p: float=0.831987527208378, target_prob: float=0.15704478758623422):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.831987527208378, target_prob=0.15704478758623422):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_810",
    "sat": "def sat(counts: List[int], p: float=0.17550196234420856, target_prob: float=0.4012188778261311):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17550196234420856, target_prob=0.4012188778261311):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_811",
    "sat": "def sat(counts: List[int], p: float=0.009129185448218058, target_prob: float=2.3650878220133573e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.009129185448218058, target_prob=2.3650878220133573e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_812",
    "sat": "def sat(counts: List[int], p: float=0.10182020802675995, target_prob: float=0.5250246308174502):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10182020802675995, target_prob=0.5250246308174502):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_813",
    "sat": "def sat(counts: List[int], p: float=0.37591530083311697, target_prob: float=0.24306957689865266):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.37591530083311697, target_prob=0.24306957689865266):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_814",
    "sat": "def sat(counts: List[int], p: float=0.11030467289882784, target_prob: float=0.11030467289882784):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11030467289882784, target_prob=0.11030467289882784):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_815",
    "sat": "def sat(counts: List[int], p: float=0.020562998311262293, target_prob: float=0.8468608498025542):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.020562998311262293, target_prob=0.8468608498025542):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_816",
    "sat": "def sat(counts: List[int], p: float=0.7538621293111355, target_prob: float=0.7538621293111355):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7538621293111355, target_prob=0.7538621293111355):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_817",
    "sat": "def sat(counts: List[int], p: float=0.7051579022140102, target_prob: float=0.35063812178121817):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7051579022140102, target_prob=0.35063812178121817):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_818",
    "sat": "def sat(counts: List[int], p: float=0.17470795785534465, target_prob: float=0.00016276590474211214):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.17470795785534465, target_prob=0.00016276590474211214):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_819",
    "sat": "def sat(counts: List[int], p: float=0.5182448554940099, target_prob: float=0.002901421923652822):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5182448554940099, target_prob=0.002901421923652822):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_820",
    "sat": "def sat(counts: List[int], p: float=0.5225925534671422, target_prob: float=0.07458523601311212):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5225925534671422, target_prob=0.07458523601311212):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_821",
    "sat": "def sat(counts: List[int], p: float=0.8820573971077561, target_prob: float=0.7780252517925097):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8820573971077561, target_prob=0.7780252517925097):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_822",
    "sat": "def sat(counts: List[int], p: float=0.3941559321338186, target_prob: float=0.21510936822720006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3941559321338186, target_prob=0.21510936822720006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_823",
    "sat": "def sat(counts: List[int], p: float=0.42208722044766933, target_prob: float=0.09396257442467545):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.42208722044766933, target_prob=0.09396257442467545):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_824",
    "sat": "def sat(counts: List[int], p: float=0.049374210073335534, target_prob: float=2.82475143968801e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.049374210073335534, target_prob=2.82475143968801e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_825",
    "sat": "def sat(counts: List[int], p: float=0.12584960327715555, target_prob: float=6.922338248055383e-08):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.12584960327715555, target_prob=6.922338248055383e-08):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_826",
    "sat": "def sat(counts: List[int], p: float=0.08694648620576295, target_prob: float=0.7611823271637445):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.08694648620576295, target_prob=0.7611823271637445):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_827",
    "sat": "def sat(counts: List[int], p: float=0.6397815473447174, target_prob: float=0.3773297757992115):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6397815473447174, target_prob=0.3773297757992115):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_828",
    "sat": "def sat(counts: List[int], p: float=0.017265803292233373, target_prob: float=0.0002981079633260968):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.017265803292233373, target_prob=0.0002981079633260968):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_829",
    "sat": "def sat(counts: List[int], p: float=0.7845306357846192, target_prob: float=0.2638164967217769):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7845306357846192, target_prob=0.2638164967217769):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_830",
    "sat": "def sat(counts: List[int], p: float=0.5999911512565561, target_prob: float=0.0016386537280103318):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5999911512565561, target_prob=0.0016386537280103318):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_831",
    "sat": "def sat(counts: List[int], p: float=0.4641854913101874, target_prob: float=0.5358145086898126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4641854913101874, target_prob=0.5358145086898126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_832",
    "sat": "def sat(counts: List[int], p: float=0.2140047329038438, target_prob: float=2.0557185170036517e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2140047329038438, target_prob=2.0557185170036517e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_833",
    "sat": "def sat(counts: List[int], p: float=0.7253415922001998, target_prob: float=0.005690777325938529):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7253415922001998, target_prob=0.005690777325938529):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_834",
    "sat": "def sat(counts: List[int], p: float=0.9177787943606707, target_prob: float=0.9177787943606707):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9177787943606707, target_prob=0.9177787943606707):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_835",
    "sat": "def sat(counts: List[int], p: float=0.4620403511197134, target_prob: float=0.06738604006581178):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4620403511197134, target_prob=0.06738604006581178):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_836",
    "sat": "def sat(counts: List[int], p: float=0.8328857281539533, target_prob: float=0.4007994359327633):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8328857281539533, target_prob=0.4007994359327633):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_837",
    "sat": "def sat(counts: List[int], p: float=0.34833641084512534, target_prob: float=0.17758157662622945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34833641084512534, target_prob=0.17758157662622945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_838",
    "sat": "def sat(counts: List[int], p: float=0.3307540712098521, target_prob: float=0.6692459287901479):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3307540712098521, target_prob=0.6692459287901479):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_839",
    "sat": "def sat(counts: List[int], p: float=0.6407459608508088, target_prob: float=0.08815642233437537):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6407459608508088, target_prob=0.08815642233437537):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_840",
    "sat": "def sat(counts: List[int], p: float=0.9348855553224397, target_prob: float=0.7638952308313892):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9348855553224397, target_prob=0.7638952308313892):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_841",
    "sat": "def sat(counts: List[int], p: float=0.013514389779673452, target_prob: float=0.0757532838776303):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.013514389779673452, target_prob=0.0757532838776303):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_842",
    "sat": "def sat(counts: List[int], p: float=0.6745219039888782, target_prob: float=0.09418382919659102):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6745219039888782, target_prob=0.09418382919659102):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_843",
    "sat": "def sat(counts: List[int], p: float=0.3786231937330786, target_prob: float=0.18458746259565834):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3786231937330786, target_prob=0.18458746259565834):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_844",
    "sat": "def sat(counts: List[int], p: float=0.6510391633100192, target_prob: float=0.3489608366899808):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6510391633100192, target_prob=0.3489608366899808):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_845",
    "sat": "def sat(counts: List[int], p: float=0.818009542236851, target_prob: float=0.1329735382183959):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.818009542236851, target_prob=0.1329735382183959):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_846",
    "sat": "def sat(counts: List[int], p: float=0.507016150576753, target_prob: float=0.507016150576753):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.507016150576753, target_prob=0.507016150576753):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_847",
    "sat": "def sat(counts: List[int], p: float=0.9854404989144362, target_prob: float=8.64147160122232e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9854404989144362, target_prob=8.64147160122232e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_848",
    "sat": "def sat(counts: List[int], p: float=0.7582962439908694, target_prob: float=0.24170375600913063):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7582962439908694, target_prob=0.24170375600913063):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_849",
    "sat": "def sat(counts: List[int], p: float=0.578479753437385, target_prob: float=0.2935458985968834):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.578479753437385, target_prob=0.2935458985968834):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_850",
    "sat": "def sat(counts: List[int], p: float=0.5150215896754207, target_prob: float=0.07035609717739809):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5150215896754207, target_prob=0.07035609717739809):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_851",
    "sat": "def sat(counts: List[int], p: float=0.9751210277328634, target_prob: float=1.9032617437383482e-07):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9751210277328634, target_prob=1.9032617437383482e-07):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_852",
    "sat": "def sat(counts: List[int], p: float=0.35240476739695015, target_prob: float=0.11389855510894054):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35240476739695015, target_prob=0.11389855510894054):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_853",
    "sat": "def sat(counts: List[int], p: float=0.8075899500585969, target_prob: float=0.19499713117044576):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8075899500585969, target_prob=0.19499713117044576):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_854",
    "sat": "def sat(counts: List[int], p: float=0.9460865539412568, target_prob: float=0.012758176729352292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9460865539412568, target_prob=0.012758176729352292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_855",
    "sat": "def sat(counts: List[int], p: float=0.8787198088012355, target_prob: float=0.7721485023796798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8787198088012355, target_prob=0.7721485023796798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_856",
    "sat": "def sat(counts: List[int], p: float=0.8748466003454654, target_prob: float=0.07192839503607232):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8748466003454654, target_prob=0.07192839503607232):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_857",
    "sat": "def sat(counts: List[int], p: float=0.6231505482281066, target_prob: float=0.15078978630662943):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6231505482281066, target_prob=0.15078978630662943):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_858",
    "sat": "def sat(counts: List[int], p: float=0.30480404185503085, target_prob: float=0.6951959581449692):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30480404185503085, target_prob=0.6951959581449692):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_859",
    "sat": "def sat(counts: List[int], p: float=0.9656305829516888, target_prob: float=0.0011812568282407448):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9656305829516888, target_prob=0.0011812568282407448):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_860",
    "sat": "def sat(counts: List[int], p: float=0.35602054401973726, target_prob: float=0.05172997340376659):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.35602054401973726, target_prob=0.05172997340376659):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_861",
    "sat": "def sat(counts: List[int], p: float=0.6481948433953442, target_prob: float=0.44343972789529695):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6481948433953442, target_prob=0.44343972789529695):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_862",
    "sat": "def sat(counts: List[int], p: float=0.32376422861202103, target_prob: float=0.676235771387979):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.32376422861202103, target_prob=0.676235771387979):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_863",
    "sat": "def sat(counts: List[int], p: float=0.7923785562333401, target_prob: float=0.6278637763784325):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7923785562333401, target_prob=0.6278637763784325):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_864",
    "sat": "def sat(counts: List[int], p: float=0.5428253763618862, target_prob: float=0.36951814303742414):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5428253763618862, target_prob=0.36951814303742414):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_865",
    "sat": "def sat(counts: List[int], p: float=0.7467191812532477, target_prob: float=3.203155482477221e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7467191812532477, target_prob=3.203155482477221e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_866",
    "sat": "def sat(counts: List[int], p: float=0.393423935400963, target_prob: float=0.2547846359978475):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.393423935400963, target_prob=0.2547846359978475):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_867",
    "sat": "def sat(counts: List[int], p: float=0.9744465696601593, target_prob: float=0.01204780329023408):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9744465696601593, target_prob=0.01204780329023408):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_868",
    "sat": "def sat(counts: List[int], p: float=0.8565467029258383, target_prob: float=0.3882020775778757):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8565467029258383, target_prob=0.3882020775778757):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_869",
    "sat": "def sat(counts: List[int], p: float=0.76075630934662, target_prob: float=0.04167033906854491):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.76075630934662, target_prob=0.04167033906854491):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_870",
    "sat": "def sat(counts: List[int], p: float=0.19353726518866543, target_prob: float=0.19353726518866543):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.19353726518866543, target_prob=0.19353726518866543):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_871",
    "sat": "def sat(counts: List[int], p: float=0.20579663460649877, target_prob: float=0.12571453904025456):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20579663460649877, target_prob=0.12571453904025456):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_872",
    "sat": "def sat(counts: List[int], p: float=0.27444358712433725, target_prob: float=0.7255564128756627):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.27444358712433725, target_prob=0.7255564128756627):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_873",
    "sat": "def sat(counts: List[int], p: float=0.9274595847830266, target_prob: float=0.027158220631824798):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9274595847830266, target_prob=0.027158220631824798):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_874",
    "sat": "def sat(counts: List[int], p: float=0.6988937217948317, target_prob: float=0.30110627820516833):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6988937217948317, target_prob=0.30110627820516833):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_875",
    "sat": "def sat(counts: List[int], p: float=0.28570226307437985, target_prob: float=0.5102212569770624):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.28570226307437985, target_prob=0.5102212569770624):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_876",
    "sat": "def sat(counts: List[int], p: float=0.3139988578351536, target_prob: float=0.3139988578351536):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3139988578351536, target_prob=0.3139988578351536):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_877",
    "sat": "def sat(counts: List[int], p: float=0.1241441795746967, target_prob: float=3.184249919471355e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1241441795746967, target_prob=3.184249919471355e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_878",
    "sat": "def sat(counts: List[int], p: float=0.9295373804330609, target_prob: float=0.07235543522888951):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9295373804330609, target_prob=0.07235543522888951):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_879",
    "sat": "def sat(counts: List[int], p: float=0.23144972570656952, target_prob: float=1.4648134390786813e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23144972570656952, target_prob=1.4648134390786813e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_880",
    "sat": "def sat(counts: List[int], p: float=0.11218941910109892, target_prob: float=0.8878105808989011):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11218941910109892, target_prob=0.8878105808989011):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_881",
    "sat": "def sat(counts: List[int], p: float=0.5097515040166221, target_prob: float=0.0016358611175118574):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5097515040166221, target_prob=0.0016358611175118574):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_882",
    "sat": "def sat(counts: List[int], p: float=0.3486767417749066, target_prob: float=0.005153649694820788):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3486767417749066, target_prob=0.005153649694820788):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_883",
    "sat": "def sat(counts: List[int], p: float=0.34597949357121593, target_prob: float=0.0031048016680748918):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.34597949357121593, target_prob=0.0031048016680748918):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_884",
    "sat": "def sat(counts: List[int], p: float=0.4570451625092269, target_prob: float=0.08690701379501292):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4570451625092269, target_prob=0.08690701379501292):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_885",
    "sat": "def sat(counts: List[int], p: float=0.5355324297316346, target_prob: float=0.20020936806003298):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5355324297316346, target_prob=0.20020936806003298):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_886",
    "sat": "def sat(counts: List[int], p: float=0.14591098969305016, target_prob: float=0.8540890103069498):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14591098969305016, target_prob=0.8540890103069498):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_887",
    "sat": "def sat(counts: List[int], p: float=0.8954958000006702, target_prob: float=0.002997738076030672):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8954958000006702, target_prob=0.002997738076030672):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_888",
    "sat": "def sat(counts: List[int], p: float=0.6127371069976394, target_prob: float=0.21805498515699523):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6127371069976394, target_prob=0.21805498515699523):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_889",
    "sat": "def sat(counts: List[int], p: float=0.9373054053318084, target_prob: float=0.0626945946681916):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9373054053318084, target_prob=0.0626945946681916):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_890",
    "sat": "def sat(counts: List[int], p: float=0.6203237810397342, target_prob: float=0.21060905983321415):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6203237810397342, target_prob=0.21060905983321415):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_891",
    "sat": "def sat(counts: List[int], p: float=0.7470654907263944, target_prob: float=0.03426422840930336):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7470654907263944, target_prob=0.03426422840930336):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_892",
    "sat": "def sat(counts: List[int], p: float=0.9924464836382542, target_prob: float=0.9555261652441343):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9924464836382542, target_prob=0.9555261652441343):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_893",
    "sat": "def sat(counts: List[int], p: float=0.33360966418964944, target_prob: float=0.00735241889271324):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.33360966418964944, target_prob=0.00735241889271324):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_894",
    "sat": "def sat(counts: List[int], p: float=0.47790193759331945, target_prob: float=0.2549682585766569):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47790193759331945, target_prob=0.2549682585766569):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_895",
    "sat": "def sat(counts: List[int], p: float=0.20727209765414278, target_prob: float=0.10217086839478873):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20727209765414278, target_prob=0.10217086839478873):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_896",
    "sat": "def sat(counts: List[int], p: float=0.9516162340397173, target_prob: float=5.480228601519497e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9516162340397173, target_prob=5.480228601519497e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_897",
    "sat": "def sat(counts: List[int], p: float=0.8297057139429163, target_prob: float=0.20615208674930813):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8297057139429163, target_prob=0.20615208674930813):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_898",
    "sat": "def sat(counts: List[int], p: float=0.40026928923347793, target_prob: float=0.006019534194229611):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40026928923347793, target_prob=0.006019534194229611):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_899",
    "sat": "def sat(counts: List[int], p: float=0.5423123305643027, target_prob: float=0.07569588363865189):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5423123305643027, target_prob=0.07569588363865189):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_900",
    "sat": "def sat(counts: List[int], p: float=0.8502172735621166, target_prob: float=0.39133746955042903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8502172735621166, target_prob=0.39133746955042903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_901",
    "sat": "def sat(counts: List[int], p: float=0.29359005146790673, target_prob: float=0.007953183672350095):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.29359005146790673, target_prob=0.007953183672350095):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_902",
    "sat": "def sat(counts: List[int], p: float=0.8881522658644956, target_prob: float=0.31343642562163126):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8881522658644956, target_prob=0.31343642562163126):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_903",
    "sat": "def sat(counts: List[int], p: float=0.6184037174849871, target_prob: float=0.09043998012330019):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6184037174849871, target_prob=0.09043998012330019):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_904",
    "sat": "def sat(counts: List[int], p: float=0.5741935828318557, target_prob: float=0.013997839552843696):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5741935828318557, target_prob=0.013997839552843696):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_905",
    "sat": "def sat(counts: List[int], p: float=0.814122950240736, target_prob: float=0.3026535442641122):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.814122950240736, target_prob=0.3026535442641122):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_906",
    "sat": "def sat(counts: List[int], p: float=0.9422023857593009, target_prob: float=0.005325674004771819):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9422023857593009, target_prob=0.005325674004771819):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_907",
    "sat": "def sat(counts: List[int], p: float=0.0771997753442315, target_prob: float=0.6691730744145651):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0771997753442315, target_prob=0.6691730744145651):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_908",
    "sat": "def sat(counts: List[int], p: float=0.8233416911625309, target_prob: float=0.3624806312672291):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8233416911625309, target_prob=0.3624806312672291):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_909",
    "sat": "def sat(counts: List[int], p: float=0.9741742646950717, target_prob: float=0.9741742646950717):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9741742646950717, target_prob=0.9741742646950717):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_910",
    "sat": "def sat(counts: List[int], p: float=0.7464554469668216, target_prob: float=0.13558277699740282):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7464554469668216, target_prob=0.13558277699740282):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_911",
    "sat": "def sat(counts: List[int], p: float=0.18141542397782306, target_prob: float=0.0329115560570533):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18141542397782306, target_prob=0.0329115560570533):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_912",
    "sat": "def sat(counts: List[int], p: float=0.6236569959359186, target_prob: float=0.23334608374810267):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6236569959359186, target_prob=0.23334608374810267):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_913",
    "sat": "def sat(counts: List[int], p: float=0.8077700238154244, target_prob: float=0.05916892193181367):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8077700238154244, target_prob=0.05916892193181367):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_914",
    "sat": "def sat(counts: List[int], p: float=0.5917728607623131, target_prob: float=0.045381553749962736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5917728607623131, target_prob=0.045381553749962736):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_915",
    "sat": "def sat(counts: List[int], p: float=0.30441649261618053, target_prob: float=0.3563159691146492):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.30441649261618053, target_prob=0.3563159691146492):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_916",
    "sat": "def sat(counts: List[int], p: float=0.07087058584147132, target_prob: float=0.07087058584147132):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07087058584147132, target_prob=0.07087058584147132):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_917",
    "sat": "def sat(counts: List[int], p: float=0.5783527885706337, target_prob: float=0.25074562556805635):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5783527885706337, target_prob=0.25074562556805635):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_918",
    "sat": "def sat(counts: List[int], p: float=0.9795907210301948, target_prob: float=0.00015982583047791823):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9795907210301948, target_prob=0.00015982583047791823):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_919",
    "sat": "def sat(counts: List[int], p: float=0.5287251295166557, target_prob: float=0.19271593283799124):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5287251295166557, target_prob=0.19271593283799124):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_920",
    "sat": "def sat(counts: List[int], p: float=0.23372250556067287, target_prob: float=0.0026799912297193903):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.23372250556067287, target_prob=0.0026799912297193903):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_921",
    "sat": "def sat(counts: List[int], p: float=0.14232444229177954, target_prob: float=0.25113503414273197):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.14232444229177954, target_prob=0.25113503414273197):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_922",
    "sat": "def sat(counts: List[int], p: float=0.10917990198567362, target_prob: float=0.6297381830845081):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.10917990198567362, target_prob=0.6297381830845081):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_923",
    "sat": "def sat(counts: List[int], p: float=0.5949742241713225, target_prob: float=0.15812703601270786):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5949742241713225, target_prob=0.15812703601270786):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_924",
    "sat": "def sat(counts: List[int], p: float=0.9169790611351916, target_prob: float=0.3454953395202474):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9169790611351916, target_prob=0.3454953395202474):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_925",
    "sat": "def sat(counts: List[int], p: float=0.18194334264750112, target_prob: float=0.033103379933746):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18194334264750112, target_prob=0.033103379933746):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_926",
    "sat": "def sat(counts: List[int], p: float=0.5769139813392735, target_prob: float=0.2520624479474793):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5769139813392735, target_prob=0.2520624479474793):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_927",
    "sat": "def sat(counts: List[int], p: float=0.47989624544660403, target_prob: float=0.06649443888251912):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47989624544660403, target_prob=0.06649443888251912):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_928",
    "sat": "def sat(counts: List[int], p: float=0.395605161148207, target_prob: float=0.003263313874226083):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.395605161148207, target_prob=0.003263313874226083):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_929",
    "sat": "def sat(counts: List[int], p: float=0.5672436652911964, target_prob: float=0.19800052078991948):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5672436652911964, target_prob=0.19800052078991948):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_930",
    "sat": "def sat(counts: List[int], p: float=0.21987174097978135, target_prob: float=0.0834949288127667):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21987174097978135, target_prob=0.0834949288127667):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_931",
    "sat": "def sat(counts: List[int], p: float=0.2711533533702646, target_prob: float=0.43212416604035386):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2711533533702646, target_prob=0.43212416604035386):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_932",
    "sat": "def sat(counts: List[int], p: float=0.8404750109762371, target_prob: float=0.025448222123031668):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8404750109762371, target_prob=0.025448222123031668):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_933",
    "sat": "def sat(counts: List[int], p: float=0.4740887432662605, target_prob: float=0.5259112567337395):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4740887432662605, target_prob=0.5259112567337395):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_934",
    "sat": "def sat(counts: List[int], p: float=0.3563103371958444, target_prob: float=0.11050518949197065):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3563103371958444, target_prob=0.11050518949197065):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_935",
    "sat": "def sat(counts: List[int], p: float=0.21270841436722665, target_prob: float=0.38418680017209006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.21270841436722665, target_prob=0.38418680017209006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_936",
    "sat": "def sat(counts: List[int], p: float=0.4231153460595536, target_prob: float=0.3327959039519886):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4231153460595536, target_prob=0.3327959039519886):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_937",
    "sat": "def sat(counts: List[int], p: float=0.9762316841361354, target_prob: float=1.039250834671393e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9762316841361354, target_prob=1.039250834671393e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_938",
    "sat": "def sat(counts: List[int], p: float=0.6254987704511531, target_prob: float=0.3745012295488469):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6254987704511531, target_prob=0.3745012295488469):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_939",
    "sat": "def sat(counts: List[int], p: float=0.8946684674123938, target_prob: float=0.029778319972842006):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8946684674123938, target_prob=0.029778319972842006):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_940",
    "sat": "def sat(counts: List[int], p: float=0.2759825873825835, target_prob: float=0.06087711294972186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2759825873825835, target_prob=0.06087711294972186):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_941",
    "sat": "def sat(counts: List[int], p: float=0.5832818274499081, target_prob: float=0.34021769023330434):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5832818274499081, target_prob=0.34021769023330434):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_942",
    "sat": "def sat(counts: List[int], p: float=0.9820164248952697, target_prob: float=0.8648683687896983):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9820164248952697, target_prob=0.8648683687896983):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_943",
    "sat": "def sat(counts: List[int], p: float=0.9591712998161548, target_prob: float=0.07832343485028578):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9591712998161548, target_prob=0.07832343485028578):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_944",
    "sat": "def sat(counts: List[int], p: float=0.4180922554217267, target_prob: float=0.07556854677037725):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4180922554217267, target_prob=0.07556854677037725):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_945",
    "sat": "def sat(counts: List[int], p: float=0.20614215951744097, target_prob: float=7.673631291759344e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.20614215951744097, target_prob=7.673631291759344e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_946",
    "sat": "def sat(counts: List[int], p: float=0.4665271373552934, target_prob: float=0.12635428698439188):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4665271373552934, target_prob=0.12635428698439188):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_947",
    "sat": "def sat(counts: List[int], p: float=0.0032210107705598068, target_prob: float=3.467056229322195e-13):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.0032210107705598068, target_prob=3.467056229322195e-13):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_948",
    "sat": "def sat(counts: List[int], p: float=0.718114123763433, target_prob: float=0.4048524580298197):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.718114123763433, target_prob=0.4048524580298197):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_949",
    "sat": "def sat(counts: List[int], p: float=0.5477704573652131, target_prob: float=0.23506513562616144):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5477704573652131, target_prob=0.23506513562616144):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_950",
    "sat": "def sat(counts: List[int], p: float=0.675781018236533, target_prob: float=0.1269196477024724):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.675781018236533, target_prob=0.1269196477024724):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_951",
    "sat": "def sat(counts: List[int], p: float=0.5836918761759101, target_prob: float=0.0021672259910500338):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5836918761759101, target_prob=0.0021672259910500338):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_952",
    "sat": "def sat(counts: List[int], p: float=0.11197486211350538, target_prob: float=0.057835228242646204):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.11197486211350538, target_prob=0.057835228242646204):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_953",
    "sat": "def sat(counts: List[int], p: float=0.4274008430190923, target_prob: float=0.25880077012054953):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4274008430190923, target_prob=0.25880077012054953):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_954",
    "sat": "def sat(counts: List[int], p: float=0.03554768984769219, target_prob: float=0.9301682585581234):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.03554768984769219, target_prob=0.9301682585581234):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_955",
    "sat": "def sat(counts: List[int], p: float=0.5998732324347961, target_prob: float=0.010639282130186008):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5998732324347961, target_prob=0.010639282130186008):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_956",
    "sat": "def sat(counts: List[int], p: float=0.3930212153774223, target_prob: float=0.24768635435848713):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3930212153774223, target_prob=0.24768635435848713):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_957",
    "sat": "def sat(counts: List[int], p: float=0.7807754147844826, target_prob: float=0.06008410370861736):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7807754147844826, target_prob=0.06008410370861736):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_958",
    "sat": "def sat(counts: List[int], p: float=0.8247456306397906, target_prob: float=0.8247456306397906):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8247456306397906, target_prob=0.8247456306397906):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_959",
    "sat": "def sat(counts: List[int], p: float=0.3981064662291396, target_prob: float=0.07559387507471929):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3981064662291396, target_prob=0.07559387507471929):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_960",
    "sat": "def sat(counts: List[int], p: float=0.2819859781645, target_prob: float=0.5155441355523899):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2819859781645, target_prob=0.5155441355523899):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_961",
    "sat": "def sat(counts: List[int], p: float=0.8087030717373334, target_prob: float=0.3970129841246456):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8087030717373334, target_prob=0.3970129841246456):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_962",
    "sat": "def sat(counts: List[int], p: float=0.5929165790489909, target_prob: float=0.011179363495470477):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.5929165790489909, target_prob=0.011179363495470477):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_963",
    "sat": "def sat(counts: List[int], p: float=0.4323831822502604, target_prob: float=0.03495225289911078):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4323831822502604, target_prob=0.03495225289911078):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_964",
    "sat": "def sat(counts: List[int], p: float=0.7812438910730323, target_prob: float=0.21875610892696773):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7812438910730323, target_prob=0.21875610892696773):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_965",
    "sat": "def sat(counts: List[int], p: float=0.8009468363201061, target_prob: float=0.4091100484967796):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8009468363201061, target_prob=0.4091100484967796):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_966",
    "sat": "def sat(counts: List[int], p: float=0.6428604415080272, target_prob: float=0.06697123032323067):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6428604415080272, target_prob=0.06697123032323067):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_967",
    "sat": "def sat(counts: List[int], p: float=0.15219786478274644, target_prob: float=9.312579711317306e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.15219786478274644, target_prob=9.312579711317306e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_968",
    "sat": "def sat(counts: List[int], p: float=0.7655424435980215, target_prob: float=0.00023851126797554056):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7655424435980215, target_prob=0.00023851126797554056):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_969",
    "sat": "def sat(counts: List[int], p: float=0.9472887122058178, target_prob: float=0.2666219132901691):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9472887122058178, target_prob=0.2666219132901691):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_970",
    "sat": "def sat(counts: List[int], p: float=0.47506221618519073, target_prob: float=0.18329624616998091):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47506221618519073, target_prob=0.18329624616998091):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_971",
    "sat": "def sat(counts: List[int], p: float=0.26471701326514885, target_prob: float=0.0704015786361577):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.26471701326514885, target_prob=0.0704015786361577):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_972",
    "sat": "def sat(counts: List[int], p: float=0.47262481149195923, target_prob: float=0.041144978198976855):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.47262481149195923, target_prob=0.041144978198976855):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_973",
    "sat": "def sat(counts: List[int], p: float=0.359931675092771, target_prob: float=0.023199462557594884):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.359931675092771, target_prob=0.023199462557594884):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_974",
    "sat": "def sat(counts: List[int], p: float=0.6137131149617744, target_prob: float=0.3862868850382256):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6137131149617744, target_prob=0.3862868850382256):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_975",
    "sat": "def sat(counts: List[int], p: float=0.8957958522724591, target_prob: float=1.4486552783144763e-09):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8957958522724591, target_prob=1.4486552783144763e-09):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_976",
    "sat": "def sat(counts: List[int], p: float=0.18224510006643868, target_prob: float=0.29806364713642486):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.18224510006643868, target_prob=0.29806364713642486):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_977",
    "sat": "def sat(counts: List[int], p: float=0.49322158905506375, target_prob: float=0.3081501936678582):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.49322158905506375, target_prob=0.3081501936678582):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_978",
    "sat": "def sat(counts: List[int], p: float=0.09841776766801069, target_prob: float=0.9015822323319893):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09841776766801069, target_prob=0.9015822323319893):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_979",
    "sat": "def sat(counts: List[int], p: float=0.9072663753740599, target_prob: float=0.22899611846807494):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.9072663753740599, target_prob=0.22899611846807494):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_980",
    "sat": "def sat(counts: List[int], p: float=0.6958611836997456, target_prob: float=0.40992053716644433):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6958611836997456, target_prob=0.40992053716644433):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_981",
    "sat": "def sat(counts: List[int], p: float=0.2056038523873308, target_prob: float=0.6310652393418497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.2056038523873308, target_prob=0.6310652393418497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_982",
    "sat": "def sat(counts: List[int], p: float=0.6986002671692794, target_prob: float=0.32455774303508333):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6986002671692794, target_prob=0.32455774303508333):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_983",
    "sat": "def sat(counts: List[int], p: float=0.7027366096842046, target_prob: float=0.17138108792737344):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.7027366096842046, target_prob=0.17138108792737344):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_984",
    "sat": "def sat(counts: List[int], p: float=0.1910679322787443, target_prob: float=6.016122422948796e-05):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.1910679322787443, target_prob=6.016122422948796e-05):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_985",
    "sat": "def sat(counts: List[int], p: float=0.09097066302964019, target_prob: float=0.9090293369703598):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.09097066302964019, target_prob=0.9090293369703598):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_986",
    "sat": "def sat(counts: List[int], p: float=0.07392909543107873, target_prob: float=0.34547375242152467):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.07392909543107873, target_prob=0.34547375242152467):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_987",
    "sat": "def sat(counts: List[int], p: float=0.3512530987924244, target_prob: float=0.18874692412881497):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.3512530987924244, target_prob=0.18874692412881497):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_988",
    "sat": "def sat(counts: List[int], p: float=0.8440019444793008, target_prob: float=0.06742165176900299):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8440019444793008, target_prob=0.06742165176900299):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_989",
    "sat": "def sat(counts: List[int], p: float=0.8311432535651688, target_prob: float=0.016336889224898378):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8311432535651688, target_prob=0.016336889224898378):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_990",
    "sat": "def sat(counts: List[int], p: float=0.25751079570439994, target_prob: float=0.09413835593156777):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.25751079570439994, target_prob=0.09413835593156777):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_991",
    "sat": "def sat(counts: List[int], p: float=0.04602584586838021, target_prob: float=0.04602584586838021):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.04602584586838021, target_prob=0.04602584586838021):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_992",
    "sat": "def sat(counts: List[int], p: float=0.4124196126159503, target_prob: float=0.0020282481149445767):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.4124196126159503, target_prob=0.0020282481149445767):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_993",
    "sat": "def sat(counts: List[int], p: float=0.724087824205456, target_prob: float=0.07556661314438955):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.724087824205456, target_prob=0.07556661314438955):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_994",
    "sat": "def sat(counts: List[int], p: float=0.6994439852150698, target_prob: float=0.6994439852150698):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.6994439852150698, target_prob=0.6994439852150698):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_995",
    "sat": "def sat(counts: List[int], p: float=0.06379609982792356, target_prob: float=1.0567460782820171e-06):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.06379609982792356, target_prob=1.0567460782820171e-06):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_996",
    "sat": "def sat(counts: List[int], p: float=0.40116633999297857, target_prob: float=0.16093443234336208):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.40116633999297857, target_prob=0.16093443234336208):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_997",
    "sat": "def sat(counts: List[int], p: float=0.02906624942568914, target_prob: float=0.0023970407602138186):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.02906624942568914, target_prob=0.0023970407602138186):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_998",
    "sat": "def sat(counts: List[int], p: float=0.8984523674619789, target_prob: float=0.5259813488305478):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.8984523674619789, target_prob=0.5259813488305478):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "BinomialProbabilities_999",
    "sat": "def sat(counts: List[int], p: float=0.771077131020303, target_prob: float=0.044067481721243945):\n    assert type(counts) is list and all(type(a) is int for a in counts), 'counts must be of type List[int]'\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "sols": [
      "def sol(p=0.771077131020303, target_prob=0.044067481721243945):\n    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ]
  },
  {
    "name": "ExponentialProbability_0",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.5):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_1",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.29381508328848427):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.29381508328848427):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_2",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.7594821007442389):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.7594821007442389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_3",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.08848373947217114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.08848373947217114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_4",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.20502531669793944):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.20502531669793944):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_5",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.8980427563722572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.8980427563722572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_6",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.6692404380399146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.6692404380399146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_7",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.29461710854304):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.29461710854304):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_8",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.2977620128149647):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.2977620128149647):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_9",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.054389734064553275):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.054389734064553275):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_10",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.760383949102956):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.760383949102956):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_11",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.6567234858360401):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.6567234858360401):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_12",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.763160538897962):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.763160538897962):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_13",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.4268795595294669):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.4268795595294669):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_14",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.3206082414506546):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.3206082414506546):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_15",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.7163599573894245):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.7163599573894245):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_16",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.018375171158668935):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.018375171158668935):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_17",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.3480385865315365):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.3480385865315365):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_18",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.21762692334781886):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.21762692334781886):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_19",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.4791793211750086):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.4791793211750086):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_20",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.7310606748419906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.7310606748419906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_21",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.8116892934424343):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.8116892934424343):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_22",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.2493569479266441):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.2493569479266441):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_23",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.031862868948851486):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.031862868948851486):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_24",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.1333588747005653):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.1333588747005653):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_25",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.6327444066606243):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.6327444066606243):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_26",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.3478422356134496):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.3478422356134496):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_27",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.06958571040982597):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.06958571040982597):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_28",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.7819026219983243):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.7819026219983243):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_29",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.7948187452744305):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.7948187452744305):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_30",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.9560517598717461):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.9560517598717461):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_31",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.14883812726005397):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.14883812726005397):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_32",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.1566789165251271):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.1566789165251271):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_33",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.0397458166480793):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.0397458166480793):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_34",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.9855121367415118):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.9855121367415118):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_35",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.9911243067903033):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.9911243067903033):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_36",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.11999208756193003):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.11999208756193003):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_37",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.7695175954187412):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.7695175954187412):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_38",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.41505583992069706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.41505583992069706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_39",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.26132378275867574):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.26132378275867574):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_40",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.589490295087287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.589490295087287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_41",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.599167023439538):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.599167023439538):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_42",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.336237782717128):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.336237782717128):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_43",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.05233839859978273):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.05233839859978273):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_44",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.07724014531901502):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.07724014531901502):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_45",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.9542152249496212):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.9542152249496212):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_46",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.6382153362788413):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.6382153362788413):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_47",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.2587574309917282):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.2587574309917282):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_48",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.5536573423037877):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.5536573423037877):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_49",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.17804454536165482):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.17804454536165482):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_50",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.24115778969765644):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.24115778969765644):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_51",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.6910036760100079):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.6910036760100079):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_52",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.2201221818644572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.2201221818644572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_53",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.2373580016616389):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.2373580016616389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_54",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.4520910888032562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.4520910888032562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_55",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.08530142828676823):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.08530142828676823):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_56",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.3694451049338676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.3694451049338676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_57",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.8107306808921356):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.8107306808921356):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_58",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.9873457416862207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.9873457416862207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_59",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.6974949913185826):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.6974949913185826):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_60",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.46729627996791645):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.46729627996791645):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_61",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.8066603988471781):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.8066603988471781):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_62",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.3395561905411837):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.3395561905411837):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_63",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.3059946173059883):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.3059946173059883):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_64",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.748653338973383):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.748653338973383):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_65",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.20064796125875406):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.20064796125875406):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_66",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.4956143585855839):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.4956143585855839):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_67",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.5234126790761755):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.5234126790761755):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_68",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.8268890801835883):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.8268890801835883):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_69",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.03696233382870362):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.03696233382870362):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_70",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.050738431916639515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.050738431916639515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_71",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.07637044683554983):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.07637044683554983):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_72",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.8481927819123365):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.8481927819123365):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_73",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.07145406179054858):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.07145406179054858):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_74",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.20257035984780303):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.20257035984780303):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_75",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.49890049333824205):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.49890049333824205):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_76",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.4110315339192413):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.4110315339192413):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_77",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.9578686341204877):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.9578686341204877):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_78",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.34619649814937736):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.34619649814937736):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_79",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.47546748026883634):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.47546748026883634):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_80",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.649004987318614):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.649004987318614):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_81",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.7586891792689796):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.7586891792689796):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_82",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.4474870666432684):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.4474870666432684):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_83",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.3159300662925879):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.3159300662925879):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_84",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.6767562639118251):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.6767562639118251):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_85",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.574432414581805):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.574432414581805):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_86",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.6306836319351462):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.6306836319351462):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_87",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.15810932141209877):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.15810932141209877):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_88",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.8795268582723862):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.8795268582723862):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_89",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.21785909531734549):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.21785909531734549):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_90",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.36915474160884154):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.36915474160884154):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_91",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.4022975059142865):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.4022975059142865):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_92",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.09168874865661936):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.09168874865661936):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_93",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.8688053819701759):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.8688053819701759):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_94",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.06120690925870442):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.06120690925870442):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_95",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.18681290239855752):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.18681290239855752):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_96",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.5641922977136227):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.5641922977136227):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_97",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.7206931417980307):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.7206931417980307):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_98",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.197240135590653):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.197240135590653):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_99",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.8609260007351763):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.8609260007351763):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_100",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.5259713934987642):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.5259713934987642):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_101",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6694786569767242):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6694786569767242):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_102",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.874810272126608):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.874810272126608):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_103",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.8084382391969113):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.8084382391969113):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_104",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.376363037152755):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.376363037152755):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_105",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.10194082331926879):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.10194082331926879):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_106",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.016216268600319883):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.016216268600319883):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_107",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.03825363740066301):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.03825363740066301):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_108",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.883284718833087):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.883284718833087):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_109",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.8993621248680216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.8993621248680216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_110",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.927184968689284):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.927184968689284):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_111",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.8078640232787124):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.8078640232787124):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_112",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.4553973018555416):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.4553973018555416):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_113",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.824198476506965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.824198476506965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_114",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.7949718945031964):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.7949718945031964):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_115",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.44283575079698123):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.44283575079698123):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_116",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.45160200447791143):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.45160200447791143):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_117",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.345418253847225):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.345418253847225):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_118",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.995641292623287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.995641292623287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_119",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.20189836012800555):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.20189836012800555):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_120",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.8042372113941275):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.8042372113941275):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_121",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.7696362405791588):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.7696362405791588):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_122",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.3823301605410082):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.3823301605410082):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_123",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.12694921002505166):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.12694921002505166):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_124",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.562966479006179):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.562966479006179):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_125",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.6603934996279518):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.6603934996279518):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_126",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.09455313396385367):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.09455313396385367):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_127",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.08230857854451679):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.08230857854451679):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_128",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6997925697483783):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6997925697483783):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_129",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.5237880301481369):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.5237880301481369):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_130",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.5947285130021361):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.5947285130021361):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_131",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.8970982085356018):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.8970982085356018):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_132",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.24470417709546444):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.24470417709546444):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_133",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.935618376816984):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.935618376816984):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_134",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.19009150866901703):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.19009150866901703):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_135",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.2762494715671616):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.2762494715671616):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_136",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.46398617635705586):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.46398617635705586):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_137",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.3863420194744117):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.3863420194744117):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_138",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.12703913196075267):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.12703913196075267):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_139",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.5954941093935288):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.5954941093935288):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_140",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.025459131423498538):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.025459131423498538):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_141",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.9995483224932965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.9995483224932965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_142",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.04367716680806666):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.04367716680806666):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_143",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.43723481130163866):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.43723481130163866):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_144",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.13083870770660433):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.13083870770660433):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_145",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7557491467223841):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7557491467223841):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_146",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.32722353268475535):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.32722353268475535):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_147",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.27342769113334997):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.27342769113334997):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_148",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.6995549515236006):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.6995549515236006):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_149",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.9353346194294178):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.9353346194294178):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_150",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.30642594221389585):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.30642594221389585):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_151",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.5441129460588278):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.5441129460588278):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_152",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.1691566176933328):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.1691566176933328):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_153",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.5612648215746142):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.5612648215746142):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_154",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.4417104711052674):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.4417104711052674):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_155",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.8903022575635082):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.8903022575635082):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_156",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.026447623368638706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.026447623368638706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_157",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.4660162092866772):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.4660162092866772):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_158",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.5239849178645326):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.5239849178645326):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_159",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.8475910970381932):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.8475910970381932):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_160",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.40644509028662257):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.40644509028662257):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_161",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.29201873035121695):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.29201873035121695):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_162",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.46261797673322513):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.46261797673322513):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_163",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.08542502017124498):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.08542502017124498):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_164",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.1766243429328952):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.1766243429328952):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_165",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.20729961978138012):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.20729961978138012):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_166",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.39980333422942826):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.39980333422942826):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_167",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.07946415519674321):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.07946415519674321):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_168",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.531838413224995):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.531838413224995):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_169",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.5727616794205442):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.5727616794205442):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_170",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.5609001219271723):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.5609001219271723):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_171",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.45436105207035615):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.45436105207035615):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_172",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.7874974253600375):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.7874974253600375):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_173",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.1806275315142779):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.1806275315142779):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_174",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.673180394576735):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.673180394576735):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_175",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.3621501903269577):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.3621501903269577):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_176",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.03604049616252303):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.03604049616252303):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_177",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.919556714167785):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.919556714167785):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_178",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.0649455883481973):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.0649455883481973):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_179",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.5189856889602477):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.5189856889602477):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_180",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.12202095213846664):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.12202095213846664):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_181",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.5500461458579067):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.5500461458579067):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_182",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.6292064015574014):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.6292064015574014):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_183",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.9477879346907246):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.9477879346907246):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_184",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.6620560048005389):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.6620560048005389):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_185",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.25097847094061265):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.25097847094061265):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_186",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.6434682573800491):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.6434682573800491):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_187",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.6297807105568786):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.6297807105568786):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_188",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.007688356720355283):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.007688356720355283):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_189",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.37916043936869004):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.37916043936869004):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_190",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.3859987486854033):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.3859987486854033):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_191",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.7913872643611409):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.7913872643611409):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_192",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.4008295183839372):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.4008295183839372):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_193",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.9902052986118384):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.9902052986118384):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_194",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.07017558321796291):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.07017558321796291):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_195",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.9794699377787663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.9794699377787663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_196",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.20909459677602382):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.20909459677602382):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_197",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.31012781587934923):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.31012781587934923):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_198",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.9722048434526134):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.9722048434526134):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_199",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.5089795341734945):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.5089795341734945):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_200",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.07357350575605348):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.07357350575605348):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_201",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.7825439144265238):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.7825439144265238):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_202",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.7561223091829148):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.7561223091829148):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_203",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.2960582889900424):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.2960582889900424):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_204",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.8285072195394955):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.8285072195394955):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_205",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.115846901836556):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.115846901836556):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_206",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.9450138478044017):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.9450138478044017):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_207",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.45879732918369986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.45879732918369986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_208",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.22241402412972533):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.22241402412972533):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_209",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.07390270357291084):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.07390270357291084):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_210",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.2654843127011962):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.2654843127011962):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_211",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.8903647856877352):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.8903647856877352):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_212",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.3625354488710194):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.3625354488710194):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_213",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.32740823223183746):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.32740823223183746):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_214",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.6211143928641579):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.6211143928641579):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_215",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.9169955621372201):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.9169955621372201):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_216",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.6669629227857793):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.6669629227857793):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_217",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.1562511655746549):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.1562511655746549):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_218",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.587423193607095):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.587423193607095):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_219",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.3141606433811175):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.3141606433811175):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_220",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.2446780651758914):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.2446780651758914):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_221",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.6080243068133633):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.6080243068133633):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_222",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.3460982204794746):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.3460982204794746):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_223",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.2549382728891908):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.2549382728891908):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_224",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.4258395510508083):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.4258395510508083):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_225",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.23053930473617867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.23053930473617867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_226",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.8847607672130882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.8847607672130882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_227",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.6901325808415774):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.6901325808415774):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_228",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.9366441394207423):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.9366441394207423):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_229",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.32744563808117044):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.32744563808117044):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_230",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.7206169653329446):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.7206169653329446):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_231",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.645447660119562):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.645447660119562):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_232",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.6995518897806792):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.6995518897806792):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_233",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.1380460058033156):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.1380460058033156):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_234",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.8492616134399865):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.8492616134399865):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_235",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.3652146819985419):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.3652146819985419):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_236",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.42002324668890334):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.42002324668890334):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_237",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.30313657974649044):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.30313657974649044):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_238",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.7578699283651928):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.7578699283651928):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_239",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.8912414297051114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.8912414297051114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_240",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.1275559029986464):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.1275559029986464):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_241",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.4543190409994552):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.4543190409994552):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_242",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.7564586278086859):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.7564586278086859):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_243",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.5340923533428236):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.5340923533428236):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_244",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.5810946288043879):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.5810946288043879):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_245",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.7411420460809218):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.7411420460809218):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_246",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.7291350159688771):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.7291350159688771):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_247",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.8188558310196881):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.8188558310196881):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_248",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.06753742974308397):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.06753742974308397):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_249",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.67992062794917):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.67992062794917):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_250",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.47896518032206137):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.47896518032206137):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_251",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.2474223566107705):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.2474223566107705):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_252",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.39912387707899943):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.39912387707899943):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_253",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.1867853259951665):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.1867853259951665):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_254",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.4701438836862656):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.4701438836862656):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_255",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.4472689919932271):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.4472689919932271):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_256",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.48018229536565626):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.48018229536565626):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_257",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.06174459467224025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.06174459467224025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_258",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.37184933797345965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.37184933797345965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_259",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.4135310840045038):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.4135310840045038):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_260",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.051563372453799494):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.051563372453799494):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_261",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.08306301440240804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.08306301440240804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_262",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.9892931869017906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.9892931869017906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_263",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.08862972367925015):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.08862972367925015):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_264",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.47588496772635835):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.47588496772635835):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_265",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.3025169632072878):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.3025169632072878):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_266",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.5178886187059978):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.5178886187059978):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_267",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.1685215854727914):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.1685215854727914):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_268",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.13537210672046873):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.13537210672046873):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_269",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.4911006657980035):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.4911006657980035):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_270",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.5180020306716767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.5180020306716767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_271",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.831897251760504):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.831897251760504):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_272",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.6678595647859482):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.6678595647859482):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_273",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.5871717325348124):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.5871717325348124):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_274",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.8152523375830308):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.8152523375830308):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_275",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.15343818444097201):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.15343818444097201):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_276",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.23190721335629771):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.23190721335629771):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_277",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.15879106187273484):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.15879106187273484):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_278",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.31928981270398915):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.31928981270398915):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_279",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.3893370960702027):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.3893370960702027):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_280",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.6062933376512812):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.6062933376512812):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_281",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.0827281261963081):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.0827281261963081):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_282",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.3549897882371438):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.3549897882371438):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_283",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.061443324600248816):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.061443324600248816):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_284",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.722119146326287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.722119146326287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_285",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.39386715550790274):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.39386715550790274):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_286",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.5907642418488126):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.5907642418488126):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_287",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.720110103257612):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.720110103257612):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_288",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7757421300383973):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7757421300383973):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_289",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.922054069965188):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.922054069965188):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_290",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.3498568633908413):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.3498568633908413):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_291",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.1932216140767703):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.1932216140767703):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_292",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.7010297036722768):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.7010297036722768):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_293",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.31063087886425855):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.31063087886425855):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_294",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.992378504925458):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.992378504925458):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_295",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.08705382934898909):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.08705382934898909):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_296",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.8396200224565576):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.8396200224565576):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_297",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.04287208131353082):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.04287208131353082):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_298",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.01617711243021447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.01617711243021447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_299",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.7713905842023016):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.7713905842023016):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_300",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.6337020811499899):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.6337020811499899):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_301",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.4131157986458066):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.4131157986458066):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_302",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.3581354099813169):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.3581354099813169):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_303",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.5674153668667706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.5674153668667706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_304",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.37187418458760635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.37187418458760635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_305",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.5658967958873723):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.5658967958873723):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_306",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.0679333266023322):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.0679333266023322):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_307",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.2070625487896256):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.2070625487896256):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_308",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.6521421027573254):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.6521421027573254):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_309",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.26385056429620757):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.26385056429620757):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_310",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.21447181506945678):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.21447181506945678):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_311",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.7057770081916657):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.7057770081916657):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_312",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.4673008383811298):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.4673008383811298):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_313",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.561608435984949):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.561608435984949):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_314",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.025118972364860825):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.025118972364860825):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_315",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.8980656027640447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.8980656027640447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_316",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.9300532374111895):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.9300532374111895):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_317",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.22091445942820653):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.22091445942820653):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_318",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.1834349507926416):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.1834349507926416):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_319",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.2032427291866188):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.2032427291866188):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_320",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.7170919076007488):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.7170919076007488):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_321",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.7464227864010965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.7464227864010965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_322",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.6664591095822293):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.6664591095822293):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_323",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.9681879477439252):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.9681879477439252):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_324",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.23779104219926606):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.23779104219926606):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_325",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.6407190917088801):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.6407190917088801):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_326",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.05764559989484397):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.05764559989484397):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_327",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.36680114725265345):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.36680114725265345):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_328",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.12341971760214776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.12341971760214776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_329",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.3867221188186014):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.3867221188186014):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_330",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.3802307957158715):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.3802307957158715):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_331",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7962873111470178):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7962873111470178):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_332",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.17734799134289858):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.17734799134289858):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_333",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.8514357995563759):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.8514357995563759):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_334",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.3709870644885551):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.3709870644885551):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_335",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.1658407094671368):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.1658407094671368):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_336",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.6353395853584468):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.6353395853584468):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_337",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.1350994553202557):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.1350994553202557):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_338",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.12383541934106101):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.12383541934106101):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_339",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.902842979816507):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.902842979816507):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_340",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.19900163083325684):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.19900163083325684):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_341",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.9714873572538957):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.9714873572538957):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_342",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.9885595485163242):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.9885595485163242):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_343",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.4653185377629161):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.4653185377629161):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_344",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.2575322999588804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.2575322999588804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_345",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.17914515169447442):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.17914515169447442):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_346",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.8890027947247301):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.8890027947247301):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_347",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.3470828366229285):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.3470828366229285):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_348",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.3645166139006324):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.3645166139006324):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_349",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.0009167180990166113):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.0009167180990166113):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_350",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.42901393102190144):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.42901393102190144):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_351",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6027001703643163):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6027001703643163):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_352",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.23550495235267277):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.23550495235267277):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_353",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.35741706088197545):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.35741706088197545):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_354",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.7784617889568474):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.7784617889568474):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_355",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.5664621369630093):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.5664621369630093):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_356",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.592248835534272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.592248835534272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_357",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.25991660415193185):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.25991660415193185):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_358",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.4843280489043956):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.4843280489043956):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_359",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.36218191874832706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.36218191874832706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_360",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.4529402065758442):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.4529402065758442):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_361",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.36390925672413055):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.36390925672413055):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_362",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.7995219736444146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.7995219736444146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_363",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.4503449677388003):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.4503449677388003):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_364",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.2924670656052999):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.2924670656052999):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_365",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.3710637017426738):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.3710637017426738):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_366",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.7846527915291315):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.7846527915291315):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_367",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.41139229115631337):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.41139229115631337):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_368",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.32376504232475434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.32376504232475434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_369",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.32156349360308456):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.32156349360308456):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_370",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.27490080174822096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.27490080174822096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_371",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.5057032191597702):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.5057032191597702):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_372",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.40352939646057906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.40352939646057906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_373",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.9069412581046077):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.9069412581046077):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_374",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.9109694469476171):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.9109694469476171):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_375",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.9617758176380536):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.9617758176380536):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_376",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.27678007226416):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.27678007226416):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_377",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.3482314205839322):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.3482314205839322):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_378",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.4668477732407964):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.4668477732407964):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_379",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.9719849851027272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.9719849851027272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_380",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.5423419240562258):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.5423419240562258):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_381",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.9911277481092395):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.9911277481092395):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_382",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.7367116934965005):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.7367116934965005):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_383",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.1270914881196925):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.1270914881196925):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_384",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.685730282440169):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.685730282440169):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_385",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.27423628170554404):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.27423628170554404):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_386",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.9248072291336081):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.9248072291336081):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_387",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.5268374938783804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.5268374938783804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_388",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.47694735564689283):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.47694735564689283):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_389",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.05996384629189988):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.05996384629189988):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_390",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.9377942020569201):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.9377942020569201):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_391",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.4489721220050821):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.4489721220050821):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_392",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.016049988428129325):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.016049988428129325):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_393",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.4674066454906868):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.4674066454906868):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_394",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7080094010548068):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7080094010548068):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_395",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.9069628312428828):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.9069628312428828):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_396",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.1988870563233074):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.1988870563233074):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_397",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.5761275631182584):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.5761275631182584):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_398",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.2967927490785419):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.2967927490785419):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_399",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.2868966466744307):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.2868966466744307):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_400",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.10658188857981854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.10658188857981854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_401",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.050314021265161935):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.050314021265161935):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_402",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.6385850072948622):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.6385850072948622):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_403",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.5774587175292065):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.5774587175292065):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_404",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.6280934676020706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.6280934676020706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_405",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.02167226964397473):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.02167226964397473):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_406",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.23754012438973438):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.23754012438973438):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_407",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.8406904815348998):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.8406904815348998):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_408",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7315186389234871):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7315186389234871):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_409",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.7380337122417684):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.7380337122417684):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_410",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.2065078446974572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.2065078446974572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_411",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.052799029251297425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.052799029251297425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_412",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.2894517655971659):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.2894517655971659):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_413",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.5839733292383602):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.5839733292383602):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_414",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.6144012577660052):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.6144012577660052):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_415",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.3878842240939242):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.3878842240939242):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_416",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.16110611301057598):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.16110611301057598):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_417",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.6118410558129797):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.6118410558129797):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_418",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.8588675806367976):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.8588675806367976):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_419",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.9760478212193529):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.9760478212193529):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_420",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.4307737388694515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.4307737388694515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_421",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.34136225263954656):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.34136225263954656):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_422",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.7813049062745583):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.7813049062745583):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_423",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.4555097460353157):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.4555097460353157):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_424",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.37813258638096203):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.37813258638096203):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_425",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.6802400958957202):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.6802400958957202):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_426",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.2004633290093586):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.2004633290093586):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_427",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.7251437258630928):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.7251437258630928):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_428",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.5438611696593327):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.5438611696593327):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_429",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.9670865367154985):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.9670865367154985):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_430",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.5561597568148484):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.5561597568148484):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_431",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.7346662681010513):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.7346662681010513):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_432",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.8868346120869958):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.8868346120869958):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_433",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.3074768994725867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.3074768994725867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_434",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.0892207895721715):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.0892207895721715):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_435",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.18145718280899747):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.18145718280899747):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_436",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.637952254462266):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.637952254462266):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_437",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.8449540702470622):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.8449540702470622):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_438",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.5850968257268349):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.5850968257268349):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_439",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.8554680641292879):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.8554680641292879):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_440",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.8894006160213794):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.8894006160213794):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_441",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.9195723815893566):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.9195723815893566):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_442",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.008274340195154162):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.008274340195154162):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_443",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.7312112161738606):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.7312112161738606):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_444",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.7864141093537594):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.7864141093537594):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_445",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.292644052608115):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.292644052608115):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_446",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.2750983323967249):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.2750983323967249):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_447",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.4211148349719753):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.4211148349719753):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_448",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.4606051512536431):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.4606051512536431):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_449",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.6326799688799336):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.6326799688799336):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_450",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.6719375728700048):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.6719375728700048):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_451",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.16495085941560617):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.16495085941560617):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_452",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.7811224957547407):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.7811224957547407):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_453",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.6692015745274165):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.6692015745274165):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_454",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.22774726214646068):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.22774726214646068):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_455",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.5920756605786722):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.5920756605786722):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_456",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.40364120950168203):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.40364120950168203):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_457",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.26291621493459605):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.26291621493459605):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_458",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.8311638896456425):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.8311638896456425):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_459",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.054581316954738):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.054581316954738):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_460",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.7649834998976289):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.7649834998976289):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_461",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.3203412305967376):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.3203412305967376):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_462",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.6203943797120459):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.6203943797120459):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_463",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.43428203704798785):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.43428203704798785):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_464",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.3443911022572512):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.3443911022572512):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_465",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.9148156438649915):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.9148156438649915):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_466",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.07063086139778663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.07063086139778663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_467",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.5212840688879998):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.5212840688879998):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_468",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.19939805806259114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.19939805806259114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_469",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.2949392552373804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.2949392552373804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_470",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.5881438513354381):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.5881438513354381):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_471",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.5804422588802404):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.5804422588802404):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_472",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.9671347157124237):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.9671347157124237):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_473",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.7024504229229582):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.7024504229229582):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_474",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.48030324467302854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.48030324467302854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_475",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.6764421583410475):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.6764421583410475):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_476",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.16408986686832472):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.16408986686832472):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_477",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.8093071785993146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.8093071785993146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_478",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.9246159545568873):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.9246159545568873):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_479",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.6254981784246879):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.6254981784246879):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_480",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.5986412884540089):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.5986412884540089):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_481",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.5433834675528818):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.5433834675528818):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_482",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.9938426888303716):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.9938426888303716):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_483",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.5051068027822897):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.5051068027822897):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_484",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.6898236804298441):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.6898236804298441):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_485",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.1622230704697406):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.1622230704697406):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_486",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.6437393318593119):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.6437393318593119):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_487",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.5386606035762671):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.5386606035762671):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_488",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.05426004743134438):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.05426004743134438):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_489",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.9902932292716347):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.9902932292716347):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_490",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.4019957489603986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.4019957489603986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_491",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.8062054582791671):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.8062054582791671):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_492",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.9015857993854594):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.9015857993854594):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_493",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.007306462174572204):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.007306462174572204):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_494",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.9005716639765662):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.9005716639765662):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_495",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.23764862804998443):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.23764862804998443):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_496",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.20645286106781569):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.20645286106781569):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_497",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.021871189443709804):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.021871189443709804):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_498",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.5562995783020885):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.5562995783020885):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_499",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.18745487960363216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.18745487960363216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_500",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.6427075754906245):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.6427075754906245):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_501",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.2717306755483745):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.2717306755483745):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_502",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.8164916389221383):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.8164916389221383):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_503",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.13120408483274792):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.13120408483274792):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_504",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.43922269573883854):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.43922269573883854):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_505",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.8764176364332561):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.8764176364332561):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_506",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.14952139068682457):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.14952139068682457):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_507",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.15531744402929704):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.15531744402929704):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_508",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.24008126898865256):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.24008126898865256):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_509",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.9545855369508466):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.9545855369508466):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_510",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.17697195023261592):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.17697195023261592):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_511",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.4536296869590877):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.4536296869590877):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_512",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.45182121035695055):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.45182121035695055):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_513",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.3713062185790946):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.3713062185790946):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_514",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.05233491176883698):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.05233491176883698):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_515",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.6010408486326246):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.6010408486326246):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_516",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.3360023417348025):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.3360023417348025):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_517",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.45816619381463786):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.45816619381463786):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_518",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.03774656873040427):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.03774656873040427):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_519",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.6169634955364168):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.6169634955364168):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_520",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.6246658438650359):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.6246658438650359):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_521",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.23306041967335767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.23306041967335767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_522",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.044948283844872705):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.044948283844872705):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_523",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.7805744434968322):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.7805744434968322):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_524",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.38729155540999605):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.38729155540999605):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_525",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.8346955483460654):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.8346955483460654):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_526",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.12315971882824062):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.12315971882824062):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_527",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.8939587835423592):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.8939587835423592):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_528",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.1228781770572912):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.1228781770572912):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_529",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.4161025410398622):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.4161025410398622):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_530",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.5851483562759763):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.5851483562759763):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_531",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.44870306386848324):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.44870306386848324):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_532",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.41614869079865335):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.41614869079865335):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_533",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.20118816121758132):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.20118816121758132):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_534",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.4024077984871668):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.4024077984871668):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_535",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.18457976203241788):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.18457976203241788):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_536",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.2386333294155354):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.2386333294155354):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_537",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.32760489448263275):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.32760489448263275):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_538",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.5510365259700452):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.5510365259700452):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_539",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.8497767625703768):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.8497767625703768):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_540",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.6814953429162485):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.6814953429162485):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_541",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.8405799911642561):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.8405799911642561):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_542",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.5469274432412834):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.5469274432412834):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_543",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.07137226448605527):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.07137226448605527):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_544",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.37241244903794835):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.37241244903794835):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_545",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.5269362097432827):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.5269362097432827):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_546",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.043409659336861806):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.043409659336861806):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_547",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.5270668236874814):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.5270668236874814):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_548",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.7002377129897951):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.7002377129897951):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_549",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.9217205916942941):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.9217205916942941):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_550",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.4904359945995249):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.4904359945995249):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_551",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.8646047165135187):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.8646047165135187):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_552",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.45144388304084937):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.45144388304084937):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_553",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.9422070773300417):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.9422070773300417):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_554",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.5286689701942938):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.5286689701942938):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_555",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.7822622007144795):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.7822622007144795):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_556",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.8655950548486591):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.8655950548486591):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_557",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.7262765551160832):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.7262765551160832):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_558",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.6730551247457626):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.6730551247457626):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_559",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.9064303920699811):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.9064303920699811):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_560",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.7396900364675751):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.7396900364675751):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_561",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.3143091313254588):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.3143091313254588):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_562",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.7294122019802505):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.7294122019802505):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_563",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.8587115597786781):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.8587115597786781):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_564",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.378640526254277):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.378640526254277):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_565",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.44596337286942145):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.44596337286942145):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_566",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.13731456785775986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.13731456785775986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_567",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.05310157140633409):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.05310157140633409):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_568",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.4856877114565651):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.4856877114565651):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_569",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.9233756361000334):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.9233756361000334):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_570",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.25505202520457215):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.25505202520457215):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_571",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.7053681803410333):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.7053681803410333):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_572",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.8533246492756151):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.8533246492756151):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_573",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.7774185218764244):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.7774185218764244):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_574",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.6713057194734229):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.6713057194734229):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_575",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.2385398879491718):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.2385398879491718):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_576",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.808045949691355):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.808045949691355):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_577",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.1579028836665286):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.1579028836665286):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_578",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.2895602662599145):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.2895602662599145):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_579",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.5206026581281765):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.5206026581281765):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_580",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.750433362926721):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.750433362926721):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_581",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.30136228986344527):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.30136228986344527):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_582",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.6824233822588411):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.6824233822588411):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_583",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.22102092977576304):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.22102092977576304):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_584",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.2903698737718099):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.2903698737718099):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_585",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.17539865112267572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.17539865112267572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_586",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.5157804502195755):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.5157804502195755):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_587",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.605612247739268):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.605612247739268):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_588",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.8510906679690984):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.8510906679690984):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_589",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.42843214715770594):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.42843214715770594):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_590",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.5868784872810229):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.5868784872810229):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_591",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.404122499871991):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.404122499871991):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_592",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.0967524946754087):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.0967524946754087):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_593",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.027070084696421137):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.027070084696421137):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_594",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.13009526836713747):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.13009526836713747):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_595",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.7731464622275754):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.7731464622275754):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_596",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.9448705919147382):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.9448705919147382):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_597",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7298862575309377):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7298862575309377):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_598",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.2937682366394615):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.2937682366394615):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_599",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.1334487841823011):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.1334487841823011):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_600",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.9626601023133403):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.9626601023133403):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_601",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.19167656569546):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.19167656569546):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_602",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.49508058192269766):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.49508058192269766):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_603",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.7479245159203434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.7479245159203434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_604",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.4991691017280817):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.4991691017280817):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_605",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.3789153579778024):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.3789153579778024):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_606",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.8389019035842217):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.8389019035842217):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_607",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.14797881257866985):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.14797881257866985):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_608",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.21184332505063275):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.21184332505063275):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_609",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.8422776612601028):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.8422776612601028):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_610",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.279066894312091):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.279066894312091):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_611",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.35927135423389867):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.35927135423389867):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_612",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.1714733483241767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.1714733483241767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_613",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.6042162971305776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.6042162971305776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_614",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.0562345995793756):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.0562345995793756):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_615",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.8158943021978411):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.8158943021978411):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_616",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.5736024235092438):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.5736024235092438):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_617",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.20594275405814733):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.20594275405814733):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_618",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.2108953457775724):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.2108953457775724):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_619",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.35057496920856457):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.35057496920856457):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_620",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.02269825491150146):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.02269825491150146):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_621",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.38102652707519513):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.38102652707519513):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_622",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.46308999340070023):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.46308999340070023):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_623",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.36424898056696564):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.36424898056696564):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_624",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.9057458945317555):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.9057458945317555):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_625",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.8484110792541658):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.8484110792541658):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_626",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.08101762577115801):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.08101762577115801):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_627",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.34204830897215255):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.34204830897215255):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_628",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.6448781840675109):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.6448781840675109):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_629",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.28270972934312355):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.28270972934312355):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_630",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.10908543969894302):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.10908543969894302):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_631",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.44392536698711726):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.44392536698711726):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_632",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.21858993484124):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.21858993484124):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_633",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.8291908398251447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.8291908398251447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_634",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.5045109288787178):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.5045109288787178):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_635",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.1566366504314456):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.1566366504314456):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_636",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.6477563698783434):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.6477563698783434):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_637",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.9158116042884997):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.9158116042884997):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_638",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.6454430298016511):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.6454430298016511):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_639",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.43035598873689407):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.43035598873689407):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_640",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.04177469279462065):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.04177469279462065):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_641",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.09616054457895162):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.09616054457895162):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_642",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.19660282583160016):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.19660282583160016):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_643",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7024703643063618):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7024703643063618):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_644",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.17217175381220462):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.17217175381220462):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_645",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.46539854677553216):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.46539854677553216):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_646",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.13248742629734334):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.13248742629734334):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_647",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.35782344452108306):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.35782344452108306):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_648",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.07347388347912687):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.07347388347912687):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_649",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.5699640993474698):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.5699640993474698):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_650",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.8842867040189845):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.8842867040189845):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_651",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.1763829558623674):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.1763829558623674):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_652",
    "sat": "def sat(p_stop: float, steps: int=32, target_prob: float=0.636254553109166):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=32, target_prob=0.636254553109166):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_653",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.972400464770311):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.972400464770311):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_654",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.07390566350816064):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.07390566350816064):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_655",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.19097501657071736):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.19097501657071736):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_656",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.9203038137393077):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.9203038137393077):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_657",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.4976473473532603):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.4976473473532603):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_658",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.7575585974998924):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.7575585974998924):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_659",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.32112515059362523):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.32112515059362523):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_660",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.3109846400662747):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.3109846400662747):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_661",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.6157773351306769):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.6157773351306769):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_662",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7994642658226617):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7994642658226617):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_663",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.09514133243057776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.09514133243057776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_664",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.9722816738958687):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.9722816738958687):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_665",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.7251537525514682):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.7251537525514682):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_666",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.23826105172395418):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.23826105172395418):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_667",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.5652424388014844):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.5652424388014844):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_668",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.4664299153669176):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.4664299153669176):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_669",
    "sat": "def sat(p_stop: float, steps: int=96, target_prob: float=0.7714598024724572):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=96, target_prob=0.7714598024724572):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_670",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.7361084927707655):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.7361084927707655):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_671",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.26499338833684427):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.26499338833684427):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_672",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.014676655528326532):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.014676655528326532):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_673",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.9162676824598117):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.9162676824598117):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_674",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.30960766843525866):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.30960766843525866):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_675",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.18603307077969378):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.18603307077969378):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_676",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.8143739072584547):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.8143739072584547):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_677",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.6503912909536635):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.6503912909536635):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_678",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.1722603812330501):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.1722603812330501):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_679",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.20710183823817296):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.20710183823817296):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_680",
    "sat": "def sat(p_stop: float, steps: int=19, target_prob: float=0.34338279780073855):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=19, target_prob=0.34338279780073855):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_681",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.8500960484082584):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.8500960484082584):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_682",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.508199917193446):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.508199917193446):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_683",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.33859247788874614):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.33859247788874614):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_684",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.697625187943851):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.697625187943851):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_685",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.17938341428304272):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.17938341428304272):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_686",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.7271721145982287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.7271721145982287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_687",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.7117608307752624):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.7117608307752624):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_688",
    "sat": "def sat(p_stop: float, steps: int=7, target_prob: float=0.41248445235856424):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=7, target_prob=0.41248445235856424):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_689",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.5142618340930737):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.5142618340930737):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_690",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.33782731247159603):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.33782731247159603):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_691",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.36227610764402596):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.36227610764402596):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_692",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.17688013514526246):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.17688013514526246):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_693",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.2048719752384316):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.2048719752384316):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_694",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.06601416703832419):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.06601416703832419):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_695",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.6266581844262643):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.6266581844262643):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_696",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.5483759804777485):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.5483759804777485):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_697",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.6057251712982337):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.6057251712982337):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_698",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.26377631138289637):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.26377631138289637):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_699",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9882544043394417):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9882544043394417):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_700",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.507501534958074):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.507501534958074):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_701",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.9222361864782113):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.9222361864782113):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_702",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.9733286269125319):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.9733286269125319):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_703",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.6636488589942995):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.6636488589942995):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_704",
    "sat": "def sat(p_stop: float, steps: int=86, target_prob: float=0.7216012534618368):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=86, target_prob=0.7216012534618368):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_705",
    "sat": "def sat(p_stop: float, steps: int=16, target_prob: float=0.015580566554034614):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=16, target_prob=0.015580566554034614):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_706",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.36608747887612847):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.36608747887612847):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_707",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.06439662517927713):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.06439662517927713):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_708",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.014714460518293171):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.014714460518293171):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_709",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.6334044970048412):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.6334044970048412):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_710",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.7371865589003328):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.7371865589003328):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_711",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.29902010999721096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.29902010999721096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_712",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.050099634574719776):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.050099634574719776):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_713",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.8043679954443652):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.8043679954443652):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_714",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.20380767089830287):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.20380767089830287):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_715",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.20000607007434557):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.20000607007434557):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_716",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.630715376714744):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.630715376714744):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_717",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.40999174937591576):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.40999174937591576):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_718",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.6755459107720727):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.6755459107720727):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_719",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.8837459692544511):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.8837459692544511):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_720",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.5608883104244613):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.5608883104244613):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_721",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.34517943357500214):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.34517943357500214):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_722",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.18889561507980346):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.18889561507980346):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_723",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.7856115703300093):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.7856115703300093):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_724",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.9201615173621013):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.9201615173621013):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_725",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.1915862762571653):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.1915862762571653):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_726",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.7049287748446121):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.7049287748446121):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_727",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.22980093372321264):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.22980093372321264):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_728",
    "sat": "def sat(p_stop: float, steps: int=27, target_prob: float=0.11457987288549687):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=27, target_prob=0.11457987288549687):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_729",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.34022916364478606):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.34022916364478606):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_730",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.732982742016375):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.732982742016375):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_731",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.06765539764181483):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.06765539764181483):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_732",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.897742331308783):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.897742331308783):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_733",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.809394191505248):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.809394191505248):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_734",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.012704371150385696):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.012704371150385696):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_735",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.06661658764061917):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.06661658764061917):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_736",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.513909828131172):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.513909828131172):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_737",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.7577936242760618):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.7577936242760618):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_738",
    "sat": "def sat(p_stop: float, steps: int=75, target_prob: float=0.9985462193648609):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=75, target_prob=0.9985462193648609):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_739",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.34439867720542683):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.34439867720542683):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_740",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.06679051957479465):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.06679051957479465):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_741",
    "sat": "def sat(p_stop: float, steps: int=61, target_prob: float=0.17418702660026109):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=61, target_prob=0.17418702660026109):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_742",
    "sat": "def sat(p_stop: float, steps: int=10, target_prob: float=0.7447642700527182):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=10, target_prob=0.7447642700527182):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_743",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.47551256266065356):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.47551256266065356):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_744",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.31894825024638074):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.31894825024638074):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_745",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.9987912816297262):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.9987912816297262):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_746",
    "sat": "def sat(p_stop: float, steps: int=5, target_prob: float=0.5133224317657344):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=5, target_prob=0.5133224317657344):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_747",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.7157563188418905):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.7157563188418905):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_748",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.4539234970390519):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.4539234970390519):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_749",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.9704081993844056):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.9704081993844056):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_750",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.44320551310506495):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.44320551310506495):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_751",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.7075212997322067):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.7075212997322067):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_752",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.9783054348196542):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.9783054348196542):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_753",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.9586461788584991):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.9586461788584991):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_754",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.007165697127147874):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.007165697127147874):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_755",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.08068724535621408):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.08068724535621408):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_756",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.9421590754054038):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.9421590754054038):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_757",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.2448437325776326):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.2448437325776326):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_758",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.32407700615501944):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.32407700615501944):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_759",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.06588287024147443):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.06588287024147443):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_760",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.6024385342844117):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.6024385342844117):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_761",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.5085325698999276):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.5085325698999276):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_762",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.9381457938544006):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.9381457938544006):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_763",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.29131533743283256):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.29131533743283256):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_764",
    "sat": "def sat(p_stop: float, steps: int=70, target_prob: float=0.9805360246163243):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=70, target_prob=0.9805360246163243):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_765",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.6986854657220536):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.6986854657220536):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_766",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.3761363829722397):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.3761363829722397):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_767",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.36858006801182586):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.36858006801182586):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_768",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.6254500586474342):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.6254500586474342):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_769",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.1670965695451223):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.1670965695451223):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_770",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.5573320154759576):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.5573320154759576):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_771",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.1498731215392799):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.1498731215392799):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_772",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.5491299335833095):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.5491299335833095):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_773",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.46833335817954447):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.46833335817954447):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_774",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.9652221247306123):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.9652221247306123):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_775",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.4285125642591321):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.4285125642591321):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_776",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.5227548113673135):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.5227548113673135):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_777",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.7886244069752041):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.7886244069752041):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_778",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.7402813699356279):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.7402813699356279):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_779",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.7572078427145723):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.7572078427145723):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_780",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.6887164737217526):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.6887164737217526):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_781",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.3304791079383641):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.3304791079383641):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_782",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.2200863506648265):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.2200863506648265):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_783",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.39365902708893785):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.39365902708893785):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_784",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.9244931080803096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.9244931080803096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_785",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.10402927399110251):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.10402927399110251):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_786",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.9234350054268022):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.9234350054268022):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_787",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.2872692232895371):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.2872692232895371):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_788",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.8715964978221419):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.8715964978221419):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_789",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.7386745038633576):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.7386745038633576):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_790",
    "sat": "def sat(p_stop: float, steps: int=26, target_prob: float=0.8337009369382651):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=26, target_prob=0.8337009369382651):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_791",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.903142816610807):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.903142816610807):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_792",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.5817056086175448):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.5817056086175448):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_793",
    "sat": "def sat(p_stop: float, steps: int=15, target_prob: float=0.6415952289603903):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=15, target_prob=0.6415952289603903):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_794",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.5695132934705848):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.5695132934705848):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_795",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.9383947057539906):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.9383947057539906):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_796",
    "sat": "def sat(p_stop: float, steps: int=47, target_prob: float=0.44714982456166663):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=47, target_prob=0.44714982456166663):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_797",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.7208035267612064):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.7208035267612064):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_798",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.5965520465365768):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.5965520465365768):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_799",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.15807231928045218):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.15807231928045218):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_800",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.22433670914766235):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.22433670914766235):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_801",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.7799579885922545):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.7799579885922545):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_802",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.7348760234713673):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.7348760234713673):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_803",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.4259286723433495):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.4259286723433495):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_804",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9928551950172325):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9928551950172325):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_805",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.12628541708147556):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.12628541708147556):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_806",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.8286671126096998):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.8286671126096998):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_807",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.738360208131694):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.738360208131694):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_808",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.7281461382697135):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.7281461382697135):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_809",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.5118141504906096):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.5118141504906096):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_810",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.06223581366336306):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.06223581366336306):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_811",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.8779002892853357):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.8779002892853357):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_812",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.2979037815065586):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.2979037815065586):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_813",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.22669813914858905):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.22669813914858905):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_814",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.8712258934682755):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.8712258934682755):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_815",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.7898967473598545):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.7898967473598545):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_816",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.49615478255806544):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.49615478255806544):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_817",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.40070993935245824):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.40070993935245824):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_818",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.6047407652431454):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.6047407652431454):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_819",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.773796091963577):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.773796091963577):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_820",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.6432667773828871):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.6432667773828871):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_821",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.5140426189190958):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.5140426189190958):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_822",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.8404579531936712):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.8404579531936712):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_823",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.5966668637005462):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.5966668637005462):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_824",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.30128164604227237):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.30128164604227237):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_825",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.6554307281582965):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.6554307281582965):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_826",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.7709211187959443):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.7709211187959443):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_827",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.8241209888386815):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.8241209888386815):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_828",
    "sat": "def sat(p_stop: float, steps: int=73, target_prob: float=0.7926407636516913):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=73, target_prob=0.7926407636516913):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_829",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.022475695294438824):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.022475695294438824):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_830",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.42596521551811406):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.42596521551811406):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_831",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.8470565202303437):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.8470565202303437):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_832",
    "sat": "def sat(p_stop: float, steps: int=97, target_prob: float=0.2534729811780435):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=97, target_prob=0.2534729811780435):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_833",
    "sat": "def sat(p_stop: float, steps: int=94, target_prob: float=0.4853924926624089):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=94, target_prob=0.4853924926624089):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_834",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.303269190206676):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.303269190206676):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_835",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.9383140825661431):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.9383140825661431):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_836",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.992412544758598):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.992412544758598):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_837",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.8678296113671135):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.8678296113671135):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_838",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.4936077156731322):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.4936077156731322):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_839",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.7524673270775424):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.7524673270775424):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_840",
    "sat": "def sat(p_stop: float, steps: int=74, target_prob: float=0.4897119647327509):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=74, target_prob=0.4897119647327509):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_841",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.45561740243040627):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.45561740243040627):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_842",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9562091834893395):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9562091834893395):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_843",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.4004761337607763):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.4004761337607763):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_844",
    "sat": "def sat(p_stop: float, steps: int=42, target_prob: float=0.7419470087478278):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=42, target_prob=0.7419470087478278):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_845",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.7443729600859922):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.7443729600859922):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_846",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.6693081690319388):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.6693081690319388):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_847",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.27494199164210065):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.27494199164210065):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_848",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.5096387350716431):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.5096387350716431):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_849",
    "sat": "def sat(p_stop: float, steps: int=38, target_prob: float=0.42273215612162585):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=38, target_prob=0.42273215612162585):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_850",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.9915290031554223):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.9915290031554223):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_851",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.8457153267758474):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.8457153267758474):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_852",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.8730955863480901):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.8730955863480901):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_853",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.1725170006380219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.1725170006380219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_854",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.011929873309249328):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.011929873309249328):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_855",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.29113582711327013):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.29113582711327013):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_856",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.9038492099104806):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.9038492099104806):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_857",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.5630455928353101):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.5630455928353101):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_858",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.9542483676546528):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.9542483676546528):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_859",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.48642085828250037):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.48642085828250037):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_860",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.6022390560804781):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.6022390560804781):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_861",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.47884660226409725):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.47884660226409725):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_862",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.7488086421072842):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.7488086421072842):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_863",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.3216318252869722):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.3216318252869722):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_864",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.23712752727409936):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.23712752727409936):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_865",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.7515117140013121):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.7515117140013121):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_866",
    "sat": "def sat(p_stop: float, steps: int=39, target_prob: float=0.4885212726849514):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=39, target_prob=0.4885212726849514):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_867",
    "sat": "def sat(p_stop: float, steps: int=44, target_prob: float=0.3609184848190652):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=44, target_prob=0.3609184848190652):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_868",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.27057585289766395):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.27057585289766395):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_869",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.3781060136700112):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.3781060136700112):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_870",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.24715559428196898):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.24715559428196898):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_871",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.4261807111702043):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.4261807111702043):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_872",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.7795786391679097):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.7795786391679097):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_873",
    "sat": "def sat(p_stop: float, steps: int=46, target_prob: float=0.1330688574285963):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=46, target_prob=0.1330688574285963):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_874",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.08254904160644438):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.08254904160644438):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_875",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.40577391710562727):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.40577391710562727):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_876",
    "sat": "def sat(p_stop: float, steps: int=20, target_prob: float=0.11682229925345189):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=20, target_prob=0.11682229925345189):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_877",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.8387627386396214):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.8387627386396214):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_878",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.7212273500077241):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.7212273500077241):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_879",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.8222529508224659):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.8222529508224659):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_880",
    "sat": "def sat(p_stop: float, steps: int=25, target_prob: float=0.029778504113547766):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=25, target_prob=0.029778504113547766):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_881",
    "sat": "def sat(p_stop: float, steps: int=81, target_prob: float=0.04591553838870266):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=81, target_prob=0.04591553838870266):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_882",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.9979401346012828):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.9979401346012828):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_883",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.9403338811984193):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.9403338811984193):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_884",
    "sat": "def sat(p_stop: float, steps: int=68, target_prob: float=0.8371030238482184):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=68, target_prob=0.8371030238482184):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_885",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.5587832917854714):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.5587832917854714):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_886",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.2703094077993716):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.2703094077993716):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_887",
    "sat": "def sat(p_stop: float, steps: int=49, target_prob: float=0.1047567470804942):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=49, target_prob=0.1047567470804942):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_888",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.7891023506035485):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.7891023506035485):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_889",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.41009803244599186):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.41009803244599186):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_890",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.8862093897258767):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.8862093897258767):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_891",
    "sat": "def sat(p_stop: float, steps: int=40, target_prob: float=0.43647621408549386):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=40, target_prob=0.43647621408549386):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_892",
    "sat": "def sat(p_stop: float, steps: int=18, target_prob: float=0.3759501385759896):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=18, target_prob=0.3759501385759896):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_893",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.32918418241960035):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.32918418241960035):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_894",
    "sat": "def sat(p_stop: float, steps: int=60, target_prob: float=0.28331933566938483):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=60, target_prob=0.28331933566938483):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_895",
    "sat": "def sat(p_stop: float, steps: int=4, target_prob: float=0.13304459710776595):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=4, target_prob=0.13304459710776595):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_896",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.3367079450850283):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.3367079450850283):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_897",
    "sat": "def sat(p_stop: float, steps: int=43, target_prob: float=0.3950561007981507):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=43, target_prob=0.3950561007981507):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_898",
    "sat": "def sat(p_stop: float, steps: int=87, target_prob: float=0.49392164872821387):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=87, target_prob=0.49392164872821387):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_899",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.3636363042621159):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.3636363042621159):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_900",
    "sat": "def sat(p_stop: float, steps: int=11, target_prob: float=0.331413279486225):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=11, target_prob=0.331413279486225):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_901",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.2991269934519044):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.2991269934519044):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_902",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.1755454021709787):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.1755454021709787):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_903",
    "sat": "def sat(p_stop: float, steps: int=41, target_prob: float=0.2543009316466439):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=41, target_prob=0.2543009316466439):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_904",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.5974844953229298):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.5974844953229298):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_905",
    "sat": "def sat(p_stop: float, steps: int=83, target_prob: float=0.10172530331676599):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=83, target_prob=0.10172530331676599):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_906",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.19089165938492159):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.19089165938492159):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_907",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.193242123487943):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.193242123487943):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_908",
    "sat": "def sat(p_stop: float, steps: int=36, target_prob: float=0.6185905329601881):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=36, target_prob=0.6185905329601881):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_909",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.1225716008997243):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.1225716008997243):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_910",
    "sat": "def sat(p_stop: float, steps: int=66, target_prob: float=0.17235109041587426):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=66, target_prob=0.17235109041587426):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_911",
    "sat": "def sat(p_stop: float, steps: int=45, target_prob: float=0.4186647674871362):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=45, target_prob=0.4186647674871362):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_912",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.9390587783485366):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.9390587783485366):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_913",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.35269954418959015):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.35269954418959015):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_914",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.6729941608773194):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.6729941608773194):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_915",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.08649381597686534):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.08649381597686534):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_916",
    "sat": "def sat(p_stop: float, steps: int=52, target_prob: float=0.12268945800391229):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=52, target_prob=0.12268945800391229):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_917",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.9635468421122915):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.9635468421122915):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_918",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.4970630244247931):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.4970630244247931):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_919",
    "sat": "def sat(p_stop: float, steps: int=69, target_prob: float=0.26884507889859954):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=69, target_prob=0.26884507889859954):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_920",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.8678017991966609):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.8678017991966609):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_921",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.37850760768934355):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.37850760768934355):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_922",
    "sat": "def sat(p_stop: float, steps: int=8, target_prob: float=0.22897803637403968):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=8, target_prob=0.22897803637403968):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_923",
    "sat": "def sat(p_stop: float, steps: int=51, target_prob: float=0.19905977381561046):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=51, target_prob=0.19905977381561046):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_924",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.4430996010964573):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.4430996010964573):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_925",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.44234798406856546):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.44234798406856546):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_926",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.67340238362056):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.67340238362056):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_927",
    "sat": "def sat(p_stop: float, steps: int=53, target_prob: float=0.9571334370983368):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=53, target_prob=0.9571334370983368):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_928",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.752450885228982):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.752450885228982):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_929",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.1203875676397248):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.1203875676397248):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_930",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.2666796939428798):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.2666796939428798):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_931",
    "sat": "def sat(p_stop: float, steps: int=93, target_prob: float=0.9495817482610733):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=93, target_prob=0.9495817482610733):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_932",
    "sat": "def sat(p_stop: float, steps: int=79, target_prob: float=0.6173028734675701):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=79, target_prob=0.6173028734675701):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_933",
    "sat": "def sat(p_stop: float, steps: int=72, target_prob: float=0.34248561730941973):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=72, target_prob=0.34248561730941973):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_934",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.5181098508897406):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.5181098508897406):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_935",
    "sat": "def sat(p_stop: float, steps: int=84, target_prob: float=0.12221330579682077):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=84, target_prob=0.12221330579682077):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_936",
    "sat": "def sat(p_stop: float, steps: int=80, target_prob: float=0.11918119867146026):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=80, target_prob=0.11918119867146026):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_937",
    "sat": "def sat(p_stop: float, steps: int=65, target_prob: float=0.05078909045259694):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=65, target_prob=0.05078909045259694):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_938",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.5412338522603882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.5412338522603882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_939",
    "sat": "def sat(p_stop: float, steps: int=14, target_prob: float=0.7055278667101622):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=14, target_prob=0.7055278667101622):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_940",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.4902481362662946):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.4902481362662946):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_941",
    "sat": "def sat(p_stop: float, steps: int=3, target_prob: float=0.21557888664389202):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=3, target_prob=0.21557888664389202):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_942",
    "sat": "def sat(p_stop: float, steps: int=98, target_prob: float=0.04475379857930706):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=98, target_prob=0.04475379857930706):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_943",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.4205826510887849):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.4205826510887849):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_944",
    "sat": "def sat(p_stop: float, steps: int=30, target_prob: float=0.35602455402139777):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=30, target_prob=0.35602455402139777):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_945",
    "sat": "def sat(p_stop: float, steps: int=95, target_prob: float=0.7018029839886001):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=95, target_prob=0.7018029839886001):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_946",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.2539531793540366):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.2539531793540366):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_947",
    "sat": "def sat(p_stop: float, steps: int=29, target_prob: float=0.030074279548167215):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=29, target_prob=0.030074279548167215):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_948",
    "sat": "def sat(p_stop: float, steps: int=67, target_prob: float=0.9943176871355986):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=67, target_prob=0.9943176871355986):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_949",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.6700475456656512):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.6700475456656512):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_950",
    "sat": "def sat(p_stop: float, steps: int=21, target_prob: float=0.3321364570141322):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=21, target_prob=0.3321364570141322):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_951",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.3652696238622779):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.3652696238622779):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_952",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.47628455401927083):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.47628455401927083):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_953",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.9986074658859319):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.9986074658859319):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_954",
    "sat": "def sat(p_stop: float, steps: int=89, target_prob: float=0.719703988377798):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=89, target_prob=0.719703988377798):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_955",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.6898653829235193):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.6898653829235193):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_956",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.8680914475880154):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.8680914475880154):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_957",
    "sat": "def sat(p_stop: float, steps: int=56, target_prob: float=0.681796020740074):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=56, target_prob=0.681796020740074):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_958",
    "sat": "def sat(p_stop: float, steps: int=85, target_prob: float=0.4081061366369032):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=85, target_prob=0.4081061366369032):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_959",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.33367953098933023):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.33367953098933023):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_960",
    "sat": "def sat(p_stop: float, steps: int=24, target_prob: float=0.20891559126660542):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=24, target_prob=0.20891559126660542):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_961",
    "sat": "def sat(p_stop: float, steps: int=50, target_prob: float=0.09882998157606515):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=50, target_prob=0.09882998157606515):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_962",
    "sat": "def sat(p_stop: float, steps: int=58, target_prob: float=0.24821401831463963):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=58, target_prob=0.24821401831463963):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_963",
    "sat": "def sat(p_stop: float, steps: int=12, target_prob: float=0.8347254931285593):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=12, target_prob=0.8347254931285593):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_964",
    "sat": "def sat(p_stop: float, steps: int=76, target_prob: float=0.9593207252554071):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=76, target_prob=0.9593207252554071):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_965",
    "sat": "def sat(p_stop: float, steps: int=17, target_prob: float=0.8870067362687882):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=17, target_prob=0.8870067362687882):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_966",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.8204094828257644):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.8204094828257644):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_967",
    "sat": "def sat(p_stop: float, steps: int=77, target_prob: float=0.6480669460314099):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=77, target_prob=0.6480669460314099):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_968",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.39129409341078014):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.39129409341078014):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_969",
    "sat": "def sat(p_stop: float, steps: int=31, target_prob: float=0.6293721246120327):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=31, target_prob=0.6293721246120327):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_970",
    "sat": "def sat(p_stop: float, steps: int=13, target_prob: float=0.6025884141269198):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=13, target_prob=0.6025884141269198):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_971",
    "sat": "def sat(p_stop: float, steps: int=62, target_prob: float=0.08795224250687095):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=62, target_prob=0.08795224250687095):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_972",
    "sat": "def sat(p_stop: float, steps: int=92, target_prob: float=0.9115953469239791):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=92, target_prob=0.9115953469239791):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_973",
    "sat": "def sat(p_stop: float, steps: int=34, target_prob: float=0.7607667815779839):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=34, target_prob=0.7607667815779839):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_974",
    "sat": "def sat(p_stop: float, steps: int=90, target_prob: float=0.5219720837711219):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=90, target_prob=0.5219720837711219):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_975",
    "sat": "def sat(p_stop: float, steps: int=6, target_prob: float=0.7440020046198372):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=6, target_prob=0.7440020046198372):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_976",
    "sat": "def sat(p_stop: float, steps: int=33, target_prob: float=0.24895822094057207):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=33, target_prob=0.24895822094057207):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_977",
    "sat": "def sat(p_stop: float, steps: int=1, target_prob: float=0.9104275098960835):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=1, target_prob=0.9104275098960835):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_978",
    "sat": "def sat(p_stop: float, steps: int=91, target_prob: float=0.9022278625453106):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=91, target_prob=0.9022278625453106):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_979",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.24595464418886337):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.24595464418886337):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_980",
    "sat": "def sat(p_stop: float, steps: int=99, target_prob: float=0.903997912099866):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=99, target_prob=0.903997912099866):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_981",
    "sat": "def sat(p_stop: float, steps: int=54, target_prob: float=0.9569988618398281):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=54, target_prob=0.9569988618398281):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_982",
    "sat": "def sat(p_stop: float, steps: int=37, target_prob: float=0.08932483826242132):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=37, target_prob=0.08932483826242132):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_983",
    "sat": "def sat(p_stop: float, steps: int=88, target_prob: float=0.6585245397652983):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=88, target_prob=0.6585245397652983):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_984",
    "sat": "def sat(p_stop: float, steps: int=55, target_prob: float=0.4950147001233758):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=55, target_prob=0.4950147001233758):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_985",
    "sat": "def sat(p_stop: float, steps: int=9, target_prob: float=0.3228328908122705):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=9, target_prob=0.3228328908122705):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_986",
    "sat": "def sat(p_stop: float, steps: int=35, target_prob: float=0.8431326448243001):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=35, target_prob=0.8431326448243001):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_987",
    "sat": "def sat(p_stop: float, steps: int=28, target_prob: float=0.03266501044490633):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=28, target_prob=0.03266501044490633):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_988",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.093948399228448):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.093948399228448):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_989",
    "sat": "def sat(p_stop: float, steps: int=57, target_prob: float=0.17809867229540788):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=57, target_prob=0.17809867229540788):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_990",
    "sat": "def sat(p_stop: float, steps: int=22, target_prob: float=0.27316444961697106):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=22, target_prob=0.27316444961697106):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_991",
    "sat": "def sat(p_stop: float, steps: int=23, target_prob: float=0.9180858859421367):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=23, target_prob=0.9180858859421367):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_992",
    "sat": "def sat(p_stop: float, steps: int=64, target_prob: float=0.22867002569864114):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=64, target_prob=0.22867002569864114):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_993",
    "sat": "def sat(p_stop: float, steps: int=59, target_prob: float=0.14674565941569806):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=59, target_prob=0.14674565941569806):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_994",
    "sat": "def sat(p_stop: float, steps: int=78, target_prob: float=0.05560600180072728):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=78, target_prob=0.05560600180072728):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_995",
    "sat": "def sat(p_stop: float, steps: int=71, target_prob: float=0.5059480629328211):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=71, target_prob=0.5059480629328211):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_996",
    "sat": "def sat(p_stop: float, steps: int=63, target_prob: float=0.5681002660610588):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=63, target_prob=0.5681002660610588):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_997",
    "sat": "def sat(p_stop: float, steps: int=82, target_prob: float=0.3296350725333739):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=82, target_prob=0.3296350725333739):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_998",
    "sat": "def sat(p_stop: float, steps: int=2, target_prob: float=0.5414386513854295):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=2, target_prob=0.5414386513854295):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  },
  {
    "name": "ExponentialProbability_999",
    "sat": "def sat(p_stop: float, steps: int=48, target_prob: float=0.1694013118092177):\n    assert type(p_stop) is float, 'p_stop must be of type float'\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "sols": [
      "def sol(steps=48, target_prob=0.1694013118092177):\n    return 1 - (1 - target_prob) ** (1.0/steps)"
    ]
  }
]