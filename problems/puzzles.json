[
  {
    "name": "TowersOfHanoi_0",
    "sat": "def sat(moves: List[List[int]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])\n    for [i, j] in moves:\n        rods[j].append(rods[i].pop())\n        assert rods[j][-1] == min(rods[j]), \"larger disk on top of smaller disk\"\n    return rods[0] == rods[1] == []",
    "sols": [
      "def sol():\n    def helper(m, i, j):\n        if m == 0:\n            return []\n        k = 3 - i - j\n        return helper(m - 1, i, k) + [[i, j]] + helper(m - 1, k, j)\n\n    return helper(8, 0, 2)"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_0",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target: List[List[int]]=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_1",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[0, 5], [3], [1, 2, 4, 6]], target: List[List[int]]=[[4], [0, 1, 2, 3, 5], [6]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0, 5], [3], [1, 2, 4, 6]], target=[[4], [0, 1, 2, 3, 5], [6]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_2",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[0], [3], [1, 2, 4, 5]], target: List[List[int]]=[[1, 2], [0, 4, 5], [3]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[0], [3], [1, 2, 4, 5]], target=[[1, 2], [0, 4, 5], [3]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_3",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[3, 5, 6], [1, 4], [0, 2]], target: List[List[int]]=[[1, 2, 3, 5], [4, 6], [0]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[3, 5, 6], [1, 4], [0, 2]], target=[[1, 2, 3, 5], [4, 6], [0]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_4",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[1, 2], [], [0, 3]], target: List[List[int]]=[[], [0, 1], [2, 3]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[1, 2], [], [0, 3]], target=[[], [0, 1], [2, 3]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_5",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[2, 3], [1], [0]], target: List[List[int]]=[[1, 3], [2], [0]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[2, 3], [1], [0]], target=[[1, 3], [2], [0]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_6",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[1, 2, 4], [3], [0]], target: List[List[int]]=[[0, 1, 2], [], [3, 4]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[1, 2, 4], [3], [0]], target=[[0, 1, 2], [], [3, 4]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_7",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[6, 7, 9], [0, 1, 4, 8, 14], [2, 3, 5, 10, 11, 12, 13, 15]], target: List[List[int]]=[[6, 9, 10, 11, 12], [0, 1, 3, 4, 5], [2, 7, 8, 13, 14, 15]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[6, 7, 9], [0, 1, 4, 8, 14], [2, 3, 5, 10, 11, 12, 13, 15]], target=[[6, 9, 10, 11, 12], [0, 1, 3, 4, 5], [2, 7, 8, 13, 14, 15]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_8",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[4, 5, 9, 10, 11], [0, 2, 3], [1, 6, 7, 8]], target: List[List[int]]=[[0, 2, 3, 5, 6, 9, 10, 11], [7, 8], [1, 4]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[4, 5, 9, 10, 11], [0, 2, 3], [1, 6, 7, 8]], target=[[0, 2, 3, 5, 6, 9, 10, 11], [7, 8], [1, 4]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "TowersOfHanoiArbitrary_9",
    "sat": "def sat(moves: List[List[int]], source: List[List[int]]=[[2, 4], [1, 3], [0]], target: List[List[int]]=[[0], [1, 4], [2, 3]]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "sols": [
      "def sol(source=[[2, 4], [1, 3], [0]], target=[[0], [1, 4], [2, 3]]):\n    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ]
  },
  {
    "name": "Quine_0",
    "sat": "def sat(quine: str):\n    assert type(quine) is str, 'quine must be of type str'\n    return eval(quine) == quine",
    "sols": [
      "def sol():\n    return \"(lambda x: f'({x})({chr(34)}{x}{chr(34)})')(\\\"lambda x: f'({x})({chr(34)}{x}{chr(34)})'\\\")\""
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_0",
    "sat": "def sat(colors: List[int], n: int=100):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=100):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_1",
    "sat": "def sat(colors: List[int], n: int=7824):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": []
  },
  {
    "name": "BooleanPythagoreanTriples_2",
    "sat": "def sat(colors: List[int], n: int=0):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=0):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_3",
    "sat": "def sat(colors: List[int], n: int=1):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=1):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_4",
    "sat": "def sat(colors: List[int], n: int=2):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=2):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_5",
    "sat": "def sat(colors: List[int], n: int=3):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=3):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_6",
    "sat": "def sat(colors: List[int], n: int=4):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=4):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_7",
    "sat": "def sat(colors: List[int], n: int=5):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=5):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_8",
    "sat": "def sat(colors: List[int], n: int=6):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=6):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "BooleanPythagoreanTriples_9",
    "sat": "def sat(colors: List[int], n: int=7):\n    assert type(colors) is list and all(type(a) is int for a in colors), 'colors must be of type List[int]'  # list of 0/1 colors of length >= n\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "sols": [
      "def sol(n=7):\n    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ]
  },
  {
    "name": "ClockAngle_0",
    "sat": "def sat(hands: List[int], target_angle: int=45):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=45):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_1",
    "sat": "def sat(hands: List[int], target_angle: int=30):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=30):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_2",
    "sat": "def sat(hands: List[int], target_angle: int=19):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=19):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_3",
    "sat": "def sat(hands: List[int], target_angle: int=8):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=8):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_4",
    "sat": "def sat(hands: List[int], target_angle: int=357):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=357):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_5",
    "sat": "def sat(hands: List[int], target_angle: int=346):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=346):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_6",
    "sat": "def sat(hands: List[int], target_angle: int=335):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=335):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_7",
    "sat": "def sat(hands: List[int], target_angle: int=324):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=324):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_8",
    "sat": "def sat(hands: List[int], target_angle: int=313):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=313):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "ClockAngle_9",
    "sat": "def sat(hands: List[int], target_angle: int=302):\n    assert type(hands) is list and all(type(a) is int for a in hands), 'hands must be of type List[int]'\n    hour, min = hands\n    return hour in range(1, 13) and min in range(60) and ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle",
    "sols": [
      "def sol(target_angle=302):\n    for hour in range(1, 13):\n        for min in range(60):\n            if ((60 * hour + min) - 12 * min) % 720 == 2 * target_angle:\n                return [hour, min]"
    ]
  },
  {
    "name": "Kirkman_0",
    "sat": "def sat(daygroups: List[List[List[int]]]):\n    assert type(daygroups) is list and all(type(a) is list and all(type(b) is list and all(type(c) is int for c in b) for b in a) for a in daygroups), 'daygroups must be of type List[List[List[int]]]'\n    assert len(daygroups) == 7\n    assert all(len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups)\n    assert all(len(g) == 3 for groups in daygroups for g in groups)\n    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15",
    "sols": [
      "def sol():\n    from itertools import combinations\n    import random\n    rand = random.Random(0)\n    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv\n    counts = {(i, j): (7 if j in range(k, k + 3) else 0)\n              for k in range(0, 15, 3)\n              for i in range(k, k + 3)\n              for j in range(15) if j != i\n              }\n\n    todos = [pair for pair, count in counts.items() if count == 0]\n    while True:\n        pair = rand.choice(todos)  # choose i and j to make next to each other on some day\n        if rand.randrange(2):\n            pair = pair[::-1]\n\n        a, u = pair\n        pi, inv = rand.choice(days)\n        assert pi[inv[a]] == a and pi[inv[u]] == u\n        bases = [3 * (inv[i] // 3) for i in pair]\n        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]\n        if rand.randrange(2):\n            b, c, = c, b\n        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)\n\n        new_pairs = [(a, u), (c, u), (b, v), (b, w)]\n        old_pairs = [(u, v), (u, w), (b, a), (b, c)]\n        gained = sum(counts[p] == 0 for p in new_pairs)\n        lost = sum(counts[p] == 1 for p in old_pairs)\n        if rand.random() <= 100 ** (gained - lost):\n            for p in new_pairs:\n                counts[p] += 1\n                counts[p[::-1]] += 1\n            for p in old_pairs:\n                counts[p] -= 1\n                counts[p[::-1]] -= 1\n            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]\n            todos = [pair for pair, count in counts.items() if count == 0]\n            if len(todos) == 0:\n                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]"
    ]
  },
  {
    "name": "MonkeyAndCoconuts_0",
    "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1",
    "sols": [
      "def sol():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5"
    ]
  },
  {
    "name": "No3Colinear_0",
    "sat": "def sat(coords: List[List[int]], side: int=5, num_points: int=10):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=5, num_points=10):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_1",
    "sat": "def sat(coords: List[List[int]], side: int=0, num_points: int=0):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=0, num_points=0):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_2",
    "sat": "def sat(coords: List[List[int]], side: int=1, num_points: int=1):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=1, num_points=1):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_3",
    "sat": "def sat(coords: List[List[int]], side: int=2, num_points: int=4):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=2, num_points=4):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_4",
    "sat": "def sat(coords: List[List[int]], side: int=3, num_points: int=6):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=3, num_points=6):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_5",
    "sat": "def sat(coords: List[List[int]], side: int=4, num_points: int=8):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": [
      "def sol(side=4, num_points=8):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ]
  },
  {
    "name": "No3Colinear_6",
    "sat": "def sat(coords: List[List[int]], side: int=6, num_points: int=12):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": []
  },
  {
    "name": "No3Colinear_7",
    "sat": "def sat(coords: List[List[int]], side: int=7, num_points: int=14):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": []
  },
  {
    "name": "No3Colinear_8",
    "sat": "def sat(coords: List[List[int]], side: int=8, num_points: int=16):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": []
  },
  {
    "name": "No3Colinear_9",
    "sat": "def sat(coords: List[List[int]], side: int=9, num_points: int=18):\n    assert type(coords) is list and all(type(a) is list and all(type(b) is int for b in a) for a in coords), 'coords must be of type List[List[int]]'\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "sols": []
  },
  {
    "name": "PostageStamp_0",
    "sat": "def sat(stamps: List[int], target: int=80, max_stamps: int=4, options: List[int]=[10, 32, 8]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=80, max_stamps=4, options=[10, 32, 8]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_1",
    "sat": "def sat(stamps: List[int], target: int=69, max_stamps: int=3, options: List[int]=[23, 69, 69, 75, 15, 87, 37, 9]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=69, max_stamps=3, options=[23, 69, 69, 75, 15, 87, 37, 9]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_2",
    "sat": "def sat(stamps: List[int], target: int=65, max_stamps: int=3, options: List[int]=[1, 98, 50, 16, 32]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=65, max_stamps=3, options=[1, 98, 50, 16, 32]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_3",
    "sat": "def sat(stamps: List[int], target: int=499, max_stamps: int=8, options: List[int]=[46, 94, 39, 67, 82, 60, 11, 74]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=499, max_stamps=8, options=[46, 94, 39, 67, 82, 60, 11, 74]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_4",
    "sat": "def sat(stamps: List[int], target: int=35, max_stamps: int=5, options: List[int]=[35]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=35, max_stamps=5, options=[35]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_5",
    "sat": "def sat(stamps: List[int], target: int=109, max_stamps: int=2, options: List[int]=[26, 53, 83]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=109, max_stamps=2, options=[26, 53, 83]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_6",
    "sat": "def sat(stamps: List[int], target: int=110, max_stamps: int=2, options: List[int]=[55]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=110, max_stamps=2, options=[55]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_7",
    "sat": "def sat(stamps: List[int], target: int=115, max_stamps: int=4, options: List[int]=[55, 98, 76, 38, 78, 80, 17]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=115, max_stamps=4, options=[55, 98, 76, 38, 78, 80, 17]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_8",
    "sat": "def sat(stamps: List[int], target: int=78, max_stamps: int=8, options: List[int]=[13]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=78, max_stamps=8, options=[13]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "PostageStamp_9",
    "sat": "def sat(stamps: List[int], target: int=28, max_stamps: int=1, options: List[int]=[40, 44, 25, 28, 97, 45, 51]):\n    assert type(stamps) is list and all(type(a) is int for a in stamps), 'stamps must be of type List[int]'\n    return set(stamps) <= set(options) and len(stamps) <= max_stamps and sum(stamps) == target",
    "sols": [
      "def sol(target=28, max_stamps=1, options=[40, 44, 25, 28, 97, 45, 51]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ]
  },
  {
    "name": "SquaringTheSquare_0",
    "sat": "def sat(xy_sides: List[List[int]]):\n    assert type(xy_sides) is list and all(type(a) is list and all(type(b) is int for b in a) for a in xy_sides), 'xy_sides must be of type List[List[int]]'  # List of (x, y, side)\n    n = max(x + side for x, y, side in xy_sides)\n    assert len({side for x, y, side in xy_sides}) == len(xy_sides) > 1\n    for x, y, s in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for x2, y2, s2 in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or y2 >= y + s or y2 + s2 <= y\n\n    return sum(side ** 2 for x, y, side in xy_sides) == n ** 2",
    "sols": [
      "def sol():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]"
    ]
  },
  {
    "name": "NecklaceSplit_0",
    "sat": "def sat(n: int, lace: str=\"rrbbbbrrbrbrbbrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rrbbbbrrbrbrbbrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_1",
    "sat": "def sat(n: int, lace: str=\"bbbbrrrbbrrrrbbrbrbbrrbr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbbbrrrbbrrrrbbrbrbbrrbr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_2",
    "sat": "def sat(n: int, lace: str=\"bbbrbbrrbrbrbrrbbbbrrbbrrbrrrbbbbrbbrbrbbrrrbbbbrrrrrbrbbbrrbbbbrbrrrbbbrbrrbbbrrbrbbbbbrrbbbrbbrbrrbrbrrbbbbbbbrrrbbrrbbrrrbbrbbrbrrbrbrbrbrbbrrbrbrbrrrrrbrbrrrrbbrbrbrrrbbbbbbbbbrbrrbrrrrrbbbbbrbbbbbbbbbrrrrrrbbrrbrbbbrrbrbbrbbrrrrrrrbbbrbrrbbbrrbrrbrrrbbbbbrrbrrrbbbrbbrbbrrbbbrbrbrrbbrbrbrrrbrrbrbbrbbrrrbbbrbbrrbbbbrbbbrbbrrbrrbbrbrrbrbrrbrrbrrrrrrbbrrbbbrrbrrrbrrbbbrbrbbbrbrbbbbbbrbrbrbrbrbbbrrrbbrbrbrbbbbbbrbrbrrrbbrrbbrrbrbrrbrbbbbrrrrrrbrrrbrrbrrrbrrbrbbbbbrbbbrbbrrrrbrbrrrbbrbbbbbrbbrrbrbrrrbbrrbrrrbbbrrrbrrbrrbrrrbrbrbrrbrrrbrrrrrrrbrbrbrrrbbbrbrbrrbrbrbrbbrrbbrrrbrbbbbbrrbrbrrbrrbbbrbrrrbrrrrrrrrbbrrrbrbrrbrrbbrbrrbrrbbrbrbrbbrrrrbrrrrrbbbrbrrrbbbbbbbbrbrbrbrrbrbrbbrrbbrbrrrrbbrrbbrbbbbbrbbbbbbbbrrrrbbrrrrrrrrbbrrbbrbbbbbbbrbbbrbbrbbrbrbbrbrrbrbbbbrrrrrrbrrbrbrbbrrbrbrrrrrbbrrrrrbbbbrrbbbrbbrbrbrbrbbrbrbrrbbrbrrbrrbrrbrbbrbrrrbrrbbrbbbbbbrrbrbrbbbrrbbbrrbbrbbbbbrrbrbrbbrrrbrrrrbbbrrbrbbbbrbrrbbbrbbbbrbrbbrrbbbrrrrrbbbrrrbrbbbbrrbrrrrrrrrrbrbrrbrbbrrrbbrbrbbrrrbbrbbbrbrbrrbbrbbrrbbrbbrrbbbbrbrrbbrrrbbbrbrbbbrbrrrbrrrrbbrrbrbrrrbrrrbbrrbbrrbrrbrrbrrbbbbrbrrbrbrbrbrrbrrrrrbbbbbbrbbbbbbrrbbrbbrbbrbrbrrbrrrrrrbrbbrrbbrrrbbbbrrrrbrrbrbrrbbrrrrrbbrbbrrrrbrbrbrrrbbbbrbrrrbrbrrbbbrrrrrrbbbbbrbrbrbrrrbbbrrrrbbbrrbrbrrbbrrbrbbrbrbrrbbbbrrrrrrrbrbrbbbrrrrbbbrbrrbbbbbbbbbrbbrbrbrbbrrbrrrrrrbrrbbbbrbbrrbbrrrbrrrrbrrbrbbbbbbbrbbrbbbrrbrrbrrrrbrbbbbrbrbbrbrrbbrrbrbrbrrrbrbrrbrbbbbrrrbrrbbbbbbrbrbrbbrrbbbrbbrbbrrbbbrrrbbbbbbrrrrbbbrrbbrbrbbbrrrrrrbrbrbrbrrbrrbbrbbrrrbbrbbrrbrbbbrrrrrrbrrbbbrbrrbrrbbbrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbbrbbrrbrbrbrrbbbbrrbbrrbrrrbbbbrbbrbrbbrrrbbbbrrrrrbrbbbrrbbbbrbrrrbbbrbrrbbbrrbrbbbbbrrbbbrbbrbrrbrbrrbbbbbbbrrrbbrrbbrrrbbrbbrbrrbrbrbrbrbbrrbrbrbrrrrrbrbrrrrbbrbrbrrrbbbbbbbbbrbrrbrrrrrbbbbbrbbbbbbbbbrrrrrrbbrrbrbbbrrbrbbrbbrrrrrrrbbbrbrrbbbrrbrrbrrrbbbbbrrbrrrbbbrbbrbbrrbbbrbrbrrbbrbrbrrrbrrbrbbrbbrrrbbbrbbrrbbbbrbbbrbbrrbrrbbrbrrbrbrrbrrbrrrrrrbbrrbbbrrbrrrbrrbbbrbrbbbrbrbbbbbbrbrbrbrbrbbbrrrbbrbrbrbbbbbbrbrbrrrbbrrbbrrbrbrrbrbbbbrrrrrrbrrrbrrbrrrbrrbrbbbbbrbbbrbbrrrrbrbrrrbbrbbbbbrbbrrbrbrrrbbrrbrrrbbbrrrbrrbrrbrrrbrbrbrrbrrrbrrrrrrrbrbrbrrrbbbrbrbrrbrbrbrbbrrbbrrrbrbbbbbrrbrbrrbrrbbbrbrrrbrrrrrrrrbbrrrbrbrrbrrbbrbrrbrrbbrbrbrbbrrrrbrrrrrbbbrbrrrbbbbbbbbrbrbrbrrbrbrbbrrbbrbrrrrbbrrbbrbbbbbrbbbbbbbbrrrrbbrrrrrrrrbbrrbbrbbbbbbbrbbbrbbrbbrbrbbrbrrbrbbbbrrrrrrbrrbrbrbbrrbrbrrrrrbbrrrrrbbbbrrbbbrbbrbrbrbrbbrbrbrrbbrbrrbrrbrrbrbbrbrrrbrrbbrbbbbbbrrbrbrbbbrrbbbrrbbrbbbbbrrbrbrbbrrrbrrrrbbbrrbrbbbbrbrrbbbrbbbbrbrbbrrbbbrrrrrbbbrrrbrbbbbrrbrrrrrrrrrbrbrrbrbbrrrbbrbrbbrrrbbrbbbrbrbrrbbrbbrrbbrbbrrbbbbrbrrbbrrrbbbrbrbbbrbrrrbrrrrbbrrbrbrrrbrrrbbrrbbrrbrrbrrbrrbbbbrbrrbrbrbrbrrbrrrrrbbbbbbrbbbbbbrrbbrbbrbbrbrbrrbrrrrrrbrbbrrbbrrrbbbbrrrrbrrbrbrrbbrrrrrbbrbbrrrrbrbrbrrrbbbbrbrrrbrbrrbbbrrrrrrbbbbbrbrbrbrrrbbbrrrrbbbrrbrbrrbbrrbrbbrbrbrrbbbbrrrrrrrbrbrbbbrrrrbbbrbrrbbbbbbbbbrbbrbrbrbbrrbrrrrrrbrrbbbbrbbrrbbrrrbrrrrbrrbrbbbbbbbrbbrbbbrrbrrbrrrrbrbbbbrbrbbrbrrbbrrbrbrbrrrbrbrrbrbbbbrrrbrrbbbbbbrbrbrbbrrbbbrbbrbbrrbbbrrrbbbbbbrrrrbbbrrbbrbrbbbrrrrrrbrbrbrbrrbrrbbrbbrrrbbrbbrrbrbbbrrrrrrbrrbbbrbrrbrrbbbrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_3",
    "sat": "def sat(n: int, lace: str=\"rbrbbrrbbbrrrbrrrrbrrbrbrbbbbbbrbbbbbbbbrrrbbrbrbrrbbrbbbbbrbbrrrbbrbrrbrbbbbrbrrrrbbrbrrrrbbbrrrbrrrrbrbbrrrrrbbrbbrbbrrbbbbrbbbbbrbrrbbrbrrrbrbbrrbrbrrrbbrbrbrrbbrbrrrbrbrrbrbrbbrbbrrrbrbbrrrbrbbbrbrrbrrrrbrbrbrbbrrbbbbrrrbrbrrrrbbrrrbbbrbrrbrbbrrrbrbrbbrbrrbrbb\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbrbbrrbbbrrrbrrrrbrrbrbrbbbbbbrbbbbbbbbrrrbbrbrbrrbbrbbbbbrbbrrrbbrbrrbrbbbbrbrrrrbbrbrrrrbbbrrrbrrrrbrbbrrrrrbbrbbrbbrrbbbbrbbbbbrbrrbbrbrrrbrbbrrbrbrrrbbrbrbrrbbrbrrrbrbrrbrbrbbrbbrrrbrbbrrrbrbbbrbrrbrrrrbrbrbrbbrrbbbbrrrbrbrrrrbbrrrbbbrbrrbrbbrrrbrbrbbrbrrbrbb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_4",
    "sat": "def sat(n: int, lace: str=\"brrbrrbbrbrbbbrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"brrbrrbbrbrbbbrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_5",
    "sat": "def sat(n: int, lace: str=\"rbbbrrbbrrbrbbbbbbbbbbrbrbrbbrrbrrbbrbrrrbbrrrbbrbbbrrbrbbrbrbbrbrrbbrrrbbrrrbrrrbbrrbbrbrrrbbbrbbbbrrbrrbrrrbbrbrbbbrbrrrrrbrbrbbrbbrrbrbrrbrbbbbrbrrbbbrrrrrrrrbrbbrrbbbbbrrrrbrrbbrrbrbrbbrbrrrrbrbbrrrrbbrbrbrbb\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbbbrrbbrrbrbbbbbbbbbbrbrbrbbrrbrrbbrbrrrbbrrrbbrbbbrrbrbbrbrbbrbrrbbrrrbbrrrbrrrbbrrbbrbrrrbbbrbbbbrrbrrbrrrbbrbrbbbrbrrrrrbrbrbbrbbrrbrbrrbrbbbbrbrrbbbrrrrrrrrbrbbrrbbbbbrrrrbrrbbrrbrbrbbrbrrrrbrbbrrrrbbrbrbrbb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_6",
    "sat": "def sat(n: int, lace: str=\"rrbrrbbbrrbrbbbrbbbrrbbbbrrrrrrrbrbbrrrrrrrbrbrrrrbrrbbbbbrbbrbrbbbbbbbrbbrbbbrrrbrbrbrrrrbrbbbr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rrbrrbbbrrbrbbbrbbbrrbbbbrrrrrrrbrbbrrrrrrrbrbrrrrbrrbbbbbrbbrbrbbbbbbbrbbrbbbrrrbrbrbrrrrbrbbbr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_7",
    "sat": "def sat(n: int, lace: str=\"bbbbrrrr\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"bbbbrrrr\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_8",
    "sat": "def sat(n: int, lace: str=\"rbrbbbrrrrbbrbbbbrrrbrbbrbrrrbrrbbrrbrrrbbrrbbbrrbrbbrrbrbbrrbbrbrbbbrrb\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rbrbbbrrrrbbrbbbbrrrbrbbrbrrrbrrbbrrbrrrbbrrbbbrrbrbbrrbrbbrrbbrbrbbbrrb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "NecklaceSplit_9",
    "sat": "def sat(n: int, lace: str=\"rrrbrrbrbbrrbrbrbbrbbrbb\"):\n    assert type(n) is int, 'n must be of type int'\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "sols": [
      "def sol(lace=\"rrrbrrbrbbrrbrbrbbrbbrbb\"):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ]
  },
  {
    "name": "PandigitalSquare_0",
    "sat": "def sat(n: int):\n    assert type(n) is int, 'n must be of type int'\n    return sorted([int(s) for s in str(n * n)]) == list(range(10))",
    "sols": [
      "def sol():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n"
    ]
  },
  {
    "name": "AllPandigitalSquares_0",
    "sat": "def sat(nums: List[int]):\n    assert type(nums) is list and all(type(a) is int for a in nums), 'nums must be of type List[int]'\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174",
    "sols": [
      "def sol():\n    return [i for i in range(-10 ** 5, 10 ** 5) if sorted([int(s) for s in str(i * i)]) == list(range(10))]"
    ]
  },
  {
    "name": "CardGame24_0",
    "sat": "def sat(expr: str, nums: List[int]=[3, 7, 3, 7]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[3, 7, 3, 7]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_1",
    "sat": "def sat(expr: str, nums: List[int]=[12, 10, 2, 9]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[12, 10, 2, 9]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_2",
    "sat": "def sat(expr: str, nums: List[int]=[5, 12, 8, 11]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[5, 12, 8, 11]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_3",
    "sat": "def sat(expr: str, nums: List[int]=[1, 4, 3, 12]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[1, 4, 3, 12]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_4",
    "sat": "def sat(expr: str, nums: List[int]=[2, 4, 5, 10]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[2, 4, 5, 10]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_5",
    "sat": "def sat(expr: str, nums: List[int]=[3, 12, 11, 9]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[3, 12, 11, 9]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_6",
    "sat": "def sat(expr: str, nums: List[int]=[1, 1, 4, 6]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[1, 1, 4, 6]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_7",
    "sat": "def sat(expr: str, nums: List[int]=[5, 11, 5, 10]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[5, 11, 5, 10]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_8",
    "sat": "def sat(expr: str, nums: List[int]=[4, 4, 5, 6]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[4, 4, 5, 6]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "CardGame24_9",
    "sat": "def sat(expr: str, nums: List[int]=[6, 5, 5, 8]):\n    assert type(expr) is str, 'expr must be of type str'\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "sols": [
      "def sol(nums=[6, 5, 5, 8]):\n    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ]
  },
  {
    "name": "Easy63_0",
    "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 2 and s.count(\"1\") == 1 and eval(s) == 63",
    "sols": [
      "def sol():\n    return \"8*8-1\""
    ]
  },
  {
    "name": "Harder63_0",
    "sat": "def sat(s: str):\n    assert type(s) is str, 's must be of type str'\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 3 and s.count(\"1\") == 1 and eval(s) == 63",
    "sols": [
      "def sol():\n    return \"8*8-1**8\""
    ]
  },
  {
    "name": "WaterPouring_0",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[8, 5, 3], init: List[int]=[8, 0, 0], goal: List[int]=[4, 4, 0]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_1",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[640, 355, 499], init: List[int]=[135, 56, 164], goal: List[int]=[191, 0, 164]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[640, 355, 499], init=[135, 56, 164], goal=[191, 0, 164]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_2",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[501, 45, 839], init: List[int]=[76, 7, 381], goal: List[int]=[239, 0, 225]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[501, 45, 839], init=[76, 7, 381], goal=[239, 0, 225]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_3",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[796, 282, 991], init: List[int]=[63, 211, 48], goal: List[int]=[0, 282, 40]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[796, 282, 991], init=[63, 211, 48], goal=[0, 282, 40]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_4",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[558, 835, 383], init: List[int]=[35, 61, 378], goal: List[int]=[383, 91, 0]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[558, 835, 383], init=[35, 61, 378], goal=[383, 91, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_5",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[968, 367, 53], init: List[int]=[660, 267, 49], goal: List[int]=[877, 46, 53]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[968, 367, 53], init=[660, 267, 49], goal=[877, 46, 53]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_6",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[763, 415, 102], init: List[int]=[94, 291, 66], goal: List[int]=[168, 283, 0]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[763, 415, 102], init=[94, 291, 66], goal=[168, 283, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_7",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[953, 694, 40], init: List[int]=[188, 134, 34], goal: List[int]=[168, 148, 40]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[953, 694, 40], init=[188, 134, 34], goal=[168, 148, 40]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_8",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[435, 783, 273], init: List[int]=[241, 154, 258], goal: List[int]=[0, 640, 13]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[435, 783, 273], init=[241, 154, 258], goal=[0, 640, 13]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "WaterPouring_9",
    "sat": "def sat(moves: List[List[int]], capacities: List[int]=[580, 99, 753], init: List[int]=[470, 9, 418], goal: List[int]=[193, 99, 605]):\n    assert type(moves) is list and all(type(a) is list and all(type(b) is int for b in a) for a in moves), 'moves must be of type List[List[int]]'  # moves is list of [from, to] pairs\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "sols": [
      "def sol(capacities=[580, 99, 753], init=[470, 9, 418], goal=[193, 99, 605]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ]
  },
  {
    "name": "VerbalArithmetic_0",
    "sat": "def sat(li: List[int], words: List[str]=['SEND', 'MORE', 'MONEY']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['SEND', 'MORE', 'MONEY']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_1",
    "sat": "def sat(li: List[int], words: List[str]=['FORTY', 'TEN', 'TEN', 'SIXTY']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['FORTY', 'TEN', 'TEN', 'SIXTY']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_2",
    "sat": "def sat(li: List[int], words: List[str]=['GREEN', 'ORANGE', 'COLORS']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['GREEN', 'ORANGE', 'COLORS']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_3",
    "sat": "def sat(li: List[int], words: List[str]=['eokm', 'zado', 'ooel', 'hmam', 'zkld', 'ehljo']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['eokm', 'zado', 'ooel', 'hmam', 'zkld', 'ehljo']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_4",
    "sat": "def sat(li: List[int], words: List[str]=['gdlg', 'ofok', 'empp', 'kokk', 'ddle', 'kmeg', 'dmpe', 'dmdd', 'egkyo']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['gdlg', 'ofok', 'empp', 'kokk', 'ddle', 'kmeg', 'dmpe', 'dmdd', 'egkyo']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_5",
    "sat": "def sat(li: List[int], words: List[str]=['hqhh', 'umbj', 'qnbk', 'jqkp', 'nqnu', 'blmpq']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['hqhh', 'umbj', 'qnbk', 'jqkp', 'nqnu', 'blmpq']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_6",
    "sat": "def sat(li: List[int], words: List[str]=['rreo', 'wdnd', 'rdpw', 'scpp', 'dccs', 'sjns', 'dcpd', 'pos', 'wcep', 'sdres']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['rreo', 'wdnd', 'rdpw', 'scpp', 'dccs', 'sjns', 'dcpd', 'pos', 'wcep', 'sdres']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_7",
    "sat": "def sat(li: List[int], words: List[str]=['qofb', 'eeq', 'hrfh', 'qbss', 'hhqs', 'ehvs', 'qsbz', 'efbqh']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['qofb', 'eeq', 'hrfh', 'qbss', 'hhqs', 'ehvs', 'qsbz', 'efbqh']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_8",
    "sat": "def sat(li: List[int], words: List[str]=['ddrg', 'rcch', 'ghejd']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['ddrg', 'rcch', 'ghejd']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  },
  {
    "name": "VerbalArithmetic_9",
    "sat": "def sat(li: List[int], words: List[str]=['ewnn', 'nrvt', 'nbv', 'neee', 'wtwt', 'awhw', 'aattv']):\n    assert type(li) is list and all(type(a) is int for a in li), 'li must be of type List[int]'\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "sols": [
      "def sol(words=['ewnn', 'nrvt', 'nbv', 'neee', 'wtwt', 'awhw', 'aattv']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ]
  }
]